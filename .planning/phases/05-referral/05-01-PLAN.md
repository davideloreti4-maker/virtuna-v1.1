---
phase: 05-referral
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/YYYYMMDDHHMMSS_referral_tables.sql
  - src/lib/referral/code-generator.ts
  - src/lib/referral/constants.ts
  - src/app/api/referral/generate/route.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "User can generate a unique referral code via API"
    - "Referral codes are stored in database with user association"
    - "Codes are URL-safe, collision-resistant, and human-friendly"
    - "Database schema supports click tracking and conversion attribution"
  artifacts:
    - path: "supabase/migrations/YYYYMMDDHHMMSS_referral_tables.sql"
      provides: "Database schema for referral system"
      contains: "CREATE TABLE referral_codes"
      min_lines: 80
    - path: "src/lib/referral/code-generator.ts"
      provides: "Code generation with nanoid"
      exports: ["generateReferralCode"]
      min_lines: 10
    - path: "src/app/api/referral/generate/route.ts"
      provides: "Referral code generation endpoint"
      exports: ["POST"]
      min_lines: 40
  key_links:
    - from: "src/app/api/referral/generate/route.ts"
      to: "src/lib/referral/code-generator.ts"
      via: "import generateReferralCode"
      pattern: "import.*generateReferralCode"
    - from: "src/app/api/referral/generate/route.ts"
      to: "supabase referral_codes table"
      via: "supabase.from insert"
      pattern: 'from\("referral_codes"\)\.insert'
    - from: "supabase/migrations/YYYYMMDDHHMMSS_referral_tables.sql"
      to: "wallet_transactions table"
      via: "CHECK constraint extension"
      pattern: "wallet_transactions.*CHECK.*referral"
---

<objective>
Create the database foundation and code generation API for the referral system.

Purpose: Enable users to generate unique referral codes stored in a normalized schema that supports click tracking, conversion attribution, and wallet transactions. This plan lays the groundwork for cookie-based tracking (Plan 05-02) and dashboard UI (Plan 05-03).

Output: Migration with 3 tables (referral_codes, referral_clicks, referral_conversions), wallet trigger, RLS policies, code generation utility, and API endpoint.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-referral/05-RESEARCH.md

# Existing Code
@src/types/database.types.ts
@src/lib/supabase/server.ts
@src/app/api/webhooks/whop/route.ts

# Phase 4 context (wallet_transactions already exists)
The wallet_transactions table is already created with:
- amount_cents (number)
- balance_after_cents (number)
- type (string with CHECK constraint)
- reference_type (string with CHECK constraint)
- reference_id (string, nullable)
- user_id (UUID, FK to auth.users)
- status, description, metadata, created_at

A Postgres trigger (calculate_balance_after) already handles atomic balance calculation.

Research shows we need to:
1. Extend wallet_transactions CHECK constraints to include 'referral_bonus' type and 'referral_conversion' reference_type
2. Create 3 new tables: referral_codes (one per user), referral_clicks (deduplicated), referral_conversions (unique per referred user)
3. Use nanoid with custom alphabet (no O, I, 0, 1) for 8-char codes = 31^8 = ~850B combinations
</context>

<tasks>

<task type="auto">
  <name>Install nanoid and create code generation utility</name>
  <files>
package.json
src/lib/referral/code-generator.ts
src/lib/referral/constants.ts
  </files>
  <action>
1. Install nanoid: `pnpm add nanoid`

2. Create `src/lib/referral/constants.ts` with cookie configuration:
```typescript
export const REFERRAL_COOKIE_NAME = "virtuna_referral";
export const REFERRAL_COOKIE_MAX_AGE = 60 * 60 * 24 * 30; // 30 days
export const REFERRAL_BONUS_CENTS = 1000; // $10 (business decision - parameterize later)
```

3. Create `src/lib/referral/code-generator.ts`:
```typescript
import { customAlphabet } from "nanoid";

// Alphanumeric uppercase only (avoid confusion: O vs 0, I vs 1, l vs 1)
const alphabet = "23456789ABCDEFGHJKLMNPQRSTUVWXYZ"; // 31 chars
const nanoid = customAlphabet(alphabet, 8); // 8 chars = 31^8 = ~850 billion combinations

export function generateReferralCode(): string {
  return nanoid();
}
```

Per research: "Use nanoid with custom alphabet (no O, I, 0, 1) for 8-char codes"
  </action>
  <verify>
1. `grep "nanoid" package.json` shows dependency installed
2. `cat src/lib/referral/constants.ts` shows cookie config and bonus amount
3. `cat src/lib/referral/code-generator.ts` shows customAlphabet with 31-char set and 8-char length
4. `npx tsc --noEmit` passes (no type errors)
  </verify>
  <done>
nanoid installed, code-generator.ts exports generateReferralCode with collision-resistant config, constants.ts defines cookie/bonus config
  </done>
</task>

<task type="auto">
  <name>Create referral database tables with wallet integration</name>
  <files>
supabase/migrations/YYYYMMDDHHMMSS_referral_tables.sql
  </files>
  <action>
Create migration file with timestamp (use current date/time in format YYYYMMDDHHMMSS, e.g., 20260213120000).

Migration must include:

1. **referral_codes table** (one per user):
   - id (UUID PRIMARY KEY DEFAULT gen_random_uuid())
   - user_id (UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE)
   - code (TEXT NOT NULL UNIQUE)
   - created_at (TIMESTAMPTZ DEFAULT NOW())
   - Indexes: idx_referral_codes_user_id, idx_referral_codes_code (UNIQUE)

2. **referral_clicks table** (track link clicks with deduplication):
   - id (UUID PRIMARY KEY DEFAULT gen_random_uuid())
   - referral_code (TEXT NOT NULL REFERENCES referral_codes(code) ON DELETE CASCADE)
   - referrer_user_id (UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE)
   - referred_user_id (UUID REFERENCES auth.users(id) ON DELETE SET NULL) -- NULL until signup
   - clicked_at (TIMESTAMPTZ DEFAULT NOW())
   - referrer_url (TEXT, nullable)
   - user_agent (TEXT, nullable)
   - ip_hash (TEXT, nullable)
   - UNIQUE(referred_user_id, referral_code) -- deduplication: one click per user per code
   - Indexes: idx_referral_clicks_referral_code, idx_referral_clicks_referrer_user_id, idx_referral_clicks_clicked_at

3. **referral_conversions table** (track purchases, one per referred user):
   - id (UUID PRIMARY KEY DEFAULT gen_random_uuid())
   - referrer_user_id (UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE)
   - referred_user_id (UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE) -- One conversion per user (idempotency)
   - referral_code (TEXT NOT NULL REFERENCES referral_codes(code) ON DELETE CASCADE)
   - whop_membership_id (TEXT NOT NULL)
   - bonus_cents (INTEGER NOT NULL)
   - converted_at (TIMESTAMPTZ DEFAULT NOW())
   - metadata (JSONB, nullable)
   - Indexes: idx_referral_conversions_referrer_user_id, idx_referral_conversions_referred_user_id, idx_referral_conversions_referred_user_unique (UNIQUE)

4. **RLS policies** (enable RLS on all three tables):
   - referral_codes: users can SELECT/INSERT their own codes (user_id = auth.uid())
   - referral_clicks: users can SELECT clicks on their codes (referrer_user_id = auth.uid())
   - referral_conversions: users can SELECT conversions they generated (referrer_user_id = auth.uid())

5. **Extend wallet_transactions CHECK constraints**:
   - ALTER TABLE wallet_transactions DROP CONSTRAINT IF EXISTS wallet_transactions_type_check;
   - ALTER TABLE wallet_transactions ADD CONSTRAINT wallet_transactions_type_check CHECK (type IN ('deal_payment', 'affiliate_commission', 'referral_bonus', 'withdrawal', 'adjustment'));
   - ALTER TABLE wallet_transactions DROP CONSTRAINT IF EXISTS wallet_transactions_reference_type_check;
   - ALTER TABLE wallet_transactions ADD CONSTRAINT wallet_transactions_reference_type_check CHECK (reference_type IN ('deal_enrollment', 'affiliate_conversion', 'referral_conversion', 'manual'));

6. **Wallet balance trigger** (already exists from Phase 4, do NOT recreate):
   - Add comment: "-- NOTE: calculate_balance_after trigger already exists from Phase 4 (payment system)"

Use the exact schema from research (RESEARCH.md lines 563-681) with all indexes and constraints.
  </action>
  <verify>
1. Migration file exists: `ls supabase/migrations/*_referral_tables.sql`
2. File contains CREATE TABLE statements for referral_codes, referral_clicks, referral_conversions
3. File contains UNIQUE constraints: referral_codes(code), referral_codes(user_id), referral_clicks(referred_user_id, referral_code), referral_conversions(referred_user_id)
4. File contains RLS policies for all three tables
5. File extends wallet_transactions CHECK constraints with 'referral_bonus' and 'referral_conversion'
6. File does NOT recreate calculate_balance_after trigger (comment confirms it exists)
7. `npx supabase db reset` succeeds (applies migration locally)
  </verify>
  <done>
Migration created with 3 referral tables, RLS policies, wallet integration, and all constraints from research. Local database reset succeeds.
  </done>
</task>

<task type="auto">
  <name>Create referral code generation API endpoint</name>
  <files>
src/app/api/referral/generate/route.ts
  </files>
  <action>
Create POST endpoint at `/api/referral/generate` that:

1. Authenticates user via Supabase server client
2. Checks if user already has a code (SELECT from referral_codes WHERE user_id = auth.uid())
3. If exists, returns existing code: `{ code: string }`
4. If not, generates new code with collision retry logic:
   - Call generateReferralCode()
   - INSERT into referral_codes (user_id, code, created_at)
   - On unique constraint violation (error.code === "23505"), retry up to 5 attempts
   - On success, return: `{ code: string }`
   - On other errors, return 500: `{ error: string }`

Implementation must match research pattern (RESEARCH.md lines 301-358):
- Use createClient from @/lib/supabase/server
- Auth check: if (!user) return 401
- Use maybeSingle() for existing check (handles no rows gracefully)
- Retry loop with maxAttempts = 5
- Check error.code === "23505" for collision
- Return NextResponse.json with appropriate status codes

Per research: "Generate new code with collision retry" and "nanoid with retry logic"
  </action>
  <verify>
1. `cat src/app/api/referral/generate/route.ts` shows POST export
2. Endpoint imports generateReferralCode from @/lib/referral/code-generator
3. Endpoint imports createClient from @/lib/supabase/server
4. Endpoint checks auth with supabase.auth.getUser()
5. Endpoint uses maybeSingle() to check for existing code
6. Endpoint has retry loop (maxAttempts = 5) on collision (error.code === "23505")
7. `npx tsc --noEmit` passes
8. Test locally: `curl -X POST http://localhost:3000/api/referral/generate -H "Cookie: <auth-cookie>"` returns JSON with code field
  </verify>
  <done>
/api/referral/generate endpoint created with auth, existing check, collision retry (5 attempts), and proper error handling. TypeScript passes, manual test confirms code generation.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Database schema**: `npx supabase db reset` succeeds without errors
2. **Types updated**: Run `pnpm supabase:types` to regenerate database.types.ts with new tables
3. **Code generation**: Call `/api/referral/generate` as authenticated user, verify code is 8 chars, alphanumeric uppercase (no O, I, 0, 1)
4. **Idempotency**: Call `/api/referral/generate` twice, verify same code returned
5. **Collision handling**: No manual test needed (8-char nanoid has 850B combinations, collision extremely unlikely in dev)
6. **Wallet constraints**: Verify wallet_transactions CHECK constraints include 'referral_bonus' and 'referral_conversion': `\d+ wallet_transactions` in psql shows updated constraints
</verification>

<success_criteria>
- [x] nanoid installed in package.json
- [x] src/lib/referral/code-generator.ts exports generateReferralCode with custom alphabet (31 chars, 8 length)
- [x] src/lib/referral/constants.ts defines cookie config and bonus amount
- [x] Migration file creates referral_codes, referral_clicks, referral_conversions with all indexes and UNIQUE constraints
- [x] Migration enables RLS on all three tables with appropriate policies
- [x] Migration extends wallet_transactions CHECK constraints to support referral_bonus and referral_conversion
- [x] /api/referral/generate returns unique 8-char code for authenticated users
- [x] Endpoint returns same code on subsequent calls (idempotent)
- [x] TypeScript compiles without errors
- [x] Local database reset succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/05-referral/05-01-SUMMARY.md` following the template at `/Users/davideloreti/.claude/get-shit-done/templates/summary.md`.

Include:
- Migration filename
- Generated referral code example (from manual test)
- Confirmation of wallet_transactions constraint extension
- Note that calculate_balance_after trigger already exists (not recreated)
</output>
