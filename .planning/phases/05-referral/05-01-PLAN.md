---
phase: 05-referral
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/supabase/middleware.ts
  - supabase/migrations/20260216000000_referral_clicks_insert_policy.sql
autonomous: true

must_haves:
  truths:
    - "Referral cookie persists through Supabase session refresh (middleware setAll does not destroy it)"
    - "OAuth callback can insert referral click records without RLS blocking the write"
    - "Existing referral cookie is not overwritten when user clicks a different referral link"
  artifacts:
    - path: "src/lib/supabase/middleware.ts"
      provides: "Referral cookie re-applied after Supabase response re-creation"
      contains: "REFERRAL_COOKIE_NAME"
    - path: "supabase/migrations/20260216000000_referral_clicks_insert_policy.sql"
      provides: "RLS INSERT policy for referral_clicks allowing service-role and authenticated user inserts during OAuth callback"
      contains: "referral_clicks"
  key_links:
    - from: "src/lib/supabase/middleware.ts"
      to: "src/lib/referral/constants.ts"
      via: "import REFERRAL_COOKIE_NAME, REFERRAL_COOKIE_MAX_AGE"
      pattern: "REFERRAL_COOKIE_NAME"
    - from: "src/app/auth/callback/route.ts"
      to: "supabase referral_clicks table"
      via: "supabase.from('referral_clicks').insert()"
      pattern: "referral_clicks.*insert"
---

<objective>
Fix two critical bugs in the referral tracking pipeline that would cause silent failures in production.

Purpose: Without these fixes, (1) the referral cookie set in middleware is destroyed when Supabase refreshes the session (setAll re-creates the response object, losing the cookie), and (2) the OAuth callback's attempt to insert referral click records is blocked by RLS (no INSERT policy exists on referral_clicks for authenticated users).

Output: Patched middleware with referral cookie persistence + new Supabase migration adding INSERT policy.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/supabase/middleware.ts
@src/lib/referral/constants.ts
@src/app/auth/callback/route.ts
@supabase/migrations/20260213140000_referral_tables.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix middleware referral cookie lost on Supabase response re-creation</name>
  <files>src/lib/supabase/middleware.ts</files>
  <action>
    The middleware has a bug: on lines 58-69, the referral cookie is set on `supabaseResponse`. But on lines 80-89, when Supabase's `setAll` callback fires, it re-creates `supabaseResponse` via `NextResponse.next()`, destroying the referral cookie.

    Fix: Track the referral code in a local variable, then re-apply the referral cookie AFTER the Supabase auth check completes (after line 97's `getUser()` call). This ensures the cookie survives any response re-creation by Supabase.

    Specific changes:
    1. Remove the cookie setting from lines 60-69 (the early set before Supabase client creation)
    2. After the `getUser()` call and before returning the response, add a block that checks if `referralCode` is set AND the request doesn't already have a `REFERRAL_COOKIE_NAME` cookie, then set the referral cookie on whatever `supabaseResponse` currently is
    3. Also preserve the existing `!request.cookies.get(REFERRAL_COOKIE_NAME)` guard to avoid overwriting existing referral attribution ("first click wins")

    The fix pattern:
    ```typescript
    // At top of updateSession (before Supabase client):
    const referralCode = request.nextUrl.searchParams.get("ref");

    // ... Supabase client creation + getUser() ...

    // After getUser(), before returning:
    if (referralCode && !request.cookies.get(REFERRAL_COOKIE_NAME)) {
      supabaseResponse.cookies.set({
        name: REFERRAL_COOKIE_NAME,
        value: referralCode,
        path: "/",
        secure: true,
        httpOnly: true,
        sameSite: "lax",
        maxAge: REFERRAL_COOKIE_MAX_AGE,
      });
    }
    ```

    Do NOT change any other middleware logic (protected paths, public paths, auth redirects).
  </action>
  <verify>
    - TypeScript compiles: `npx tsc --noEmit` passes (or at least no new errors in middleware.ts)
    - The referral cookie set block appears AFTER the `getUser()` call
    - The `!request.cookies.get(REFERRAL_COOKIE_NAME)` guard is present (first-click-wins)
  </verify>
  <done>
    Referral cookie is set on the final `supabaseResponse` object, after all Supabase response re-creations, ensuring it persists through the full middleware lifecycle.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add RLS INSERT policy for referral_clicks table</name>
  <files>supabase/migrations/20260216000000_referral_clicks_insert_policy.sql</files>
  <action>
    Create a new Supabase migration file that adds an INSERT policy on `referral_clicks` for authenticated users.

    The OAuth callback at `/auth/callback` uses a user-scoped Supabase client to insert referral click records. Currently, RLS blocks this because only a SELECT policy exists on `referral_clicks` (for `referrer_user_id = auth.uid()`). The INSERT needs to allow the referred user to create a click record where they are the `referred_user_id`.

    Migration content:
    ```sql
    -- Allow authenticated users to create referral click records
    -- (during OAuth callback, the referred user inserts their own click)
    CREATE POLICY "Authenticated users can create referral clicks"
      ON referral_clicks FOR INSERT
      TO authenticated
      WITH CHECK (referred_user_id = (SELECT auth.uid()));
    ```

    This is safe because:
    - The `referred_user_id` must match the authenticated user (can't fake referrals for other users)
    - The UNIQUE constraint on `(referred_user_id, referral_code)` prevents duplicate clicks
    - The `referrer_user_id` is looked up from `referral_codes` table (not user-supplied)
  </action>
  <verify>
    - Migration file exists at `supabase/migrations/20260216000000_referral_clicks_insert_policy.sql`
    - SQL syntax is valid (CREATE POLICY with WITH CHECK clause)
    - Policy targets `authenticated` role and restricts `referred_user_id` to `auth.uid()`
  </verify>
  <done>
    RLS INSERT policy on referral_clicks allows authenticated users to insert click records where they are the referred user, enabling the OAuth callback to track referral clicks.
  </done>
</task>

</tasks>

<verification>
1. `grep -n "REFERRAL_COOKIE_NAME" src/lib/supabase/middleware.ts` shows the cookie set block appears AFTER `getUser()`
2. Migration file exists and contains CREATE POLICY ... FOR INSERT
3. TypeScript compiles without new errors related to middleware.ts
</verification>

<success_criteria>
- Middleware referral cookie survives Supabase `setAll` response re-creation
- referral_clicks table has INSERT policy for authenticated users
- Both files committed and ready for deployment
</success_criteria>

<output>
After completion, create `.planning/phases/05-referral/05-01-SUMMARY.md`
</output>
