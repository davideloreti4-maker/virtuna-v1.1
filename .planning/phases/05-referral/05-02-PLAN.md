---
phase: 05-referral
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/middleware.ts
  - src/lib/supabase/middleware.ts
  - src/app/api/auth/callback/route.ts
  - src/app/api/webhooks/whop/route.ts
  - src/app/api/referral/stats/route.ts
autonomous: true

must_haves:
  truths:
    - "Clicking a ?ref=CODE link sets a server-side cookie that persists through OAuth"
    - "After OAuth callback, referral cookie is re-set and click is logged in database"
    - "When referred user purchases via Whop, referrer receives $10 bonus in wallet"
    - "Conversion attribution is idempotent (duplicate webhooks don't create duplicate bonuses)"
    - "Users can fetch their referral stats (clicks, conversions, earnings)"
  artifacts:
    - path: "src/lib/supabase/middleware.ts"
      provides: "Referral cookie detection and setting"
      contains: "virtuna_referral"
      min_lines: 65
    - path: "src/app/api/auth/callback/route.ts"
      provides: "Referral click logging after OAuth"
      contains: "referral_clicks"
      min_lines: 50
    - path: "src/app/api/webhooks/whop/route.ts"
      provides: "Conversion attribution on purchase"
      contains: "referral_conversions"
      min_lines: 220
    - path: "src/app/api/referral/stats/route.ts"
      provides: "Referral stats API"
      exports: ["GET"]
      min_lines: 40
  key_links:
    - from: "src/lib/supabase/middleware.ts"
      to: "REFERRAL_COOKIE_NAME constant"
      via: "import from constants"
      pattern: "import.*REFERRAL_COOKIE_NAME"
    - from: "src/app/api/auth/callback/route.ts"
      to: "referral_clicks table"
      via: "supabase.from insert"
      pattern: 'from\("referral_clicks"\)\.insert'
    - from: "src/app/api/webhooks/whop/route.ts"
      to: "referral_conversions table"
      via: "supabase.from insert"
      pattern: 'from\("referral_conversions"\)\.insert'
    - from: "src/app/api/webhooks/whop/route.ts"
      to: "wallet_transactions table"
      via: "bonus credit insert"
      pattern: 'from\("wallet_transactions"\)\.insert'
---

<objective>
Implement cookie-based referral tracking that survives OAuth redirects and webhook-based conversion attribution that credits referrers when purchases complete.

Purpose: Connect the database foundation (Plan 05-01) to real user behavior — tracking clicks, persisting attribution through authentication, and rewarding referrers. This enables the dashboard UI (Plan 05-03) to show meaningful stats.

Output: Middleware cookie tracking, OAuth callback click logging, webhook conversion handler with wallet crediting, and stats API.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-referral/05-RESEARCH.md
@.planning/phases/05-referral/05-01-SUMMARY.md

# Existing Code
@src/middleware.ts
@src/lib/supabase/middleware.ts
@src/app/api/auth/callback/route.ts
@src/app/api/webhooks/whop/route.ts

# Cookie Persistence Through OAuth
Research shows SameSite=Lax (NOT Strict) is critical for OAuth redirect survival:
- SameSite=Strict blocks cookies on cross-origin navigations (Supabase OAuth is cross-origin)
- SameSite=Lax allows cookies on top-level GET navigations (OAuth callback)
- Must re-set cookie in auth callback after OAuth completes

# Webhook Attribution Logic
On membership.went_valid:
1. Query referral_clicks for referred_user_id (most recent click)
2. Check referral_conversions for existing conversion (idempotency)
3. If no existing conversion, insert conversion + wallet transaction
4. Wallet balance calculated by existing trigger (atomic, no race conditions)

# Idempotency Pattern
- UNIQUE constraint on referral_conversions(referred_user_id) prevents duplicates
- Check maybeSingle() before inserting conversion
- If already exists, skip (webhook retry case)
</context>

<tasks>

<task type="auto">
  <name>Add referral cookie detection and setting to middleware</name>
  <files>
src/lib/supabase/middleware.ts
  </files>
  <action>
Modify updateSession function to detect ?ref=CODE query param and set first-party cookie BEFORE auth check.

Changes:
1. Import REFERRAL_COOKIE_NAME and REFERRAL_COOKIE_MAX_AGE from @/lib/referral/constants
2. At start of updateSession (before creating supabase client), check request.nextUrl.searchParams.get("ref")
3. If referralCode exists:
   - Check if cookie already set: request.cookies.get(REFERRAL_COOKIE_NAME)
   - If cookie NOT already set (first click), set cookie on supabaseResponse:
     ```typescript
     supabaseResponse.cookies.set({
       name: REFERRAL_COOKIE_NAME,
       value: referralCode,
       path: "/",
       secure: true,
       httpOnly: true,
       sameSite: "lax", // CRITICAL: NOT "strict"
       maxAge: REFERRAL_COOKIE_MAX_AGE,
     });
     ```
4. Continue with existing auth logic (no changes to PROTECTED_ROUTES handling)

Per research (RESEARCH.md lines 86-113): "Set first-party cookie with SameSite=Lax (survives OAuth redirect)" and "Check for existing referral cookie before setting new one (deduplication)"

IMPORTANT: Only set cookie if it's NOT already present (prevents overwriting existing attribution from earlier click).
  </action>
  <verify>
1. `grep "REFERRAL_COOKIE_NAME" src/lib/supabase/middleware.ts` shows import from constants
2. Middleware checks searchParams.get("ref") before supabase client creation
3. Middleware checks request.cookies.get(REFERRAL_COOKIE_NAME) before setting
4. Cookie config has sameSite: "lax" (NOT "strict")
5. Cookie config has httpOnly: true, secure: true, maxAge from constant
6. `npx tsc --noEmit` passes
7. Manual test: Visit `http://localhost:3000/?ref=TEST123`, verify cookie set in browser DevTools (Application -> Cookies -> localhost:3000 -> virtuna_referral=TEST123)
  </verify>
  <done>
Middleware detects ?ref= param, sets first-party cookie with SameSite=Lax (only if not already set), preserves existing auth logic. Manual test confirms cookie persistence.
  </done>
</task>

<task type="auto">
  <name>Log referral click in auth callback after OAuth</name>
  <files>
src/app/api/auth/callback/route.ts
  </files>
  <action>
Modify GET handler to retrieve referral cookie after successful auth exchange and log click to database.

Changes to existing logic (after `supabase.auth.exchangeCodeForSession(code)` succeeds):

1. Retrieve cookie from request headers:
   ```typescript
   const cookieHeader = request.headers.get("cookie");
   const referralCode = cookieHeader
     ?.split(";")
     .find((c) => c.trim().startsWith("virtuna_referral="))
     ?.split("=")[1]
     ?.trim();
   ```

2. If referralCode exists AND data.user exists:
   - First, get referrer_user_id from referral_codes table:
     ```typescript
     const { data: codeData } = await supabase
       .from("referral_codes")
       .select("user_id")
       .eq("code", referralCode)
       .maybeSingle();
     ```
   - If codeData exists (code is valid), insert click with deduplication handling:
     ```typescript
     await supabase.from("referral_clicks").insert({
       referral_code: referralCode,
       referrer_user_id: codeData.user_id,
       referred_user_id: data.user.id,
       clicked_at: new Date().toISOString(),
     });
     ```
     Note: UNIQUE(referred_user_id, referral_code) constraint handles deduplication — insert will fail silently if duplicate

3. Create redirect response and re-set cookie (ensures persistence after OAuth):
   ```typescript
   const response = NextResponse.redirect(`${origin}${next}`);
   if (referralCode) {
     response.cookies.set({
       name: "virtuna_referral",
       value: referralCode,
       path: "/",
       secure: true,
       httpOnly: true,
       sameSite: "lax",
       maxAge: 60 * 60 * 24 * 30,
     });
   }
   return response;
   ```

4. Update final redirect (non-auth case) to also return updated response (not critical, but maintains consistency)

Per research (RESEARCH.md lines 115-168): "Retrieve referral cookie set in middleware" and "Re-set cookie after auth (ensures persistence)"

IMPORTANT: Insert will fail on duplicate (UNIQUE constraint) but we don't care — idempotency is handled at DB level.
  </action>
  <verify>
1. Auth callback imports supabase from @/lib/supabase/server (already exists)
2. After exchangeCodeForSession succeeds, callback retrieves cookie from request.headers
3. Callback queries referral_codes to get referrer_user_id
4. Callback inserts into referral_clicks (referral_code, referrer_user_id, referred_user_id, clicked_at)
5. Callback re-sets cookie on response with SameSite=Lax
6. `npx tsc --noEmit` passes
7. Integration test: Visit /?ref=CODE, sign up, check database — referral_clicks has row with referred_user_id
  </verify>
  <done>
Auth callback retrieves referral cookie, logs click (with referrer lookup), re-sets cookie after OAuth. Database insert handles deduplication via UNIQUE constraint.
  </done>
</task>

<task type="auto">
  <name>Add conversion attribution to Whop webhook handler</name>
  <files>
src/app/api/webhooks/whop/route.ts
  </files>
  <action>
Extend membership.went_valid case to check for referral conversion and credit referrer's wallet.

Add logic AFTER existing subscription upsert (lines 68-89) but BEFORE break statement:

1. Query referral_clicks for this user (most recent click):
   ```typescript
   const { data: clickData } = await supabase
     .from("referral_clicks")
     .select("referral_code, referrer_user_id")
     .eq("referred_user_id", supabaseUserId)
     .order("clicked_at", { ascending: false })
     .limit(1)
     .maybeSingle();
   ```

2. If clickData exists (user was referred):
   - Check for existing conversion (idempotency):
     ```typescript
     const { data: existingConversion } = await supabase
       .from("referral_conversions")
       .select("id")
       .eq("referred_user_id", supabaseUserId)
       .maybeSingle();
     ```
   - If existingConversion does NOT exist:
     a. Import REFERRAL_BONUS_CENTS from @/lib/referral/constants
     b. Insert conversion:
        ```typescript
        const { data: conversion, error: conversionError } = await supabase
          .from("referral_conversions")
          .insert({
            referrer_user_id: clickData.referrer_user_id,
            referred_user_id: supabaseUserId,
            referral_code: clickData.referral_code,
            whop_membership_id: data.id,
            bonus_cents: REFERRAL_BONUS_CENTS,
            converted_at: new Date().toISOString(),
          })
          .select("id, bonus_cents")
          .single();
        ```
     c. If conversion succeeds (no error), credit wallet:
        ```typescript
        await supabase.from("wallet_transactions").insert({
          user_id: clickData.referrer_user_id,
          amount_cents: conversion.bonus_cents,
          type: "referral_bonus",
          reference_type: "referral_conversion",
          reference_id: conversion.id,
          description: `Referral bonus for ${clickData.referral_code}`,
          status: "completed",
        });
        ```
     d. If conversionError, log to console but don't fail webhook (silent failure for bonus, subscription upsert already succeeded)

3. Add comment: "// NOTE: Wallet balance calculated by calculate_balance_after trigger (atomic)"

Per research (RESEARCH.md lines 183-278): "Check for referral conversion" and "Credit referrer's wallet (trigger handles balance calculation)"

IMPORTANT:
- Conversion attribution happens AFTER subscription upsert (purchase is primary operation)
- UNIQUE(referred_user_id) on referral_conversions prevents double credits on webhook retry
- Wallet trigger handles balance_after_cents calculation (no manual SUM queries)
  </action>
  <verify>
1. Webhook handler imports REFERRAL_BONUS_CENTS from @/lib/referral/constants
2. membership.went_valid case queries referral_clicks after subscription upsert
3. Handler checks for existing conversion (maybeSingle on referral_conversions)
4. If no existing conversion, handler inserts conversion + wallet transaction
5. Wallet transaction uses type: "referral_bonus", reference_type: "referral_conversion"
6. `npx tsc --noEmit` passes
7. Integration test: Create referral link, sign up as referred user, purchase via Whop sandbox, check database — referral_conversions and wallet_transactions have rows
  </verify>
  <done>
Webhook handler attributes conversions to referrers on membership.went_valid, credits $10 to wallet (calculated by trigger), with idempotency via UNIQUE constraint.
  </done>
</task>

<task type="auto">
  <name>Create referral stats API endpoint</name>
  <files>
src/app/api/referral/stats/route.ts
  </files>
  <action>
Create GET endpoint at `/api/referral/stats` that returns aggregated referral statistics.

Implementation:
1. Authenticate user via Supabase server client
2. Query referral_clicks count: `supabase.from("referral_clicks").select("id", { count: "exact" }).eq("referrer_user_id", user.id)`
3. Query referral_conversions with bonus sum:
   ```typescript
   const { data: conversions } = await supabase
     .from("referral_conversions")
     .select("bonus_cents")
     .eq("referrer_user_id", user.id);
   ```
4. Calculate totals:
   ```typescript
   const totalClicks = clicksCount || 0;
   const totalConversions = conversions?.length || 0;
   const totalEarningsCents = conversions?.reduce((sum, c) => sum + c.bonus_cents, 0) || 0;
   ```
5. Return JSON:
   ```typescript
   return NextResponse.json({
     clicks: totalClicks,
     conversions: totalConversions,
     earningsCents: totalEarningsCents,
   });
   ```

If user not authenticated, return 401: `{ error: "Unauthorized" }`

Per dashboard needs (Plan 05-03 will consume this API): clicks, conversions, earnings
  </action>
  <verify>
1. `cat src/app/api/referral/stats/route.ts` shows GET export
2. Endpoint imports createClient from @/lib/supabase/server
3. Endpoint authenticates user with supabase.auth.getUser()
4. Endpoint queries referral_clicks with count
5. Endpoint queries referral_conversions and sums bonus_cents
6. Endpoint returns JSON with clicks, conversions, earningsCents fields
7. `npx tsc --noEmit` passes
8. Manual test: `curl http://localhost:3000/api/referral/stats -H "Cookie: <auth-cookie>"` returns JSON with numeric fields
  </verify>
  <done>
/api/referral/stats endpoint created, returns aggregated stats (clicks, conversions, earnings) for authenticated users.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Cookie tracking**: Visit `/?ref=TESTCODE`, verify cookie set in browser (virtuna_referral=TESTCODE, SameSite=Lax)
2. **OAuth persistence**: Click referral link, sign up, check cookie still exists after redirect to /dashboard
3. **Click logging**: After signup via referral link, check database — referral_clicks has row with referred_user_id and referrer_user_id
4. **Conversion attribution**: Trigger Whop webhook (use ngrok + Whop dashboard test mode OR mock webhook in local dev), verify referral_conversions + wallet_transactions rows created
5. **Idempotency**: Send duplicate webhook, verify no duplicate conversion (UNIQUE constraint prevents)
6. **Stats API**: Call /api/referral/stats, verify response shows clicks=1, conversions=1 (if conversion triggered), earningsCents=1000
7. **Wallet balance**: Query wallet_transactions for referrer, verify balance_after_cents correctly calculated by trigger
</verification>

<success_criteria>
- [x] Middleware sets referral cookie on ?ref= detection with SameSite=Lax
- [x] Middleware only sets cookie if not already present (deduplication)
- [x] Auth callback retrieves cookie, logs click (with referrer lookup), re-sets cookie
- [x] Webhook handler checks for referral on membership.went_valid
- [x] Webhook handler credits referrer wallet with $10 bonus (REFERRAL_BONUS_CENTS)
- [x] Conversion attribution is idempotent (UNIQUE constraint prevents duplicates)
- [x] Stats API returns clicks, conversions, earningsCents for authenticated users
- [x] TypeScript compiles without errors
- [x] Integration test: referral link → signup → purchase → wallet credit succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/05-referral/05-02-SUMMARY.md` following the template.

Include:
- Cookie test results (SameSite value confirmed in browser DevTools)
- Click logging confirmation (referral_clicks row details)
- Conversion attribution test results (referral_conversions + wallet_transactions rows)
- Stats API response example
- Note on idempotency mechanism (UNIQUE constraint)
</output>
