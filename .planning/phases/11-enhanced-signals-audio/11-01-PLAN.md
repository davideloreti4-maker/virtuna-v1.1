---
phase: 11-enhanced-signals-audio
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/engine/fuzzy.ts
  - src/lib/engine/trends.ts
  - src/lib/engine/aggregator.ts
  - src/app/api/cron/calculate-trends/route.ts
autonomous: true

must_haves:
  truths:
    - "Sound matching returns similarity score > 0.7 for close-but-not-exact sound names"
    - "Substring-based matching in enrichWithTrends is replaced by Jaro-Winkler similarity"
    - "audioTrendingMatch in FeatureVector is populated with the best fuzzy match score"
    - "Trend phase classification factors in absolute volume alongside growth rate"
    - "A sound with high absolute views but flat growth is classified as peak (not declining)"
  artifacts:
    - path: "src/lib/engine/fuzzy.ts"
      provides: "Jaro-Winkler similarity function"
      exports: ["jaroWinklerSimilarity"]
    - path: "src/lib/engine/trends.ts"
      provides: "Fuzzy sound matching in enrichWithTrends"
      contains: "jaroWinklerSimilarity"
    - path: "src/lib/engine/aggregator.ts"
      provides: "audioTrendingMatch wired to best fuzzy match score"
      contains: "audioTrendingMatch"
    - path: "src/app/api/cron/calculate-trends/route.ts"
      provides: "Volume-aware trend phase classification"
      contains: "classifyTrendPhase"
  key_links:
    - from: "src/lib/engine/trends.ts"
      to: "src/lib/engine/fuzzy.ts"
      via: "import jaroWinklerSimilarity"
      pattern: "import.*jaroWinklerSimilarity.*from.*fuzzy"
    - from: "src/lib/engine/aggregator.ts"
      to: "TrendEnrichment.matched_trends"
      via: "best match similarity score populates audioTrendingMatch"
      pattern: "audioTrendingMatch"
---

<objective>
Replace substring-based sound matching with Jaro-Winkler fuzzy similarity, fix trend phase classification to account for absolute volume, and wire audioTrendingMatch into the FeatureVector.

Purpose: Current sound matching uses exact substring which misses similar sound names (e.g., "original sound - creator" vs "Original Sound - Creator"). Trend phase classification only uses growth rate, so a high-volume sound with flat growth is wrongly classified as "declining".

Output: `src/lib/engine/fuzzy.ts` with pure-TypeScript Jaro-Winkler, updated `trends.ts` with fuzzy matching, updated `calculate-trends/route.ts` with volume-aware classification, updated `aggregator.ts` with audioTrendingMatch wiring.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/engine/trends.ts
@src/lib/engine/types.ts
@src/lib/engine/aggregator.ts
@src/app/api/cron/calculate-trends/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Jaro-Winkler fuzzy module + integrate into sound matching</name>
  <files>src/lib/engine/fuzzy.ts, src/lib/engine/trends.ts</files>
  <action>
    Create `src/lib/engine/fuzzy.ts` with a pure TypeScript Jaro-Winkler similarity function:

    1. **`jaroWinklerSimilarity(s1: string, s2: string): number`** — returns 0-1 similarity score.
       - Implement standard Jaro distance first: matches within floor(max(|s1|,|s2|)/2)-1 window, transpositions counted as half.
       - Apply Winkler modification: boost = min(4, common prefix length) * 0.1 * (1 - jaro). Final = jaro + boost.
       - Case-insensitive comparison (lowercase both inputs internally).
       - Edge cases: identical strings → 1.0, empty string → 0.0, single char strings handled.

    2. Update `src/lib/engine/trends.ts` — replace the substring matching in `enrichWithTrends`:
       - Import `jaroWinklerSimilarity` from `./fuzzy`.
       - Replace the `contentLower.includes(soundLower)` check (line ~54) with:
         ```
         const similarity = jaroWinklerSimilarity(soundLower, contentLower);
         ```
         BUT since content is full text and sound_name is a short phrase, do a **sliding window match**: split content into words/phrases and find the best similarity score against the sound name. Specifically:
         - Extract sound name candidates from content: split by common delimiters, also check if content contains the sound name words.
         - For efficiency, first check if `contentLower.includes(soundLower)` (exact substring = 1.0 score).
         - If no exact match, compute Jaro-Winkler between the sound name and each potential phrase in the content.
         - Match threshold: >= 0.7.
       - Store the best match similarity score for use in FeatureVector.
       - Update `TrendEnrichment` usage: the function should additionally return `best_match_score: number | null` alongside the existing fields. Add this field to the return value (not the interface — the interface is in types.ts and gets updated later by aggregator wiring).
       - Track the highest similarity score across all matched sounds to pass to aggregator.

    Export: `jaroWinklerSimilarity` and `bestFuzzyMatch(target: string, content: string, threshold?: number): { score: number; matched: boolean }` as a convenience wrapper.
  </action>
  <verify>
    ```bash
    npx tsc --noEmit src/lib/engine/fuzzy.ts src/lib/engine/trends.ts
    ```
    Confirm no type errors. Verify fuzzy.ts exports both functions.
  </verify>
  <done>
    - jaroWinklerSimilarity("kitten", "sitting") returns ~0.746
    - jaroWinklerSimilarity("original sound", "Original Sound") returns 1.0 (case insensitive)
    - enrichWithTrends uses fuzzy matching with 0.7 threshold instead of substring
    - Best match score tracked for FeatureVector wiring
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix trend phase classification + wire audioTrendingMatch in aggregator</name>
  <files>src/app/api/cron/calculate-trends/route.ts, src/lib/engine/aggregator.ts</files>
  <action>
    1. **Update `classifyTrendPhase` in `src/app/api/cron/calculate-trends/route.ts`:**

       Current logic only uses growth rate + velocity score but misclassifies high-volume flat-growth sounds as "declining". Fix:

       ```typescript
       function classifyTrendPhase(
         growthRate: number,
         velocityScore: number,
         totalViews: number // NEW parameter
       ): string {
         // High absolute volume with modest growth = peak (not declining)
         if (totalViews >= 500_000 && growthRate >= -0.2) return "peak";
         if (growthRate > 0.5 && velocityScore < 50) return "emerging";
         if (growthRate > 0.3 && velocityScore >= 50) return "rising";
         if (growthRate >= -0.1 && growthRate <= 0.3 && velocityScore >= 100) return "peak";
         return "declining";
       }
       ```

       Update the call site in `trendRecords` mapping to pass `data.total_views` as the third argument.

    2. **Wire `audioTrendingMatch` in `src/lib/engine/aggregator.ts`:**

       Currently line ~182 is `audioTrendingMatch: null` (placeholder). Replace with:
       - After the `enrichWithTrends` result is available in the aggregator (it receives `trendEnrichment: TrendEnrichment`), compute the best audio match score.
       - The `trendEnrichment.matched_trends` array contains matched sounds. If any matched, set `audioTrendingMatch` to the max `velocity_score / 100` (normalized 0-1) from matched trends. If none matched, keep `null`.
       - This wires the FeatureVector field that ml.ts already reads (`fv.audioTrendingMatch`).

       Replace:
       ```typescript
       // Audio (placeholder — Phase 11)
       audioTrendingMatch: null,
       ```
       With:
       ```typescript
       // Audio — best trending sound match score (0-1, null if no match)
       audioTrendingMatch: trendEnrichment.matched_trends.length > 0
         ? Math.min(1, Math.max(...trendEnrichment.matched_trends.map(t => t.velocity_score)) / 100)
         : null,
       ```

       Also replace the `hashtagRelevance: 0` placeholder comment with a note pointing to Plan 11-02.
  </action>
  <verify>
    ```bash
    npx tsc --noEmit src/app/api/cron/calculate-trends/route.ts src/lib/engine/aggregator.ts
    ```
    Confirm no type errors. Verify classifyTrendPhase now accepts 3 parameters.
  </verify>
  <done>
    - classifyTrendPhase(0.0, 120, 1_000_000) returns "peak" (high volume, flat growth — was "declining" before)
    - classifyTrendPhase(0.6, 30, 5_000) returns "emerging" (low volume, high growth — unchanged)
    - audioTrendingMatch populated from matched_trends velocity scores instead of hardcoded null
    - hashtagRelevance placeholder updated with Phase 11-02 reference
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes across all modified files
2. `pnpm build` completes without errors
3. fuzzy.ts Jaro-Winkler produces expected scores for known string pairs
4. classifyTrendPhase correctly classifies high-volume flat-growth sounds as "peak"
5. audioTrendingMatch is no longer hardcoded null in FeatureVector assembly
</verification>

<success_criteria>
- Sound matching uses Jaro-Winkler fuzzy similarity (threshold > 0.7) instead of substring — SIG-01 satisfied
- Trend phase classification factors in absolute volume alongside growth rate — SIG-02 satisfied
- audioTrendingMatch FeatureVector field wired to real data from trend enrichment
</success_criteria>

<output>
After completion, create `.planning/phases/11-enhanced-signals-audio/11-01-SUMMARY.md`
</output>
