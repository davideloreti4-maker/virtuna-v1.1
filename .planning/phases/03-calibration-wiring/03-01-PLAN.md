---
phase: 03-calibration-wiring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/engine/aggregator.ts
  - src/lib/engine/types.ts
  - src/types/database.types.ts
  - src/app/api/analyze/route.ts
autonomous: true

must_haves:
  truths:
    - "aggregateScores() calls getPlattParameters() and applies applyPlattScaling() to overall_score before returning"
    - "When Platt params are null (< 50 outcomes), overall_score passes through unchanged and is_calibrated is false"
    - "When Platt params exist, overall_score is transformed by sigmoid and is_calibrated is true"
    - "Every analysis_results DB row includes an is_calibrated boolean value"
    - "pnpm build succeeds with no TypeScript errors"
  artifacts:
    - path: "src/lib/engine/aggregator.ts"
      provides: "Platt scaling wiring in aggregateScores"
      contains: "getPlattParameters"
    - path: "src/lib/engine/types.ts"
      provides: "is_calibrated field on PredictionResult"
      contains: "is_calibrated"
    - path: "src/types/database.types.ts"
      provides: "is_calibrated column in analysis_results type"
      contains: "is_calibrated"
    - path: "src/app/api/analyze/route.ts"
      provides: "is_calibrated persisted in DB insert"
      contains: "is_calibrated"
  key_links:
    - from: "src/lib/engine/aggregator.ts"
      to: "src/lib/engine/calibration.ts"
      via: "import { getPlattParameters, applyPlattScaling }"
      pattern: "import.*getPlattParameters.*from.*calibration"
    - from: "src/app/api/analyze/route.ts"
      to: "PredictionResult.is_calibrated"
      via: "finalResult.is_calibrated in DB insert"
      pattern: "is_calibrated.*finalResult"
---

<objective>
Wire Platt scaling into the aggregator and add the is_calibrated boolean to every prediction result.

Purpose: Connect the existing calibration infrastructure (getPlattParameters, applyPlattScaling in calibration.ts) to the score aggregation pipeline so that calibration activates automatically once enough outcome data accumulates. Add is_calibrated to the type, DB schema, and API response so consumers know whether a score was calibrated.

Output: Modified aggregator.ts, types.ts, database.types.ts, analyze/route.ts
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-calibration-wiring/03-RESEARCH.md
@src/lib/engine/calibration.ts
@src/lib/engine/aggregator.ts
@src/lib/engine/types.ts
@src/types/database.types.ts
@src/app/api/analyze/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire Platt scaling into aggregateScores and add is_calibrated to PredictionResult</name>
  <files>src/lib/engine/aggregator.ts, src/lib/engine/types.ts</files>
  <action>
**In `src/lib/engine/types.ts`:**
- Add `is_calibrated: boolean` to the `PredictionResult` interface, after `confidence_label` and before `behavioral_predictions`. Add comment: `// CAL-02: whether Platt scaling was applied to overall_score`

**In `src/lib/engine/aggregator.ts`:**
- Add import: `import { getPlattParameters, applyPlattScaling } from "./calibration";`
- After the `overall_score` computation (after line ~291, the `Math.min(100, Math.max(0, Math.round(...)))` block), add:
  ```typescript
  // -------------------------------------------------
  // Platt Calibration (CAL-01: conditional application)
  // -------------------------------------------------
  let plattParams: import("./calibration").PlattParameters | null = null;
  try {
    plattParams = await getPlattParameters();
  } catch {
    // Calibration lookup failed — proceed uncalibrated
    plattParams = null;
  }
  const calibrated_overall = applyPlattScaling(overall_score, plattParams);
  const is_calibrated = plattParams !== null;
  ```
- In the return object, replace `overall_score,` with `overall_score: calibrated_overall,` and add `is_calibrated,` after the confidence_label field.
- Do NOT import the PlattParameters type at the top level — use the inline `import("./calibration").PlattParameters` type in the local variable declaration to avoid circular dependency risk. Or alternatively, just type the variable as `Awaited<ReturnType<typeof getPlattParameters>>` or simply let TypeScript infer it. The cleanest approach: import `PlattParameters` from calibration.ts at the top level alongside the function imports since there's no circular dependency (aggregator imports from calibration, not the other way around). Use: `import { getPlattParameters, applyPlattScaling, type PlattParameters } from "./calibration";` and type the variable as `let plattParams: PlattParameters | null = null;`.
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. Grep for `getPlattParameters` in aggregator.ts to confirm import and usage. Grep for `is_calibrated` in types.ts to confirm field added.</verify>
  <done>aggregateScores() calls getPlattParameters(), applies applyPlattScaling() to overall_score, returns is_calibrated boolean. PredictionResult interface includes is_calibrated: boolean.</done>
</task>

<task type="auto">
  <name>Task 2: Propagate is_calibrated through DB types and analyze route insert</name>
  <files>src/types/database.types.ts, src/app/api/analyze/route.ts</files>
  <action>
**In `src/types/database.types.ts`:**
- In the `analysis_results` table definition, add `is_calibrated` column to all three sections (Row, Insert, Update):
  - In `Row` (after `has_video: boolean | null`): add `is_calibrated: boolean | null`
  - In `Insert` (after `has_video?: boolean | null`): add `is_calibrated?: boolean | null`
  - In `Update` (after `has_video?: boolean | null`): add `is_calibrated?: boolean | null`
- This follows the established pattern from Phase 1 where database.types.ts was manually updated to reflect schema changes (the actual Supabase migration will be applied separately via the dashboard or migration file).

**In `src/app/api/analyze/route.ts`:**
- In the `service.from("analysis_results").insert({...})` call (around line 190), add `is_calibrated: finalResult.is_calibrated,` after the `rule_contributions` line. This persists the calibration status alongside every analysis result.

**NOTE:** The actual Supabase table schema change (`ALTER TABLE analysis_results ADD COLUMN is_calibrated BOOLEAN DEFAULT FALSE`) must be applied via the Supabase dashboard or a migration. The TypeScript types are updated here to match. The DB column should use `DEFAULT FALSE` so existing rows are backfilled correctly.
  </action>
  <verify>Run `pnpm build` — full build succeeds with no errors. Grep for `is_calibrated` in database.types.ts (should appear 3 times: Row, Insert, Update). Grep for `is_calibrated` in analyze/route.ts (should appear once in the insert object).</verify>
  <done>database.types.ts includes is_calibrated in analysis_results Row/Insert/Update. analyze/route.ts persists is_calibrated in every DB insert. Build passes clean.</done>
</task>

</tasks>

<verification>
1. `pnpm build` exits 0 with no TypeScript errors
2. `grep -n "getPlattParameters\|applyPlattScaling" src/lib/engine/aggregator.ts` shows both imported and used
3. `grep -n "is_calibrated" src/lib/engine/types.ts src/types/database.types.ts src/app/api/analyze/route.ts` shows field in all 3 files
4. `grep -c "is_calibrated" src/types/database.types.ts` returns 3 (Row + Insert + Update)
</verification>

<success_criteria>
- aggregateScores() imports and calls getPlattParameters() with error-safe try/catch
- applyPlattScaling(overall_score, plattParams) is applied before returning
- is_calibrated: boolean exists in PredictionResult interface
- is_calibrated appears in database.types.ts analysis_results (Row, Insert, Update)
- is_calibrated is included in the DB insert in analyze/route.ts
- pnpm build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/03-calibration-wiring/03-01-SUMMARY.md`
</output>
