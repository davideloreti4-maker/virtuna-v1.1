# Phase 05.1: Wire TanStack Query Hooks into Page Components and Fix Integration Gaps - Research

**Researched:** 2026-02-13
**Domain:** TanStack Query v5 integration, React component wiring, mock-to-API migration
**Confidence:** HIGH

## Summary

This phase addresses a clear gap discovered during the post-Phase 5-7 audit: TanStack Query hooks were created (in `src/hooks/queries/`) but never wired into the page components that still consume mock data or Zustand test-store for server-state operations. The hooks, API routes, query keys, database types, and pagination utilities all exist and are well-structured. The work is purely a wiring/integration task -- no new infrastructure is needed.

Three distinct integration gaps exist:

1. **Dashboard analysis flow** -- `dashboard-client.tsx` uses `useTestStore` (Zustand) for the full analysis lifecycle including SSE streaming. The `useAnalyze()` mutation hook in `src/hooks/queries/use-analyze.ts` already implements identical SSE logic. The test-store duplicates this logic and manages results in local Zustand state instead of leveraging TanStack Query's cache.

2. **Trending page** -- `trending-client.tsx` and `video-grid.tsx` import from `src/lib/trending-mock-data.ts` and use `useInfiniteVideos` (a custom hook that slices mock arrays). The `useTrendingVideos()` and `useTrendingStats()` hooks in `src/hooks/queries/use-trending.ts` already call `/api/trending` which queries Supabase `scraped_videos`. However, there is a **type shape mismatch** between `TrendingVideo` (mock type) and `Tables<"scraped_videos">` (database type) that must be handled with a mapper.

3. **Brand deals page** -- `deals-tab.tsx`, `earnings-tab.tsx`, and `affiliates-tab.tsx` all directly import from `src/lib/mock-brand-deals.ts`. The `useDeals()`, `useDealEnrollments()`, and `useApplyToDeal()` hooks exist in `src/hooks/queries/use-deals.ts`. The `deal-apply-modal.tsx` currently simulates the API call with `setTimeout`. There is a **type shape mismatch** between `BrandDeal` (mock type) and `Tables<"deals">` (database type).

**Primary recommendation:** Wire existing TanStack Query hooks into page components by replacing mock data imports and local state management. Create type mapper/adapter functions to bridge the gap between database row shapes (snake_case, flat) and UI component types (camelCase, nested). Keep Zustand stores for client-only state per QUERY-09.

## Standard Stack

### Core

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `@tanstack/react-query` | `^5.90.21` | Server state management, caching, mutations | Already installed and configured in the project |
| `zustand` | `^5.0.10` | Client-only state (bookmarks, sidebar, society, settings) | Already installed, unchanged per QUERY-09 |

### Supporting

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `react-intersection-observer` | `^10.0.2` | Infinite scroll sentinel | Already used in `video-grid.tsx` |
| `zod` | `^4.3.6` | Input validation | Already used in API routes |

### No New Dependencies

No new packages need to be installed. Everything required is already in `package.json` and configured.

**Existing infrastructure (confirmed present):**
- `src/app/(app)/providers.tsx` -- `QueryClientProvider` wrapping the app shell
- `src/hooks/queries/index.ts` -- barrel export for all query hooks
- `src/lib/queries/query-keys.ts` -- namespaced query key factory
- `src/lib/pagination.ts` -- cursor-based pagination utilities
- `src/types/database.types.ts` -- auto-generated Supabase types with `Tables<>` utility
- `src/lib/engine/types.ts` -- `PredictionResult` type used by analyze API

## Architecture Patterns

### Recommended Approach: Adapter/Mapper Layer

The core pattern for this phase is creating mapper functions that transform database row types into the UI component types that already exist.

```
Database (snake_case)     Mapper Function        UI Component (camelCase)
Tables<"scraped_videos">  --> mapScrapedToVideo    --> TrendingVideo
Tables<"deals">           --> mapDealRowToUI       --> BrandDeal (UI type)
PredictionResult          --> mapPredictionToResult --> TestResult
```

### Pattern 1: Replace Mock Import with TanStack Query Hook

**What:** Swap `import { MOCK_DATA } from "@/lib/mock-file"` with the corresponding query hook.
**When to use:** Every component that currently imports from mock data files.

**Before (mock data):**
```typescript
import { MOCK_DEALS } from "@/lib/mock-brand-deals";

function DealsTab() {
  const filteredDeals = useMemo(() => {
    return MOCK_DEALS.filter((deal) => { /* ... */ });
  }, [/* ... */]);
}
```

**After (TanStack Query):**
```typescript
import { useDeals } from "@/hooks/queries";

function DealsTab() {
  const { data, isLoading, error, fetchNextPage, hasNextPage } = useDeals(filters);

  // Flatten pages for display
  const deals = useMemo(() =>
    data?.pages.flatMap(page => page.data.map(mapDealRowToUI)) ?? [],
    [data]
  );
}
```

### Pattern 2: Replace Zustand Server-State with useMutation

**What:** Move SSE streaming and server-state logic from Zustand store into the existing `useAnalyze()` mutation hook.
**When to use:** The dashboard analysis flow specifically.

**Key insight:** The `useTestStore.submitTest()` method (lines 145-301 of `test-store.ts`) duplicates almost exactly the same SSE streaming logic that `useAnalyze()` in `src/hooks/queries/use-analyze.ts` already implements. The store should be thinned to only manage UI flow state (status, test type selection), while the actual API call uses the mutation hook.

**Before (Zustand handles everything):**
```typescript
const { submitTest, currentResult } = useTestStore();
submitTest(content, societyId); // Zustand makes API call, stores result
```

**After (mutation hook + thin Zustand):**
```typescript
const { mutate: analyze, data: result, phase, phaseMessage } = useAnalyze();
const { setStatus } = useTestStore(); // Only UI flow state

analyze({ content_text, content_type, society_id }, {
  onSuccess: (prediction) => {
    setStatus('viewing-results');
  }
});
```

### Pattern 3: Infinite Query with Intersection Observer

**What:** Replace the custom `useInfiniteVideos` hook (which slices mock arrays) with TanStack Query's `useInfiniteQuery` (which fetches from `/api/trending`).
**When to use:** The trending page video grid.

The existing `useTrendingVideos()` hook already implements this correctly via `useInfiniteQuery`. The `video-grid.tsx` component already has `react-intersection-observer` wired up. The change is connecting them.

**Source:** TanStack Query v5 docs -- infinite scroll with `useInView` sentinel pattern (verified via Context7).

### Anti-Patterns to Avoid

- **Don't create a new "server-state Zustand store":** The analysis result should come from TanStack Query's cache (`mutation.data`), not a new Zustand slice. The whole point is to stop duplicating server state in client stores.
- **Don't remove Zustand entirely:** Per QUERY-09, Zustand remains for bookmarks, sidebar, society, settings. Only remove the server-state management (analysis submission, result storage, test history).
- **Don't change the API routes:** All routes (`/api/analyze`, `/api/trending`, `/api/deals`, `/api/outcomes`) are already implemented and working. This phase only touches the client-side.
- **Don't change the mock data files:** Keep them as-is for reference/fallback. Just stop importing them in production components.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Cursor pagination in UI | Custom displayCount/slice logic | `useInfiniteQuery` + `fetchNextPage` | TanStack handles page merging, caching, refetching |
| Server state caching | Zustand with manual refetch | `useQuery` / `useMutation` cache | Built-in stale-while-revalidate, deduplication, background refresh |
| Loading states | `useState(true)` + `setTimeout` | `isLoading` / `isPending` from query hooks | Eliminates fake loading delays, shows real loading |
| Error handling | try/catch + local state | `error` / `isError` from query hooks | Consistent, automatic retry, error boundaries |
| Cache invalidation | Manual state updates | `queryClient.invalidateQueries()` | Already implemented in mutation `onSuccess` callbacks |

**Key insight:** Multiple components currently use `useState(true)` + `setTimeout(setIsLoading(false), 800)` to fake loading states (e.g., `deals-tab.tsx:58-61`, `earnings-tab.tsx:85-88`, `affiliates-tab.tsx:43-45`). These should be replaced with the actual `isLoading` state from query hooks.

## Common Pitfalls

### Pitfall 1: Type Shape Mismatch Between Database and UI Types

**What goes wrong:** `Tables<"scraped_videos">` has `{ author: string | null, description: string | null, views: number | null }` while `TrendingVideo` expects `{ creator: { handle, displayName, avatarUrl }, title: string, views: number, velocity: number }`. Directly assigning database rows to component props causes TypeScript errors and potentially null reference crashes.

**Why it happens:** Database schemas use flat snake_case columns; UI types use nested camelCase objects. The mock data was hand-crafted to match UI types perfectly, but real database rows have different shapes.

**How to avoid:** Create explicit mapper functions in `src/lib/mappers/` (or co-located with the hooks). Each mapper handles null coalescing, field renaming, and nested object construction. Type the mapper return as the exact UI type.

**Warning signs:** TypeScript errors on prop assignment after swapping data source; `null` fields causing runtime crashes in components.

**Specific mismatches identified:**

| Database Column | UI Type Field | Mapping Required |
|----------------|---------------|-----------------|
| `scraped_videos.description` | `TrendingVideo.title` | Use `description ?? "Untitled"` |
| `scraped_videos.author` | `TrendingVideo.creator.handle` | Wrap in `{ handle: author, displayName: author, avatarUrl: placeholder }` |
| `scraped_videos.category` | `TrendingVideo.category` | Type assertion with fallback (DB has `string | null`, UI expects `TrendingCategory`) |
| `scraped_videos.created_at` | `TrendingVideo.date` | Direct map (`string | null` -> default to `new Date().toISOString()`) |
| `deals.brand_name` | `BrandDeal.brandName` | camelCase rename |
| `deals.brand_logo_url` | `BrandDeal.brandLogo` | camelCase rename + null handling |
| `deals.compensation_rev_share_percent` | `BrandDeal.commission` | Rename + `?? 0` |
| `deals.compensation_fixed_cents` | `BrandDeal.fixedFee` | Convert cents to dollars: `/ 100` |

### Pitfall 2: Missing `velocity` Field in Database Schema

**What goes wrong:** The `TrendingVideo` UI type requires a `velocity` field (views multiplier), but `scraped_videos` table has no velocity column. The mock data has hand-coded velocity values.

**Why it happens:** Velocity was a mock-only field. The real data might derive velocity from `trending_sounds.velocity_score` or need computation.

**How to avoid:** The mapper should derive velocity from available data (e.g., `trending_sounds.velocity_score` if joined, or compute from view growth rate) or default to `1.0`. Check if the API route can join with `trending_sounds` to get velocity data.

**Warning signs:** `velocity` always showing 1.0x or undefined in the UI after migration.

### Pitfall 3: Race Condition When Thinning test-store

**What goes wrong:** If the `useAnalyze()` mutation and the `useTestStore` UI flow state get out of sync, the UI can show the wrong panel (e.g., showing "simulating" when the mutation already completed, or showing "idle" during active analysis).

**Why it happens:** Two sources of truth: mutation phase state and Zustand status state. They must stay synchronized.

**How to avoid:** Drive the UI flow from a single derived state. Either:
- **Option A:** Keep `useTestStore.currentStatus` but update it reactively based on `mutation.status` and `phase` state from `useAnalyze()`. The dashboard component orchestrates both.
- **Option B:** Derive `currentStatus` entirely from mutation state (isPending -> simulating, isSuccess -> viewing-results, isIdle -> idle). Remove `currentStatus` from Zustand.

**Recommendation:** Option A is safer -- minimal changes to the UI components that read `currentStatus`. The dashboard-client becomes the coordinator between the mutation hook and the store.

### Pitfall 4: useAnalysisHistory Hook Calls Wrong Endpoint

**What goes wrong:** `useAnalysisHistory()` in `use-analyze.ts` fetches from `/api/outcomes` (line 117), but analysis history should come from the `analysis_results` table, not the `outcomes` table. Outcomes are user-submitted performance reports; analysis history is the list of past analyses.

**Why it happens:** Copy-paste error during hook creation. The outcomes route returns outcomes, not analysis results.

**How to avoid:** Either:
- Create a dedicated `/api/analysis/history` route that queries `analysis_results` table
- Or fix the endpoint in `useAnalysisHistory()` to call the correct route

**This is a bug that must be fixed as part of the wiring work.**

### Pitfall 5: Earnings/Affiliates Data Has No API Routes

**What goes wrong:** The `earnings-tab.tsx` and `affiliates-tab.tsx` components use mock data, but there are no `/api/earnings` or `/api/affiliates` API routes and no corresponding TanStack Query hooks.

**Why it happens:** The backend-foundation milestone focused on deals and enrollments. Earnings aggregation and affiliate link management were not in scope for API routes.

**How to avoid:** For this phase, these tabs should either:
- Continue using mock data with a `// TODO: Replace with API when available` comment
- Or wire into the existing deals/enrollments data if sufficient

**This is an expected gap, not a bug.** The deals tab and apply flow are the priority for this phase.

### Pitfall 6: Fake Loading Delays Masking Real UX

**What goes wrong:** Components use `setTimeout(() => setIsLoading(false), 800)` for perceived loading. When switching to real queries, the `isLoading` state from TanStack Query may resolve faster or slower than 800ms, causing jarring UX transitions.

**Why it happens:** Mock data is synchronous; the fake delay was added for UX polish. Real API calls have variable latency.

**How to avoid:** Remove the fake delay. Use TanStack Query's `isLoading` / `isFetching` directly. If a minimum loading time is desired for UX consistency, implement it as a small utility (e.g., `useMinimumLoading(query.isLoading, 300)`), not as an arbitrary timeout.

## Code Examples

### Mapper: Database ScrapedVideo to UI TrendingVideo

```typescript
// src/lib/mappers/trending.ts
import type { Tables } from "@/types/database.types";
import type { TrendingVideo, TrendingCategory } from "@/types/trending";

const VALID_CATEGORIES: TrendingCategory[] = ["breaking-out", "trending-now", "rising-again"];

export function mapScrapedVideoToTrendingVideo(
  row: Tables<"scraped_videos">
): TrendingVideo {
  const category = VALID_CATEGORIES.includes(row.category as TrendingCategory)
    ? (row.category as TrendingCategory)
    : "trending-now"; // fallback

  return {
    id: row.id,
    title: row.description ?? "Untitled",
    thumbnailUrl: `https://picsum.photos/seed/${row.platform_video_id}/400/500`, // placeholder until real thumbnails
    creator: {
      handle: row.author ? `@${row.author.replace(/^@/, "")}` : "@unknown",
      displayName: row.author ?? "Unknown Creator",
      avatarUrl: `https://picsum.photos/seed/${row.author ?? "default"}/100/100`,
    },
    views: row.views ?? 0,
    likes: row.likes ?? 0,
    shares: row.shares ?? 0,
    date: row.created_at ?? new Date().toISOString(),
    category,
    hashtags: row.hashtags ?? [],
    tiktokUrl: row.video_url ?? "",
    velocity: 1.0, // TODO: derive from trending_sounds join or metadata
  };
}
```

### Wiring useDeals into DealsTab

```typescript
// Updated deals-tab.tsx approach
import { useDeals, useApplyToDeal } from "@/hooks/queries";

export function DealsTab() {
  const [activeCategory, setActiveCategory] = useState<BrandDealCategory | "all">("all");
  const [searchQuery, setSearchQuery] = useState("");

  // Replace MOCK_DEALS with real query
  const { data, isLoading, fetchNextPage, hasNextPage } = useDeals({
    status: "active",
  });

  const applyMutation = useApplyToDeal();

  // Flatten pages and map to UI types
  const allDeals = useMemo(() =>
    data?.pages.flatMap(page => page.data.map(mapDealRowToUI)) ?? [],
    [data]
  );

  // Client-side filter (category + search)
  const filteredDeals = useMemo(() =>
    allDeals.filter(deal => {
      const matchesCategory = activeCategory === "all" || deal.category === activeCategory;
      const matchesSearch = deal.brandName.toLowerCase().includes(searchQuery.toLowerCase());
      return matchesCategory && matchesSearch;
    }),
    [allDeals, activeCategory, searchQuery]
  );

  // Replace setTimeout-based loading with real query state
  if (isLoading) return <DealsTabSkeleton />;
  // ... rest of component
}
```

### Wiring useAnalyze into DashboardClient

```typescript
// Updated dashboard-client.tsx approach
import { useAnalyze } from "@/hooks/queries";
import { useTestStore } from "@/stores/test-store"; // thin: only UI flow state

export function DashboardClient() {
  const { currentStatus, currentTestType, setStatus, setTestType, reset } = useTestStore();
  const analyze = useAnalyze();

  // Derive simulation display state from mutation
  const isSimulating = analyze.isPending;
  const result = analyze.data;

  // Map PredictionResult -> TestResult for existing UI components
  const mappedResult = useMemo(() =>
    result && currentTestType
      ? mapPredictionToTestResult(result, /* content */, currentTestType, selectedSocietyId)
      : null,
    [result, currentTestType]
  );

  const handleContentSubmit = (content: string) => {
    if (!selectedSocietyId || !currentTestType) return;
    setStatus("simulating");

    analyze.mutate(
      {
        content_text: content,
        content_type: contentTypeMap[currentTestType] ?? "post",
        society_id: selectedSocietyId,
      },
      {
        onSuccess: () => setStatus("viewing-results"),
        onError: () => setStatus("filling-form"),
      }
    );
  };
  // ... rest of component, LoadingPhases reads phase/phaseMessage from analyze hook
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Mock data imports + useState | TanStack Query hooks | Phase 5 created hooks (not wired) | Hooks exist, need wiring |
| Zustand for all state | Zustand for client-only, TQ for server state | Architecture decision pre-Phase 5 | test-store still duplicates server state |
| Custom useInfiniteVideos (mock slicing) | `useTrendingVideos()` with cursor pagination | Phase 5 created hook | video-grid still uses custom hook |
| `setTimeout` fake loading | Real `isLoading` from query hooks | This phase | Removes artificial delays |

## Open Questions

1. **Should test-store.ts be refactored or deleted?**
   - What we know: It duplicates SSE logic from `useAnalyze()`, manages test history locally, and handles UI flow state
   - What's unclear: How much of test-store's UI flow management (status, phase, test type) should remain vs. be derived from mutation state
   - Recommendation: Keep test-store for `currentStatus`, `currentTestType`, and `reset()` only. Remove `submitTest()`, `tests[]`, `currentResult`, `simulationPhase`, `phaseProgress`, `phaseMessage` -- these come from mutation hook state. The `LoadingPhases` component should read from the mutation hook's `phase` and `phaseMessage` instead of from Zustand.

2. **What about the `useAnalysisHistory()` bug (wrong endpoint)?**
   - What we know: It calls `/api/outcomes` but should fetch from `analysis_results`. The `test-history-list.tsx` currently reads from `useTestStore.tests` (in-memory array, not persisted).
   - What's unclear: Whether to create a new `/api/analysis/history` route or reuse the existing outcomes endpoint with modifications
   - Recommendation: Create `/api/analysis/history` route querying `analysis_results` table. Update `useAnalysisHistory()` to call it. Wire into `test-history-list.tsx`.

3. **Earnings and affiliates data -- mock or real?**
   - What we know: No API routes exist for earnings aggregation or affiliate link management. The `earnings-tab.tsx` and `affiliates-tab.tsx` have no corresponding hooks.
   - What's unclear: Whether these features are in scope for the backend-foundation milestone
   - Recommendation: Keep mock data for earnings and affiliates tabs. Focus this phase on: (1) trending page, (2) deals tab + apply flow, (3) dashboard analysis flow. These are the three areas with existing hooks that need wiring.

4. **Video thumbnails and creator avatars from real data?**
   - What we know: `scraped_videos` has no `thumbnail_url` or `avatar_url` columns. Mock data uses picsum.photos placeholders.
   - What's unclear: Whether the scraper captures thumbnail URLs in the `metadata` JSON column
   - Recommendation: Use placeholder images in mapper. Check `metadata` column for thumbnail data. This is a data concern, not a wiring concern.

## Wiring Gap Inventory

Complete list of files that need changes, ordered by impact:

### Priority 1: Dashboard Analysis Flow (QUERY-07, UX-01, UX-04)
| File | Current State | Change Needed |
|------|--------------|---------------|
| `src/app/(app)/dashboard/dashboard-client.tsx` | Uses `useTestStore.submitTest()` for analysis | Wire `useAnalyze()` mutation, keep thin store for UI flow |
| `src/stores/test-store.ts` | Contains SSE logic, manages results | Remove `submitTest()` server logic, keep UI flow state |
| `src/components/app/simulation/loading-phases.tsx` | Reads `simulationPhase` from test-store | Read `phase`/`phaseMessage` from analyze mutation (passed as props or context) |
| `src/components/app/test-history-list.tsx` | Reads `tests[]` from test-store (in-memory) | Wire `useAnalysisHistory()` (after fixing endpoint) |

### Priority 2: Trending Page (QUERY-03)
| File | Current State | Change Needed |
|------|--------------|---------------|
| `src/app/(app)/trending/trending-client.tsx` | Imports `getTrendingStats`, `getAllVideos` from mock | Wire `useTrendingStats()`, derive video list from query |
| `src/components/trending/video-grid.tsx` | Uses `useInfiniteVideos` (mock slicing) | Wire `useTrendingVideos(category)` with `fetchNextPage` |
| `src/hooks/use-infinite-videos.ts` | Custom hook slicing mock arrays | Can be deleted after migration |

### Priority 3: Brand Deals Page (QUERY-05)
| File | Current State | Change Needed |
|------|--------------|---------------|
| `src/components/app/brand-deals/deals-tab.tsx` | Imports `MOCK_DEALS` | Wire `useDeals(filters)` |
| `src/components/app/brand-deals/deal-apply-modal.tsx` | `setTimeout` fake API call | Wire `useApplyToDeal()` mutation |
| `src/components/app/brand-deals/brand-deals-page.tsx` | Local `appliedDeals` state | Use `useDealEnrollments()` for applied state |

### Deferred (No API Routes Available)
| File | Current State | Change Needed |
|------|--------------|---------------|
| `src/components/app/brand-deals/earnings-tab.tsx` | `MOCK_EARNINGS_SUMMARY` | Keep mock -- no API route |
| `src/components/app/brand-deals/affiliates-tab.tsx` | `MOCK_AFFILIATE_LINKS`, `MOCK_PRODUCTS` | Keep mock -- no API route |

### Supporting (New Files)
| File | Purpose |
|------|---------|
| `src/lib/mappers/trending.ts` | `mapScrapedVideoToTrendingVideo()` |
| `src/lib/mappers/deals.ts` | `mapDealRowToUI()` |
| `src/app/api/analysis/history/route.ts` | New route for analysis history (fixes QUERY-06 bug) |

## Sources

### Primary (HIGH confidence)
- **Codebase analysis** -- All file contents read directly from the repository
- **Context7 /tanstack/query** -- `useInfiniteQuery` with intersection observer pattern, `useMutation` with cache invalidation, optimistic updates
- **TanStack Query v5 docs** (via Context7) -- Infinite queries, mutation callbacks, query invalidation

### Secondary (MEDIUM confidence)
- **Type inference** from `src/types/database.types.ts` -- Schema shapes for `scraped_videos`, `deals`, `deal_enrollments`, `analysis_results`, `outcomes`

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- all libraries already installed and configured, no new dependencies
- Architecture: HIGH -- hooks already exist, patterns are standard TanStack Query v5, code examples derived from actual codebase
- Pitfalls: HIGH -- type mismatches identified by comparing actual database types vs UI types side-by-side
- Wiring inventory: HIGH -- every affected file identified with grep, every mock import traced

**Research date:** 2026-02-13
**Valid until:** 2026-03-13 (stable -- no library changes expected)
