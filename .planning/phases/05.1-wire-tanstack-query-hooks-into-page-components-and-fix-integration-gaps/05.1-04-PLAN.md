---
phase: 05.1-wire-tanstack-query-hooks-into-page-components-and-fix-integration-gaps
plan: 04
type: execute
wave: 2
depends_on: ["05.1-01"]
files_modified:
  - src/app/(app)/dashboard/dashboard-client.tsx
  - src/stores/test-store.ts
  - src/components/app/simulation/loading-phases.tsx
  - src/components/app/test-history-list.tsx
autonomous: true

must_haves:
  truths:
    - "Dashboard submits analysis via useAnalyze() mutation hook, not via useTestStore.submitTest()"
    - "LoadingPhases reads simulation phase from useAnalyze() hook state (via props), not from test-store"
    - "Test history list displays data from useAnalysisHistory() hook, not from test-store.tests[]"
    - "Zustand test-store retains only UI flow state (currentStatus, currentTestType, reset) -- no server-state (submitTest SSE logic removed)"
    - "Simulation theater shows real SSE phase events from the analyze API"
  artifacts:
    - path: "src/app/(app)/dashboard/dashboard-client.tsx"
      provides: "Dashboard wired to useAnalyze mutation"
      contains: "useAnalyze"
    - path: "src/stores/test-store.ts"
      provides: "Thinned store with only UI flow state"
    - path: "src/components/app/simulation/loading-phases.tsx"
      provides: "LoadingPhases accepting phase via props"
    - path: "src/components/app/test-history-list.tsx"
      provides: "History list wired to useAnalysisHistory"
      contains: "useAnalysisHistory"
  key_links:
    - from: "src/app/(app)/dashboard/dashboard-client.tsx"
      to: "src/hooks/queries/use-analyze.ts"
      via: "useAnalyze mutation hook"
      pattern: "import.*useAnalyze.*from.*hooks/queries"
    - from: "src/app/(app)/dashboard/dashboard-client.tsx"
      to: "src/stores/test-store.ts"
      via: "thin UI flow state only"
      pattern: "useTestStore"
    - from: "src/components/app/simulation/loading-phases.tsx"
      to: "props (simulationPhase, onCancel)"
      via: "props not store"
      pattern: "function LoadingPhases.*simulationPhase"
    - from: "src/components/app/test-history-list.tsx"
      to: "src/hooks/queries/use-analyze.ts"
      via: "useAnalysisHistory query hook"
      pattern: "import.*useAnalysisHistory.*from.*hooks/queries"
---

<objective>
Wire the dashboard analysis flow to the useAnalyze() mutation hook, thin the test-store to UI-only state, and connect the test history list to useAnalysisHistory().

Purpose: The dashboard currently uses `useTestStore.submitTest()` which duplicates the SSE streaming logic that already exists in `useAnalyze()`. The LoadingPhases component reads simulation phase from the Zustand store. The test history list reads from an in-memory `tests[]` array. This plan eliminates server-state duplication by using TanStack Query for all API interactions and thinning the Zustand store to client-only UI flow management.

Output: Dashboard analysis flow powered by useAnalyze() mutation with real SSE events, LoadingPhases driven by props, history from API.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@src/hooks/queries/use-analyze.ts
@src/stores/test-store.ts
@src/app/(app)/dashboard/dashboard-client.tsx
@src/components/app/simulation/loading-phases.tsx
@src/components/app/test-history-list.tsx
@src/lib/engine/types.ts
@src/types/test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Thin test-store and wire DashboardClient to useAnalyze mutation</name>
  <files>
    src/stores/test-store.ts
    src/app/(app)/dashboard/dashboard-client.tsx
  </files>
  <action>
**Thin `test-store.ts`:**

Keep ONLY UI flow state and actions:
- `currentTestType: TestType | null`
- `currentStatus: TestStatus`
- `isViewingHistory: boolean`
- `_isHydrated: boolean`
- `setTestType(type)`
- `setStatus(status)`
- `reset()`
- `_hydrate()`

Remove (server state now in TanStack Query):
- `tests: TestResult[]` -- history comes from useAnalysisHistory()
- `currentResult: TestResult | null` -- result comes from useAnalyze().data
- `simulationPhase: SimulationPhase | null` -- phase comes from useAnalyze().phase
- `phaseProgress: number` -- derived from phase
- `phaseMessage: string` -- comes from useAnalyze().phaseMessage
- `submitTest()` -- replaced by useAnalyze().mutate()
- `cancelSimulation()` -- handled in dashboard-client via mutation reset
- `viewResult()` -- will be reimplemented with query data
- `deleteTest()` -- will need API route (out of scope, leave TODO)

Keep the `SimulationPhase` type export (LoadingPhases uses it).
Keep the `mapPredictionToTestResult` function export (dashboard needs it for backward-compatible display).
Keep `PHASE_MESSAGES` export (LoadingPhases or dashboard may need it).
Move `mapPredictionToTestResult`, `getImpactLabel`, `deriveAttention` to be standalone exports (not inside the store). They're pure functions.

Updated store shape:
```typescript
interface TestState {
  currentTestType: TestType | null;
  currentStatus: TestStatus;
  isViewingHistory: boolean;
  _isHydrated: boolean;

  setTestType: (type: TestType | null) => void;
  setStatus: (status: TestStatus) => void;
  reset: () => void;
  _hydrate: () => void;
}
```

**Wire `dashboard-client.tsx`:**

Imports to add:
- `import { useAnalyze } from "@/hooks/queries"`
- `import { mapPredictionToTestResult } from "@/stores/test-store"` (or wherever it lands)

Replace store destructuring:
```typescript
const { currentStatus, currentTestType, setStatus, setTestType, reset } = useTestStore();
const { selectedSocietyId } = useSocietyStore();
const analyzeMutation = useAnalyze();
```

Derive result from mutation:
```typescript
const currentResult = useMemo(() => {
  if (!analyzeMutation.data || !currentTestType) return null;
  return mapPredictionToTestResult(
    analyzeMutation.data,
    "", // content not stored in mutation result -- pass empty or track locally
    currentTestType,
    selectedSocietyId ?? ""
  );
}, [analyzeMutation.data, currentTestType, selectedSocietyId]);
```

Note: The `content` parameter for `mapPredictionToTestResult` needs the original submitted content. Add a local `useRef` or `useState` to track the submitted content string:
```typescript
const [submittedContent, setSubmittedContent] = useState("");
```
Use this in the mapper: `mapPredictionToTestResult(analyzeMutation.data, submittedContent, currentTestType, selectedSocietyId ?? "")`

Replace `handleContentSubmit`:
```typescript
const handleContentSubmit = (content: string) => {
  if (!selectedSocietyId || !currentTestType) return;

  setSubmittedContent(content);
  setStatus("simulating");

  const contentTypeMap: Record<string, string> = {
    "tiktok-script": "video",
    "instagram-post": "reel",
    "x-post": "post",
    "linkedin-post": "post",
    "email-subject-line": "post",
    "email": "post",
    "article": "post",
    "website-content": "post",
    "advertisement": "post",
    "product-proposition": "post",
    "survey": "post",
  };

  analyzeMutation.mutate(
    {
      content_text: content,
      content_type: contentTypeMap[currentTestType] ?? "post",
      society_id: selectedSocietyId,
    },
    {
      onSuccess: () => setStatus("viewing-results"),
      onError: () => setStatus("filling-form"),
    }
  );
};
```

Replace `handleSurveySubmit` similarly (construct content string, call same flow).

Replace `handleRunAnother`:
```typescript
const handleRunAnother = () => {
  reset();
  analyzeMutation.reset();
  setSubmittedContent("");
};
```

Update `<LoadingPhases>` rendering to pass phase as props (see Task 2).

In the JSX where `<LoadingPhases />` is rendered:
```tsx
<LoadingPhases
  simulationPhase={analyzeMutation.phase as SimulationPhase | null}
  phaseMessage={analyzeMutation.phaseMessage}
  onCancel={() => {
    setStatus("filling-form");
    // Note: can't truly cancel the SSE stream mid-flight,
    // but we can hide the theater and reset UI
    analyzeMutation.reset();
  }}
/>
```

Where `<ResultsPanel>` is rendered, use the derived `currentResult`:
```tsx
currentStatus === "viewing-results" && currentResult ? (
  <ResultsPanel result={currentResult} onRunAnother={handleRunAnother} />
) : null
```
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `grep -r "submitTest" src/app/(app)/dashboard/dashboard-client.tsx` returns nothing
3. `grep -r "useAnalyze" src/app/(app)/dashboard/dashboard-client.tsx` returns a match
4. `grep -r "submitTest" src/stores/test-store.ts` returns nothing (method removed)
5. test-store.ts no longer contains SSE streaming logic (`fetch.*api/analyze` pattern absent)
  </verify>
  <done>
Dashboard submits analysis via useAnalyze() mutation. Test-store is thinned to UI flow state only (currentStatus, currentTestType, reset). SSE streaming logic lives only in the useAnalyze() hook, not duplicated in Zustand.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire LoadingPhases to accept phase via props and wire test-history-list to useAnalysisHistory</name>
  <files>
    src/components/app/simulation/loading-phases.tsx
    src/components/app/test-history-list.tsx
  </files>
  <action>
**Update LoadingPhases (`loading-phases.tsx`):**

Change from reading Zustand store to accepting props:

Update the interface:
```typescript
interface LoadingPhasesProps {
  simulationPhase: SimulationPhase | null;
  phaseMessage?: string;
  onCancel: () => void;
}
```

Update the component:
```typescript
export function LoadingPhases({ simulationPhase, phaseMessage, onCancel }: LoadingPhasesProps) {
  const currentIdx = simulationPhase
    ? PHASE_ORDER.indexOf(simulationPhase)
    : -1;

  const isVisible = (phase: SimulationPhase): boolean =>
    currentIdx >= PHASE_ORDER.indexOf(phase);

  return (
    <div className="space-y-3">
      <AnimatePresence mode="popLayout">
        {SECTIONS.map(
          (section) =>
            isVisible(section.phase) && (
              <motion.div
                key={section.phase}
                initial={{ opacity: 0, y: 8 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0 }}
                transition={{
                  duration: 0.35,
                  ease: [0.215, 0.61, 0.355, 1],
                }}
              >
                {section.skeleton}
              </motion.div>
            )
        )}
      </AnimatePresence>

      <Button
        variant="secondary"
        onClick={onCancel}
        className="mt-4 w-full"
      >
        Cancel
      </Button>
    </div>
  );
}
```

Remove imports:
- Remove: `import { useTestStore, type SimulationPhase } from '@/stores/test-store'`
- Keep `SimulationPhase` type but import it differently. Since `SimulationPhase` is defined in test-store, either:
  - Export it from test-store (it already is) and import just the type: `import type { SimulationPhase } from '@/stores/test-store'`
  - OR define it locally in this file
  Best approach: keep importing the type from test-store but remove the store hook usage.

**Update TestHistoryList (`test-history-list.tsx`):**

Replace Zustand store usage with `useAnalysisHistory()` hook.

Imports to change:
- Remove: `import { useTestStore } from '@/stores/test-store'`
- Add: `import { useAnalysisHistory } from "@/hooks/queries"`

The `useAnalysisHistory()` hook returns analysis results from `/api/analysis/history` (fixed in Plan 01). The shape is `Tables<"analysis_results">[]` from Supabase.

The existing component displays `TestResult[]` from the store. The API returns `analysis_results` rows. We need to either:
- Map API rows to the display shape expected by `TestHistoryItem`
- Or simplify the display to use the API row fields directly

Looking at `TestHistoryItem` -- it expects a `TestResult` type. The simplest approach: create a lightweight mapper from `analysis_results` row to a minimal display object that `TestHistoryItem` can render.

```typescript
export function TestHistoryList({ onSelectTest }: TestHistoryListProps) {
  const { data: historyData, isLoading } = useAnalysisHistory();

  if (isLoading) {
    return (
      <Caption className="block px-3 py-2">
        Loading history...
      </Caption>
    );
  }

  const tests = historyData ?? [];

  if (tests.length === 0) {
    return (
      <Caption className="block px-3 py-2">
        No tests yet. Create your first test to see it here.
      </Caption>
    );
  }

  return (
    <>
      <Caption className="mb-2 block px-2 uppercase tracking-wider">
        Recent Tests
      </Caption>

      <div className="flex flex-col gap-1">
        {tests.map((test: any) => (
          <TestHistoryItem
            key={test.id}
            test={{
              id: test.id,
              testType: test.content_type as any,
              content: test.content_text,
              impactScore: test.overall_score ?? 0,
              impactLabel: test.overall_score >= 70 ? "Good" : test.overall_score >= 40 ? "Average" : "Poor",
              createdAt: test.created_at ?? new Date().toISOString(),
            } as any}
            isActive={false}
            onClick={() => onSelectTest(test.id)}
            onDelete={() => {
              // TODO: Implement delete via API route
              console.warn("Delete not yet implemented via API");
            }}
          />
        ))}
      </div>
    </>
  );
}
```

Note: Using `as any` for the test shape is acceptable as a temporary bridge. The TestHistoryItem likely only renders a few fields (content preview, score, date). A full type-safe mapper can be added in a follow-up. The critical thing is removing the Zustand `tests[]` dependency.

Remove the `deleteTest` modal for now (it operated on Zustand state which no longer holds tests). Keep the delete handler as a no-op with TODO.
Remove `currentResult` usage from store (no longer tracking "active" test from Zustand).
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `grep -r "useTestStore" src/components/app/simulation/loading-phases.tsx` returns nothing (no more store usage)
3. `grep -r "useTestStore" src/components/app/test-history-list.tsx` returns nothing
4. `grep -r "useAnalysisHistory" src/components/app/test-history-list.tsx` returns a match
5. LoadingPhases accepts `simulationPhase` and `onCancel` props
  </verify>
  <done>
LoadingPhases is a pure presentational component driven by props (simulationPhase, onCancel) instead of reading from Zustand. TestHistoryList fetches analysis history from the API via useAnalysisHistory() hook instead of reading from in-memory Zustand tests array.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for all modified files
2. No `submitTest` or SSE logic remains in test-store.ts
3. `useAnalyze()` is imported and used in dashboard-client.tsx
4. LoadingPhases no longer imports useTestStore (except type)
5. TestHistoryList uses useAnalysisHistory() not useTestStore
6. Zustand stores for bookmarks, sidebar, society, settings are completely unchanged
7. The dashboard flow works: select type -> fill form -> submit (useAnalyze mutation) -> see LoadingPhases with real SSE events -> see results
</verification>

<success_criteria>
- Dashboard analysis flow uses useAnalyze() mutation for real SSE streaming
- Test-store thinned to UI flow state only (no server state duplication)
- LoadingPhases is prop-driven (simulationPhase, onCancel)
- Test history list fetches from API via useAnalysisHistory()
- No Zustand store contains server-state management
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/05.1-wire-tanstack-query-hooks-into-page-components-and-fix-integration-gaps/05.1-04-SUMMARY.md`
</output>
