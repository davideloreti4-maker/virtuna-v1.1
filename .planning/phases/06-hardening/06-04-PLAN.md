---
phase: 06-hardening
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/profile/route.ts
autonomous: true

must_haves:
  truths:
    - "PATCH /api/profile accepts tiktok_handle field and persists it to creator_profiles"
    - "Setting tiktok_handle triggers a background scrape that does NOT block the PATCH response"
    - "The PATCH response returns immediately with success — scrape runs fire-and-forget"
    - "If the scrape fails, the profile update still succeeds (scrape is best-effort)"
    - "Tests pass after changes"
  artifacts:
    - path: "src/app/api/profile/route.ts"
      provides: "tiktok_handle field in profile update + background scrape trigger"
      contains: "tiktok_handle"
  key_links:
    - from: "src/app/api/profile/route.ts"
      to: "creator_profiles table"
      via: "upsert on PATCH with tiktok_handle"
      pattern: "creator_profiles.*upsert"
---

<objective>
Wire an optional creator profile scrape trigger when a user sets their TikTok handle via the profile API. The scrape runs in the background (fire-and-forget) so the PATCH response is not delayed.

Purpose: HARD-05 — when a user links their TikTok account, we proactively scrape their creator profile so it's available for the next prediction, without blocking the profile update response.
Output: Profile route accepts tiktok_handle, upserts to creator_profiles, and kicks off a background scrape.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/app/api/profile/route.ts
@src/lib/scraping/index.ts
@src/lib/scraping/types.ts
@src/lib/engine/creator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Accept tiktok_handle in profile PATCH and trigger background scrape</name>
  <files>src/app/api/profile/route.ts</files>
  <action>
1. Add `tiktok_handle` to the Zod validation schema:
   ```ts
   const updateProfileSchema = z.object({
     display_name: z.string().min(1).max(100).optional(),
     company: z.string().max(100).optional(),
     role: z.string().max(100).optional(),
     tiktok_handle: z.string().max(100).optional(),
   });
   ```

2. Import `createServiceClient` from `@/lib/supabase/service` (needed for creator_profiles write — user client may not have permission to write creator_profiles).

3. Import `createScrapingProvider` from `@/lib/scraping`.

4. Import `createLogger` from `@/lib/logger`.

5. In the PATCH handler, after the existing `user_settings` upsert succeeds, add:
   ```ts
   // HARD-05: If tiktok_handle provided, upsert creator_profiles and trigger background scrape
   if (parsed.data.tiktok_handle) {
     const service = createServiceClient();
     const handle = parsed.data.tiktok_handle.replace(/^@/, ""); // Strip leading @

     // Upsert creator_profiles row — link user to their TikTok handle
     await service.from("creator_profiles").upsert(
       {
         user_id: user.id,
         tiktok_handle: handle,
       },
       { onConflict: "user_id" }
     );

     // Fire-and-forget background scrape — intentionally not awaited
     // Uses void to signal intentional fire-and-forget to ESLint
     const log = createLogger({ module: "profile" });
     void (async () => {
       try {
         const scraper = createScrapingProvider();
         const profileData = await scraper.scrapeProfile(handle);
         await service.from("creator_profiles").update({
           display_name: profileData.displayName,
           tiktok_followers: profileData.followerCount,
           // Update only the fields that come from scraping
         }).eq("user_id", user.id);
         log.info("Background creator scrape complete", { handle });
       } catch (err) {
         log.warn("Background creator scrape failed (non-blocking)", {
           handle,
           error: err instanceof Error ? err.message : String(err),
         });
         // Intentionally swallowed — scrape is best-effort
       }
     })();
   }
   ```

6. Also update the GET handler to include tiktok_handle in the response:
   ```ts
   const profile = {
     // ... existing fields ...
     tiktok_handle: creatorProfile?.tiktok_handle || "",
   };
   ```

7. Replace the two `console.error` calls in the profile route with `createLogger({ module: "profile" })` calls to follow OBS-05 convention. Create a module-level `const log = createLogger({ module: "profile" });` and use `log.error(...)` instead.

Note on scrape fields: Check `src/lib/scraping/types.ts` for the exact field names returned by `scrapeProfile()`. The `profileData` object should have `displayName`, `followerCount`, etc. Map only the fields that exist in the creator_profiles table schema. If the table columns don't match exactly, use only the fields that overlap. Check `database.types.ts` for the creator_profiles table shape if needed.
  </action>
  <verify>Run `pnpm build` to verify TypeScript compiles. Run `pnpm test` to verify no regressions. The background scrape cannot be tested in unit tests (it's fire-and-forget against external APIs) — this is by design per ROADMAP decision "runtime webhook test deferred to post-deployment smoke test".</verify>
  <done>PATCH /api/profile accepts tiktok_handle, upserts creator_profiles, and triggers a non-blocking background scrape. GET /api/profile returns tiktok_handle. Console.error calls replaced with structured logger.</done>
</task>

</tasks>

<verification>
1. `pnpm test` passes with all existing tests
2. `pnpm build` succeeds (TypeScript compiles cleanly)
3. Profile route accepts tiktok_handle in request body
4. Background scrape is intentionally fire-and-forget (void async IIFE)
</verification>

<success_criteria>
- tiktok_handle accepted in PATCH body and persisted to creator_profiles
- Background scrape runs without blocking the response
- Scrape failure doesn't affect the profile update success
- GET /api/profile returns tiktok_handle
- No console.error calls remain in profile route
</success_criteria>

<output>
After completion, create `.planning/phases/06-hardening/06-04-SUMMARY.md`
</output>
