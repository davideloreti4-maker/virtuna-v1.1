---
phase: 06-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/engine/gemini.ts
  - src/lib/engine/deepseek.ts
autonomous: true

must_haves:
  truths:
    - "Malformed calibration-baseline.json does not crash gemini.ts — falls back to null calibration data"
    - "Malformed calibration-baseline.json does not crash deepseek.ts — falls back to null calibration data"
    - "A Zod schema validates calibration-baseline.json shape before use in both modules"
    - "Tests pass after changes"
  artifacts:
    - path: "src/lib/engine/gemini.ts"
      provides: "Try-catch + Zod validation around loadCalibrationData"
      contains: "CalibrationBaselineSchema"
    - path: "src/lib/engine/deepseek.ts"
      provides: "Try-catch + Zod validation around loadCalibrationData"
      contains: "CalibrationBaselineSchema"
  key_links:
    - from: "src/lib/engine/gemini.ts"
      to: "calibration-baseline.json"
      via: "loadCalibrationData with Zod parse"
      pattern: "CalibrationBaselineSchema\\.parse"
    - from: "src/lib/engine/deepseek.ts"
      to: "calibration-baseline.json"
      via: "loadCalibrationData with Zod parse"
      pattern: "CalibrationBaselineSchema\\.parse"
---

<objective>
Harden calibration-baseline.json parsing in both gemini.ts and deepseek.ts so a malformed or missing file never causes an unhandled throw. Add a Zod schema to validate the calibration data shape.

Purpose: HARD-01 and HARD-02 — prevent calibration file corruption from taking down the entire prediction pipeline.
Output: Both LLM modules gracefully degrade to null calibration data on parse failure.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/lib/engine/gemini.ts
@src/lib/engine/deepseek.ts
@src/lib/engine/calibration-baseline.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Zod schema and harden loadCalibrationData in gemini.ts</name>
  <files>src/lib/engine/gemini.ts</files>
  <action>
1. Define a `CalibrationBaselineSchema` Zod schema matching the `CalibrationData` interface at the top of gemini.ts:
   ```ts
   const CalibrationBaselineSchema = z.object({
     primary_kpis: z.object({
       share_rate: z.object({ viral_threshold: z.number() }),
       weighted_engagement_score: z.object({ percentiles: z.object({ p90: z.number() }) }),
     }),
     duration_analysis: z.object({
       sweet_spot_by_weighted_score: z.object({ optimal_range_seconds: z.array(z.number()) }),
     }),
     viral_vs_average: z.object({
       differentiators: z.array(z.object({
         factor: z.string(),
         difference_pct: z.number(),
         description: z.string(),
       })),
     }),
   });
   ```
   Import `z` from "zod" (already available — used elsewhere in this file's imports via types.ts).

2. Wrap the `loadCalibrationData()` function body in try-catch:
   - In the try block: after `JSON.parse(raw)`, replace the `as CalibrationData` cast with `CalibrationBaselineSchema.parse(parsed)`.
   - In the catch block: log a warning via the existing `log` logger (`log.warn("Failed to load calibration data", { error: error.message })`), set `cachedCalibration` to null, and return null.
   - Change the return type from `Promise<CalibrationData>` to `Promise<CalibrationData | null>`.

3. Update `analyzeWithGemini` and `analyzeVideoWithGemini` to handle null calibration:
   - Where `loadCalibrationData()` is called, add a null check. If null, use hardcoded sensible defaults:
     ```ts
     const FALLBACK_CALIBRATION: CalibrationData = {
       primary_kpis: {
         share_rate: { viral_threshold: 0.02 },
         weighted_engagement_score: { percentiles: { p90: 85 } },
       },
       duration_analysis: {
         sweet_spot_by_weighted_score: { optimal_range_seconds: [15, 60] },
       },
       viral_vs_average: { differentiators: [] },
     };
     ```
   - Use: `const calibration = (await loadCalibrationData()) ?? FALLBACK_CALIBRATION;`

4. Export `CalibrationBaselineSchema` for reuse in deepseek.ts (Task 2).

Note: Do NOT add `z` import to the import block — use a local `import { z } from "zod"` since gemini.ts does not currently import from zod directly. Actually, check if there's already a zod import via types.ts. If not, add `import { z } from "zod"` at the top.
  </action>
  <verify>Run `pnpm test` — all existing tests should still pass. The calibration fallback should not affect test behavior since tests mock the Gemini client.</verify>
  <done>gemini.ts loadCalibrationData uses Zod validation and returns null on failure; analyzeWithGemini and analyzeVideoWithGemini fall back to hardcoded defaults when calibration is null.</done>
</task>

<task type="auto">
  <name>Task 2: Harden loadCalibrationData in deepseek.ts with Zod validation</name>
  <files>src/lib/engine/deepseek.ts</files>
  <action>
1. Import `z` from "zod" at the top of deepseek.ts.

2. Define a `DeepSeekCalibrationBaselineSchema` Zod schema matching the `DeepSeekCalibrationData` interface:
   ```ts
   const DeepSeekCalibrationBaselineSchema = z.object({
     primary_kpis: z.object({
       share_rate: z.object({ percentiles: z.object({ p50: z.number(), p75: z.number(), p90: z.number() }) }),
       comment_rate: z.object({ percentiles: z.object({ p50: z.number(), p75: z.number(), p90: z.number() }) }),
       save_rate: z.object({ percentiles: z.object({ p50: z.number(), p75: z.number(), p90: z.number() }) }),
       weighted_engagement_score: z.object({ percentiles: z.object({ p50: z.number(), p75: z.number(), p90: z.number() }) }),
     }),
     virality_tiers: z.array(z.object({
       tier: z.number(),
       label: z.string(),
       score_range: z.array(z.number()),
       median_share_rate: z.number(),
       median_comment_rate: z.number(),
       median_save_rate: z.number(),
     })),
     viral_vs_average: z.object({
       differentiators: z.array(z.object({
         factor: z.string(),
         difference_pct: z.number(),
         description: z.string(),
       })),
     }),
     duration_analysis: z.object({
       sweet_spot_by_weighted_score: z.object({ optimal_range_seconds: z.array(z.number()) }),
     }),
   });
   ```

3. Wrap `loadCalibrationData()` body in try-catch:
   - Replace `JSON.parse(raw) as DeepSeekCalibrationData` with `DeepSeekCalibrationBaselineSchema.parse(JSON.parse(raw))`.
   - Catch block: `log.warn("Failed to load calibration data", { error })`, set `cachedCalibration = null`, return null.
   - Change return type to `Promise<DeepSeekCalibrationData | null>`.

4. Update `reasonWithDeepSeek` and `reasonWithGeminiFallback` to handle null calibration:
   - Define a `FALLBACK_CALIBRATION: DeepSeekCalibrationData` with sensible defaults:
     ```ts
     const FALLBACK_DEEPSEEK_CALIBRATION: DeepSeekCalibrationData = {
       primary_kpis: {
         share_rate: { percentiles: { p50: 0.005, p75: 0.01, p90: 0.02 } },
         comment_rate: { percentiles: { p50: 0.003, p75: 0.006, p90: 0.012 } },
         save_rate: { percentiles: { p50: 0.002, p75: 0.005, p90: 0.01 } },
         weighted_engagement_score: { percentiles: { p50: 45, p75: 65, p90: 85 } },
       },
       virality_tiers: [],
       viral_vs_average: { differentiators: [] },
       duration_analysis: { sweet_spot_by_weighted_score: { optimal_range_seconds: [15, 60] } },
     };
     ```
   - Use: `const calibration = (await loadCalibrationData()) ?? FALLBACK_DEEPSEEK_CALIBRATION;`
   - Apply the same pattern in `reasonWithGeminiFallback`.
  </action>
  <verify>Run `pnpm test` — all 203+ tests should pass. Circuit breaker and Zod response parsing tests are unaffected since they mock the OpenAI/Gemini client layer.</verify>
  <done>deepseek.ts loadCalibrationData uses Zod validation and returns null on failure; reasonWithDeepSeek and reasonWithGeminiFallback fall back to hardcoded defaults when calibration is null.</done>
</task>

</tasks>

<verification>
1. `pnpm test` passes with all existing tests
2. `pnpm build` succeeds (TypeScript compiles cleanly)
3. Manually verify that the Zod schemas match the actual calibration-baseline.json structure by checking field names
</verification>

<success_criteria>
- Both gemini.ts and deepseek.ts have try-catch around calibration file loading
- Both use Zod schemas to validate the parsed JSON
- Both fall back to sensible defaults (not throw) when calibration file is malformed
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-hardening/06-01-SUMMARY.md`
</output>
