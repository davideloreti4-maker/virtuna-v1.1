---
phase: 06-hardening
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/lib/engine/deepseek.ts
autonomous: true

must_haves:
  truths:
    - "Concurrent half-open circuit breaker probes result in exactly one probe request passing through"
    - "Second and subsequent concurrent callers while half-open receive null (circuit still open) instead of also probing"
    - "After the single probe succeeds, the breaker resets to closed and all subsequent calls pass through"
    - "After the single probe fails, the breaker returns to open with escalated backoff"
    - "Tests pass after changes"
  artifacts:
    - path: "src/lib/engine/deepseek.ts"
      provides: "Promise-based mutex for half-open probe"
      contains: "probeInFlight"
  key_links:
    - from: "src/lib/engine/deepseek.ts:isCircuitOpen"
      to: "src/lib/engine/deepseek.ts:reasonWithDeepSeek"
      via: "probeInFlight flag prevents concurrent half-open probes"
      pattern: "probeInFlight"
---

<objective>
Add a promise-based mutex to the circuit breaker's half-open probe so that only one request probes the recovering service. Concurrent requests during half-open receive null (service still considered down) rather than all probing simultaneously.

Purpose: HARD-04 — prevent thundering herd on a recovering DeepSeek service. Only one probe request tests if the service is back; others wait or skip.
Output: Circuit breaker half-open state is mutex-protected.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/lib/engine/deepseek.ts
@.planning/phases/06-hardening/06-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add probe mutex to circuit breaker half-open transition</name>
  <files>src/lib/engine/deepseek.ts</files>
  <action>
The current `isCircuitOpen()` function (around line 101) transitions from "open" to "half-open" when `Date.now() >= breaker.nextRetryAt`. In a serverless-per-instance world, multiple concurrent requests on the same instance can both see this transition and both probe.

1. Add a `probeInFlight` flag to the module-level breaker state:
   ```ts
   let probeInFlight = false;
   ```

2. Modify `isCircuitOpen()` to use the mutex:
   ```ts
   function isCircuitOpen(): boolean {
     if (breaker.status === "closed") return false;
     if (breaker.status === "open") {
       if (Date.now() >= breaker.nextRetryAt) {
         // Mutex: only one probe at a time
         if (probeInFlight) return true; // Another request is already probing
         probeInFlight = true;
         breaker.status = "half-open";
         return false; // Allow this ONE request through as the probe
       }
       return true;
     }
     // half-open: if we're here AND probeInFlight is true, block additional requests
     // (This shouldn't happen normally since probeInFlight gates the transition above,
     // but guard defensively)
     return false;
   }
   ```

3. Reset `probeInFlight` in both `recordSuccess()` and `recordFailure()`:
   - In `recordSuccess()`: add `probeInFlight = false;` (probe succeeded, breaker closes)
   - In `recordFailure()`: add `probeInFlight = false;` (probe failed, breaker re-opens)

4. Reset `probeInFlight` in `resetCircuitBreaker()` for test isolation:
   ```ts
   export function resetCircuitBreaker(): void {
     breaker = {
       status: "closed",
       consecutiveFailures: 0,
       nextRetryAt: 0,
       backoffIndex: 0,
     };
     probeInFlight = false;
   }
   ```

5. The key behavior:
   - First concurrent request when timer expires: `probeInFlight = false` -> sets to `true`, transitions to half-open, returns `false` (allowed through)
   - Second concurrent request sees `probeInFlight = true` -> returns `true` (blocked, gets null from reasonWithDeepSeek)
   - When probe completes (success or failure), `probeInFlight` resets

Note: This is a per-instance mutex, not distributed. The STATE.md blocker acknowledges circuit breaker is per-serverless-instance. This mutex only prevents concurrent probes within a single instance, which is the actual race condition.
  </action>
  <verify>Run `pnpm test` — all existing circuit breaker tests should pass since they test sequential state transitions. The reset function clears the new flag.</verify>
  <done>Circuit breaker half-open probe protected by probeInFlight mutex. Concurrent requests during half-open period are blocked — only one probe gets through.</done>
</task>

</tasks>

<verification>
1. `pnpm test` passes with all existing tests
2. `pnpm build` succeeds
3. Verify that `resetCircuitBreaker()` resets `probeInFlight` (existing tests call this for isolation)
</verification>

<success_criteria>
- Only one probe request passes through during half-open state
- Concurrent callers during half-open receive null (circuit appears open to them)
- Probe success resets breaker AND clears mutex
- Probe failure re-opens breaker AND clears mutex
- All existing circuit breaker tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-hardening/06-03-SUMMARY.md`
</output>
