---
phase: 06-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/engine/pipeline.ts
  - src/lib/engine/aggregator.ts
autonomous: true

must_haves:
  truths:
    - "Simultaneous DeepSeek + Gemini text analysis failure returns a partial result with confidence_label LOW — not a 500 error"
    - "Pipeline catches Gemini failure and produces a degraded PipelineResult instead of throwing"
    - "Aggregator handles null geminiResult by using zero-score defaults for all factor scores"
    - "Tests pass after changes"
  artifacts:
    - path: "src/lib/engine/pipeline.ts"
      provides: "Gemini failure caught with fallback PipelineResult"
      contains: "DEFAULT_GEMINI_RESULT"
    - path: "src/lib/engine/aggregator.ts"
      provides: "Null-safe gemini handling in aggregateScores with explicit LOW confidence override for dual-LLM failure"
      contains: "!availability.gemini && !availability.behavioral"
  key_links:
    - from: "src/lib/engine/pipeline.ts"
      to: "src/lib/engine/aggregator.ts"
      via: "PipelineResult.geminiResult can now be a fallback"
      pattern: "DEFAULT_GEMINI_RESULT"
---

<objective>
Implement graceful dual-LLM-failure path so that when both DeepSeek AND Gemini fail, the pipeline returns a partial result with LOW confidence instead of throwing a 500 error.

Purpose: HARD-03 — the prediction pipeline should never crash even when all external LLM providers are down. Users get a degraded but usable response.
Output: Pipeline degrades gracefully to rules+trends-only scoring with LOW confidence.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/lib/engine/pipeline.ts
@src/lib/engine/aggregator.ts
@src/lib/engine/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Make Gemini failure non-fatal in pipeline.ts</name>
  <files>src/lib/engine/pipeline.ts</files>
  <action>
Currently in pipeline.ts, Stage 3 (Gemini Analysis) is marked as CRITICAL and throws on failure (lines 181-192). The pipeline re-throws with `throw new Error("Analysis failed: Gemini content analysis ...")`.

Change Gemini to be non-fatal:

1. Add a default fallback Gemini result constant at the module level (alongside the other DEFAULT_ constants):
   ```ts
   const DEFAULT_GEMINI_RESULT: PipelineResult["geminiResult"] = {
     analysis: {
       factors: [
         { name: "Scroll-Stop Power", score: 0, rationale: "Analysis unavailable", improvement_tip: "N/A" },
         { name: "Completion Pull", score: 0, rationale: "Analysis unavailable", improvement_tip: "N/A" },
         { name: "Rewatch Potential", score: 0, rationale: "Analysis unavailable", improvement_tip: "N/A" },
         { name: "Share Trigger", score: 0, rationale: "Analysis unavailable", improvement_tip: "N/A" },
         { name: "Emotional Charge", score: 0, rationale: "Analysis unavailable", improvement_tip: "N/A" },
       ],
       overall_impression: "Content analysis unavailable — external AI service error.",
       content_summary: "Unable to analyze content at this time.",
     },
     cost_cents: 0,
   };
   ```

2. Modify Stage 3 (Gemini Analysis) from throwing to gracefully degrading:
   - Wrap the existing try-catch to catch the error, log it, add to warnings, record a timing of 0, and return `DEFAULT_GEMINI_RESULT` (same pattern as creator/rules/trends stages).
   - Change the geminiPromise from a throw on error to a warning+fallback:
     ```ts
     const geminiPromise = (async (): Promise<PipelineResult["geminiResult"]> => {
       try {
         return await timed("gemini_analysis", timings, () => analyzeWithGemini(validated));
       } catch (error) {
         Sentry.captureException(error, { tags: { stage: "gemini_analysis", requestId } });
         warnings.push(`Gemini analysis unavailable: ${error instanceof Error ? error.message : String(error)}`);
         timings.push({ stage: "gemini_analysis", duration_ms: 0 });
         return DEFAULT_GEMINI_RESULT;
       }
     })();
     ```

3. The rest of the pipeline stays the same — DeepSeek already handles Gemini failure context gracefully (it still gets the default analysis factors in its prompt), and the aggregator handles missing signals via weight redistribution.
  </action>
  <verify>Run `pnpm test` — existing pipeline tests should pass since they mock Gemini. Verify no TypeScript errors with `pnpm build`.</verify>
  <done>Gemini failure in the pipeline produces a fallback result with zero scores and a warning instead of crashing the pipeline.</done>
</task>

<task type="auto">
  <name>Task 2: Handle dual-failure aggregation with explicit LOW confidence override</name>
  <files>src/lib/engine/aggregator.ts</files>
  <action>
The aggregator already handles missing DeepSeek (null deepseekResult) via weight redistribution. But it assumes geminiResult always has valid data. When both fail:
- `geminiResult` will have the fallback with all factor scores = 0
- `deepseekResult` will be null
- The aggregator's `availability.gemini` should be `false` when Gemini is using fallback data

**IMPORTANT — calculateConfidence() does NOT naturally produce LOW in this case:**
When both scores are 0, `geminiDirection = 0 - 50 = -50` and `behavioralDirection = 0 - 50 = -50`.
Both are negative (same sign), so `agreement = 0.4`. Signal component is ~0.1 (base 0.2 minus penalties).
Total: `0.5` which maps to `"MEDIUM"` (LOW threshold is `< 0.4`). This is WRONG for a dual-failure scenario.
An explicit override is required.

1. Add Gemini availability detection in `aggregateScores()`:
   - Currently `availability.gemini = true` (always). Change to detect fallback:
     ```ts
     gemini: geminiResult.analysis.factors.some(f => f.score > 0),
     ```
   This is false when ALL factors are 0 (our fallback), true when any real analysis exists.

2. Add explicit dual-LLM-failure confidence override in `aggregateScores()`:
   - After the `calculateConfidence()` call (around line 320), add a branch that forces LOW when both LLMs failed:
     ```ts
     // Override confidence to LOW when both LLM providers failed.
     // calculateConfidence() incorrectly yields MEDIUM here because both
     // zero-scores produce the same direction (-50), triggering the
     // "models agree" branch (agreement = 0.4). In reality, two zeros
     // agreeing is meaningless — force LOW to reflect actual data quality.
     if (!availability.gemini && !availability.behavioral) {
       conf.confidence = 0.2;
       conf.confidence_label = "LOW";
     }
     ```
   - Note: `conf` is currently declared with `const`. Change to `let` so we can reassign:
     ```ts
     let conf = calculateConfidence(
       gemini_score,
       behavioral_score,
       ruleResult,
       trendEnrichment,
       hasVideo,
       deepseek?.confidence ?? "low",
       availability
     );

     // Dual-LLM-failure override — force LOW confidence
     if (!availability.gemini && !availability.behavioral) {
       conf = { confidence: 0.2, confidence_label: "LOW" };
     }
     ```

3. Add an explicit dual-failure warning in the warnings array:
   ```ts
   if (!availability.gemini && !availability.behavioral) {
     warnings.push("Both LLM providers failed — result based on rules and trends only");
   }
   ```
   Add this after the existing missing-signals warning block (around line 333).

4. Weight redistribution via `selectWeights()` already handles this correctly — no changes needed there.
  </action>
  <verify>Run `pnpm test` — all aggregator tests pass. Manually trace: with both LLMs failed, conf should be `{ confidence: 0.2, confidence_label: "LOW" }` due to the explicit override, NOT the misleading MEDIUM from calculateConfidence().</verify>
  <done>Aggregator detects fallback Gemini data, marks gemini availability as false, redistributes weights to remaining signals, forces confidence to LOW via explicit override (bypassing calculateConfidence's incorrect MEDIUM), and adds dual-failure warning.</done>
</task>

</tasks>

<verification>
1. `pnpm test` passes with all existing tests
2. `pnpm build` succeeds
3. When both Gemini and DeepSeek are mocked to fail, the pipeline returns a PipelineResult (no throw) and the aggregator returns a PredictionResult with `confidence_label: "LOW"`
</verification>

<success_criteria>
- Simulating both LLM failures produces a partial result, not a 500 error
- The partial result has `confidence_label: "LOW"`
- Warnings clearly indicate both LLM providers failed
- Remaining signals (ML, rules, trends) still contribute to the score
</success_criteria>

<output>
After completion, create `.planning/phases/06-hardening/06-02-SUMMARY.md`
</output>
