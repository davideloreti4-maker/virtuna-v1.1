---
phase: 06-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/engine/pipeline.ts
  - src/lib/engine/aggregator.ts
autonomous: true

must_haves:
  truths:
    - "Simultaneous DeepSeek + Gemini text analysis failure returns a partial result with confidence_label LOW — not a 500 error"
    - "Pipeline catches Gemini failure and produces a degraded PipelineResult instead of throwing"
    - "Aggregator handles null geminiResult by using zero-score defaults for all factor scores"
    - "Tests pass after changes"
  artifacts:
    - path: "src/lib/engine/pipeline.ts"
      provides: "Gemini failure caught with fallback PipelineResult"
      contains: "DEFAULT_GEMINI_RESULT"
    - path: "src/lib/engine/aggregator.ts"
      provides: "Null-safe gemini handling in aggregateScores"
  key_links:
    - from: "src/lib/engine/pipeline.ts"
      to: "src/lib/engine/aggregator.ts"
      via: "PipelineResult.geminiResult can now be a fallback"
      pattern: "DEFAULT_GEMINI_RESULT"
---

<objective>
Implement graceful dual-LLM-failure path so that when both DeepSeek AND Gemini fail, the pipeline returns a partial result with LOW confidence instead of throwing a 500 error.

Purpose: HARD-03 — the prediction pipeline should never crash even when all external LLM providers are down. Users get a degraded but usable response.
Output: Pipeline degrades gracefully to rules+trends-only scoring with LOW confidence.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/lib/engine/pipeline.ts
@src/lib/engine/aggregator.ts
@src/lib/engine/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Make Gemini failure non-fatal in pipeline.ts</name>
  <files>src/lib/engine/pipeline.ts</files>
  <action>
Currently in pipeline.ts, Stage 3 (Gemini Analysis) is marked as CRITICAL and throws on failure (lines 181-192). The pipeline re-throws with `throw new Error("Analysis failed: Gemini content analysis ...")`.

Change Gemini to be non-fatal:

1. Add a default fallback Gemini result constant at the module level (alongside the other DEFAULT_ constants):
   ```ts
   const DEFAULT_GEMINI_RESULT: PipelineResult["geminiResult"] = {
     analysis: {
       factors: [
         { name: "Scroll-Stop Power", score: 0, rationale: "Analysis unavailable", improvement_tip: "N/A" },
         { name: "Completion Pull", score: 0, rationale: "Analysis unavailable", improvement_tip: "N/A" },
         { name: "Rewatch Potential", score: 0, rationale: "Analysis unavailable", improvement_tip: "N/A" },
         { name: "Share Trigger", score: 0, rationale: "Analysis unavailable", improvement_tip: "N/A" },
         { name: "Emotional Charge", score: 0, rationale: "Analysis unavailable", improvement_tip: "N/A" },
       ],
       overall_impression: "Content analysis unavailable — external AI service error.",
       content_summary: "Unable to analyze content at this time.",
     },
     cost_cents: 0,
   };
   ```

2. Modify Stage 3 (Gemini Analysis) from throwing to gracefully degrading:
   - Wrap the existing try-catch to catch the error, log it, add to warnings, record a timing of 0, and return `DEFAULT_GEMINI_RESULT` (same pattern as creator/rules/trends stages).
   - Change the geminiPromise from a throw on error to a warning+fallback:
     ```ts
     const geminiPromise = (async (): Promise<PipelineResult["geminiResult"]> => {
       try {
         return await timed("gemini_analysis", timings, () => analyzeWithGemini(validated));
       } catch (error) {
         Sentry.captureException(error, { tags: { stage: "gemini_analysis", requestId } });
         warnings.push(`Gemini analysis unavailable: ${error instanceof Error ? error.message : String(error)}`);
         timings.push({ stage: "gemini_analysis", duration_ms: 0 });
         return DEFAULT_GEMINI_RESULT;
       }
     })();
     ```

3. The rest of the pipeline stays the same — DeepSeek already handles Gemini failure context gracefully (it still gets the default analysis factors in its prompt), and the aggregator handles missing signals via weight redistribution.
  </action>
  <verify>Run `pnpm test` — existing pipeline tests should pass since they mock Gemini. Verify no TypeScript errors with `pnpm build`.</verify>
  <done>Gemini failure in the pipeline produces a fallback result with zero scores and a warning instead of crashing the pipeline.</done>
</task>

<task type="auto">
  <name>Task 2: Handle dual-failure aggregation with LOW confidence</name>
  <files>src/lib/engine/aggregator.ts</files>
  <action>
The aggregator already handles missing DeepSeek (null deepseekResult) via weight redistribution. But it assumes geminiResult always has valid data. When both fail:
- `geminiResult` will have the fallback with all factor scores = 0
- `deepseekResult` will be null
- The aggregator's `availability.gemini` should be `false` when Gemini is using fallback data

1. Add Gemini availability detection in `aggregateScores()`:
   - Currently `availability.gemini = true` (always). Change to detect fallback:
     ```ts
     gemini: geminiResult.analysis.factors.some(f => f.score > 0),
     ```
   This is false when ALL factors are 0 (our fallback), true when any real analysis exists.

2. When both `gemini` and `behavioral` availability are false (dual LLM failure):
   - The existing `selectWeights()` already handles this — it redistributes to remaining sources (ml, rules, trends).
   - The `calculateConfidence()` function will naturally produce LOW confidence since `geminiScore` and `behavioralScore` both = 0 and disagree on direction = 0 agreement component.
   - Add an explicit warning in the warnings array:
     ```ts
     if (!availability.gemini && !availability.behavioral) {
       warnings.push("Both LLM providers failed — result based on rules and trends only");
     }
     ```
     Add this after the existing missing-signals warning block.

3. No structural changes needed — the weight redistribution and confidence calculation already handle the degenerate case correctly. The explicit `gemini: false` availability flag ensures weights flow to ml/rules/trends, and confidence drops to LOW.
  </action>
  <verify>Run `pnpm test` — all aggregator tests pass. The NaN guard from 05-02 handles the edge case where most signals are unavailable.</verify>
  <done>Aggregator detects fallback Gemini data, marks gemini availability as false, redistributes weights to remaining signals, and adds explicit dual-failure warning. Confidence is naturally LOW.</done>
</task>

</tasks>

<verification>
1. `pnpm test` passes with all existing tests
2. `pnpm build` succeeds
3. When both Gemini and DeepSeek are mocked to fail, the pipeline returns a PipelineResult (no throw) and the aggregator returns a PredictionResult with `confidence_label: "LOW"`
</verification>

<success_criteria>
- Simulating both LLM failures produces a partial result, not a 500 error
- The partial result has `confidence_label: "LOW"`
- Warnings clearly indicate both LLM providers failed
- Remaining signals (ML, rules, trends) still contribute to the score
</success_criteria>

<output>
After completion, create `.planning/phases/06-hardening/06-02-SUMMARY.md`
</output>
