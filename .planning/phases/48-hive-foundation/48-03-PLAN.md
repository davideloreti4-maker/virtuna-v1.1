---
phase: 48-hive-foundation
plan: 03
type: execute
wave: 3
depends_on: ["48-01", "48-02"]
files_modified:
  - src/components/hive/use-hive-animation.ts
  - src/components/hive/HiveCanvas.tsx
autonomous: true

must_haves:
  truths:
    - "Hive renders center rounded rectangle with 3 concentric tiers of circle nodes connected by fading lines"
    - "Progressive build animation plays on first load: center first, then tier-1, tier-2, tier-3 radiating outward"
    - "Users with prefers-reduced-motion see a static layout with no animations"
    - "Canvas maintains 60fps rendering on a standard laptop"
    - "Skeleton hive shows when data is null/loading"
    - "Build animation plays only once on initial render; re-renders show hive immediately"
  artifacts:
    - path: "src/components/hive/use-hive-animation.ts"
      provides: "Progressive build animation hook with reduced motion support"
      exports: ["useHiveAnimation"]
    - path: "src/components/hive/HiveCanvas.tsx"
      provides: "Main canvas component wiring layout, renderer, resize, animation"
      exports: ["HiveCanvas"]
  key_links:
    - from: "src/components/hive/HiveCanvas.tsx"
      to: "src/components/hive/hive-layout.ts"
      via: "useMemo calling computeHiveLayout"
      pattern: "computeHiveLayout"
    - from: "src/components/hive/HiveCanvas.tsx"
      to: "src/components/hive/hive-renderer.ts"
      via: "calls renderHive and renderSkeletonHive in render function"
      pattern: "renderHive|renderSkeletonHive"
    - from: "src/components/hive/HiveCanvas.tsx"
      to: "src/components/hive/use-canvas-resize.ts"
      via: "useCanvasResize hook with canvasRef"
      pattern: "useCanvasResize"
    - from: "src/components/hive/HiveCanvas.tsx"
      to: "src/components/hive/use-hive-animation.ts"
      via: "useHiveAnimation hook providing visibility state"
      pattern: "useHiveAnimation"
    - from: "src/components/hive/HiveCanvas.tsx"
      to: "@/hooks/usePrefersReducedMotion"
      via: "import usePrefersReducedMotion"
      pattern: "usePrefersReducedMotion"
    - from: "src/components/hive/use-hive-animation.ts"
      to: "src/components/hive/hive-constants.ts"
      via: "import ANIMATION_TIMING"
      pattern: "ANIMATION_TIMING"
---

<objective>
Build the progressive animation hook and the main HiveCanvas React component that wires together layout, rendering, resize, and animation into a working canvas visualization.

Purpose: This is the integration plan -- all pure functions from Plans 01 and 02 get orchestrated into a single React component. The animation hook controls the progressive build reveal. HiveCanvas is the component that pages will render.

Output: Two files -- `use-hive-animation.ts` (animation state hook) and `HiveCanvas.tsx` (main client component).
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/48-hive-foundation/48-CONTEXT.md
@.planning/phases/48-hive-foundation/48-RESEARCH.md
@.planning/phases/48-hive-foundation/48-01-SUMMARY.md
@.planning/phases/48-hive-foundation/48-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Progressive build animation hook</name>
  <files>src/components/hive/use-hive-animation.ts</files>
  <action>
    Create `src/components/hive/use-hive-animation.ts` as a client-side hook:

    ```
    'use client';
    ```

    Export `useHiveAnimation(options: { active: boolean; reducedMotion: boolean; onFrame: () => void })`:

    The hook manages a `requestAnimationFrame` loop that computes per-tier visibility based on elapsed time and calls `onFrame` to trigger re-renders.

    **Return type:** `{ visibility: Record<number, { opacity: number; scale: number }>; isAnimating: boolean; isComplete: boolean }`

    **Behavior:**

    1. When `active` becomes `true` and animation hasn't completed yet:
       - Record `startTime = performance.now()`
       - Start a `requestAnimationFrame` loop

    2. On each animation frame:
       - Calculate `elapsed = now - startTime`
       - For each tier (0, 1, 2, 3), compute visibility using `ANIMATION_TIMING`:
         - If `elapsed < tier.delay`: opacity=0, scale=0
         - If `elapsed >= tier.delay + tier.duration`: opacity=1, scale=1
         - Otherwise: `progress = (elapsed - delay) / duration`, apply `easeOutCubic(progress)`
         - Opacity = eased progress
         - Scale = 0.5 + eased * 0.5 (scales from 50% to 100%)
       - Store visibility in a ref (NOT state -- we don't want React re-renders per frame)
       - Call `onFrame()` to trigger a canvas redraw from the parent

    3. When all tiers reach opacity=1 and scale=1:
       - Set `isComplete = true` via ref
       - Cancel the animation frame loop
       - Set `isAnimating = false`

    4. When `reducedMotion` is true:
       - Skip animation entirely
       - Return all tiers at full visibility immediately: `{ opacity: 1, scale: 1 }`
       - Set `isComplete = true`, `isAnimating = false`

    5. Track completion in a ref so that subsequent re-mounts don't replay the animation (first load only). Use a module-level `let hasAnimated = false` flag that persists across re-renders but resets on page navigation. Actually -- use a ref initialized to false, and only set to true after animation completes. If the component re-mounts (e.g., tab switch), the ref resets and animation could replay. To prevent this, use a module-level variable:
       ```typescript
       let globalAnimationComplete = false;
       ```
       Check this before starting animation. Set it to true when complete.

    6. Cleanup: Cancel `requestAnimationFrame` in useEffect cleanup to prevent memory leaks.

    **Easing function** (inline, not imported):
    ```typescript
    function easeOutCubic(t: number): number {
      return 1 - Math.pow(1 - t, 3);
    }
    ```

    Import `ANIMATION_TIMING` from `./hive-constants`.
  </action>
  <verify>
    - `pnpm exec tsc --noEmit` passes
    - Hook exports `useHiveAnimation`
    - `cancelAnimationFrame` is in the cleanup function
    - `easeOutCubic(0) === 0`, `easeOutCubic(1) === 1`
    - Reduced motion path returns full visibility without animation loop
  </verify>
  <done>
    Animation hook drives progressive tier reveal with easeOutCubic easing. Reduced motion users get instant static display. Animation plays only on first load (module-level completion flag). No memory leaks from uncanceled animation frames.
  </done>
</task>

<task type="auto">
  <name>Task 2: HiveCanvas component -- wire everything together</name>
  <files>src/components/hive/HiveCanvas.tsx</files>
  <action>
    Create `src/components/hive/HiveCanvas.tsx` as the main client component:

    ```
    'use client';
    ```

    **Props interface:**
    ```typescript
    interface HiveCanvasProps {
      data: HiveData | null;  // null = show skeleton loading state
      className?: string;
    }
    ```

    **Component implementation:**

    1. **Refs:**
       - `canvasRef = useRef<HTMLCanvasElement>(null)`
       - `layoutRef = useRef<LayoutResult | null>(null)` -- stores layout for render access without triggering re-renders

    2. **Layout computation (useMemo):**
       - `const layout = useMemo(() => data ? computeHiveLayout(data) : null, [data])`
       - Update layoutRef in a useEffect synced to layout changes

    3. **Reduced motion:**
       - `const reducedMotion = usePrefersReducedMotion()` from `@/hooks/usePrefersReducedMotion`

    4. **Render function (useCallback):**
       - Get canvas context: `canvasRef.current?.getContext('2d')`
       - Get DPR from sizeRef
       - Clear canvas: `ctx.clearRect(0, 0, canvas.width, canvas.height)`
       - Save context, apply DPR scale: `ctx.scale(dpr, dpr)`
       - If layoutRef.current exists: call `renderHive(ctx, layoutRef.current, cssWidth, cssHeight, animationHook.visibility)`
       - If no layout (data is null): call `renderSkeletonHive(ctx, cssWidth, cssHeight)`
       - Restore context

    5. **Canvas resize hook:**
       - `const sizeRef = useCanvasResize(canvasRef, render)` -- render is the onResize callback
       - This triggers re-render on every resize, keeping canvas in sync

    6. **Animation hook:**
       - `const animation = useHiveAnimation({ active: !!layout, reducedMotion, onFrame: render })`
       - Animation starts when layout becomes available
       - Each frame calls render() which reads animation.visibility from the ref

    7. **Re-render on layout change:**
       - `useEffect(() => { render(); }, [layout, render])` -- initial render + data change

    8. **JSX:**
       ```tsx
       <canvas
         ref={canvasRef}
         className={cn('w-full h-full', className)}
         style={{ width: '100%', height: '100%' }}
         aria-label="Hive visualization showing test content analysis"
         role="img"
       />
       ```
       Use `cn` from the project's utility (check if it exists at `@/lib/utils` -- this project likely has it). If not, just concatenate classNames manually.

    **IMPORTANT considerations:**
    - The render function must read visibility from animation hook's returned ref, NOT from state. This avoids React re-renders on every animation frame.
    - The animation hook calls `onFrame` (which is `render`) on each requestAnimationFrame tick. The render function reads the current visibility from the animation hook's visibility getter.
    - To make this work, `useHiveAnimation` should expose `visibility` as a getter that reads from the internal ref, OR return a ref. The render function reads `animation.visibility` which is always current.
    - Pattern: animation hook stores visibility in a ref, returns a stable object with a getter. The render function (called by onFrame) reads the getter synchronously.

    **Integration test:** After creating HiveCanvas, temporarily add it to an existing page (or create a quick test route) to verify it renders. Use mock data:
    ```tsx
    import { generateMockHiveData } from './hive-mock-data';
    // In a test page:
    const data = generateMockHiveData();
    <HiveCanvas data={data} className="w-full h-[600px]" />
    ```

    Run `pnpm dev` and verify the hive renders in the browser. Check for:
    - Progressive build animation (center first, tiers radiate out)
    - Crisp rendering on retina display
    - Canvas resizes when window resizes
    - Skeleton state when data is null

    After verifying locally, remove any test route changes (the visual checkpoint in Plan 04 handles formal verification).
  </action>
  <verify>
    - `pnpm exec tsc --noEmit` passes
    - `pnpm dev` starts without errors
    - HiveCanvas renders on screen with mock data showing ~1300 nodes in radial layout
    - Nodes are visible as circles, connections as lines, center as rounded rectangle
    - Progressive animation plays on first load
    - Resizing browser window causes canvas to resize and re-render
  </verify>
  <done>
    HiveCanvas component renders a complete hive visualization with progressive build animation, retina support, responsive resize, and skeleton loading state. Data=null shows skeleton, data provided shows full hive with ~1300 mock nodes.
  </done>
</task>

</tasks>

<verification>
- `pnpm exec tsc --noEmit` passes
- `pnpm dev` runs without errors
- HiveCanvas with mock data renders all 3 tiers of nodes + center rect + connection lines
- Progressive build animation plays: center -> tier-1 -> tier-2 -> tier-3
- With `prefers-reduced-motion`, hive appears instantly without animation
- Canvas is crisp on retina (no blurry edges)
- Canvas resizes when window resizes
- Data=null shows skeleton hive (concentric rings + placeholder dots)
</verification>

<success_criteria>
- useHiveAnimation drives progressive reveal with easeOutCubic easing and first-load-only flag
- HiveCanvas correctly wires layout, renderer, resize, and animation
- All 9 HIVE requirements are addressed across the 3 plans:
  - HIVE-01: Center rounded rectangle (renderer)
  - HIVE-02: 3 tiers of nodes (layout + renderer)
  - HIVE-03: Connection lines with tier fade (renderer)
  - HIVE-04: Deterministic layout (d3-hierarchy + sort)
  - HIVE-05: 60fps performance (batched rendering)
  - HIVE-06: Retina/HiDPI support (resize hook + DPR)
  - HIVE-07: Responsive resize (ResizeObserver)
  - HIVE-08: Reduced motion fallback (animation hook)
  - HIVE-09: Skeleton loading state (renderer)
</success_criteria>

<output>
After completion, create `.planning/phases/48-hive-foundation/48-03-SUMMARY.md`
</output>
