---
phase: 48-hive-foundation
plan: 02
type: execute
wave: 2
depends_on: ["48-01"]
files_modified:
  - src/components/hive/use-canvas-resize.ts
  - src/components/hive/hive-renderer.ts
autonomous: true

must_haves:
  truths:
    - "Canvas renders crisp on retina/HiDPI displays (no blurriness on MacBook)"
    - "Canvas resizes fluidly when browser window changes size"
    - "Skeleton loading state shows faint concentric rings with placeholder dots"
    - "Connection lines fade by tier (tier-1 brightest, tier-3 dimmest)"
    - "Nodes render as circles with tier-based size and opacity"
    - "Center renders as rounded rectangle"
  artifacts:
    - path: "src/components/hive/use-canvas-resize.ts"
      provides: "ResizeObserver + DPR canvas hook"
      exports: ["useCanvasResize"]
    - path: "src/components/hive/hive-renderer.ts"
      provides: "All Canvas 2D drawing functions"
      exports: ["renderHive", "renderSkeletonHive"]
  key_links:
    - from: "src/components/hive/use-canvas-resize.ts"
      to: "ResizeObserver"
      via: "devicePixelContentBoxSize with contentBox fallback"
      pattern: "devicePixelContentBoxSize|contentBoxSize|contentRect"
    - from: "src/components/hive/hive-renderer.ts"
      to: "src/components/hive/hive-constants.ts"
      via: "import constants for tier config"
      pattern: "import.*TIER_CONFIG|NODE_SIZES|LINE_OPACITY"
    - from: "src/components/hive/hive-renderer.ts"
      to: "src/components/hive/hive-types.ts"
      via: "import LayoutResult for render function param"
      pattern: "import.*LayoutResult"
---

<objective>
Build the canvas resize hook (ResizeObserver + DPR scaling) and all Canvas 2D drawing functions (nodes, connections, center element, skeleton loading state).

Purpose: These are the visual rendering primitives. The resize hook ensures crisp retina rendering and responsive sizing. The renderer implements batched draw calls for 60fps with 1000+ nodes. Together they handle everything that gets pixels on screen.

Output: Two files -- `use-canvas-resize.ts` (React hook) and `hive-renderer.ts` (pure drawing functions).
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/48-hive-foundation/48-CONTEXT.md
@.planning/phases/48-hive-foundation/48-RESEARCH.md
@.planning/phases/48-hive-foundation/48-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Canvas resize hook with retina DPR support</name>
  <files>src/components/hive/use-canvas-resize.ts</files>
  <action>
    Create `src/components/hive/use-canvas-resize.ts` as a client-side React hook:

    ```
    'use client';
    ```

    Export `useCanvasResize(canvasRef: RefObject<HTMLCanvasElement | null>, onResize: (size: CanvasSize) => void)`:

    1. Use `useEffect` to set up a `ResizeObserver` on the canvas element
    2. Implement the DPR fallback chain from RESEARCH.md:
       - Try `entry.devicePixelContentBoxSize` first (Chrome/Edge -- already in device pixels, set dpr=1)
       - Fallback to `entry.contentBoxSize` * `window.devicePixelRatio`
       - Final fallback to `entry.contentRect` * `window.devicePixelRatio`
    3. On each resize:
       - Calculate `displayWidth = Math.round(width * dpr)` and `displayHeight = Math.round(height * dpr)`
       - Only update if canvas buffer size actually changed (avoid unnecessary redraws)
       - Set `canvas.width = displayWidth` and `canvas.height = displayHeight` (buffer dimensions)
       - Call `onResize({ width: cssWidth, height: cssHeight, dpr })` where cssWidth/cssHeight are the CSS pixel dimensions
    4. Try observing with `{ box: 'device-pixel-content-box' }`, catch and fallback to `{ box: 'content-box' }`
    5. Clean up observer on unmount
    6. Return a `sizeRef` (useRef<CanvasSize>) so callers can read current size synchronously

    Import `CanvasSize` from `./hive-types`.

    IMPORTANT: Do NOT set CSS width/height on the canvas element from this hook. CSS sizing is handled by the parent component's Tailwind classes. This hook only manages the buffer (backing store) dimensions.

    IMPORTANT: The `onResize` callback should be wrapped in `useCallback` by the consumer, but this hook should accept it as-is and use it in the dependency array of useEffect. Use `useRef` to store the latest callback to avoid re-creating the observer when callback changes.
  </action>
  <verify>
    - `pnpm exec tsc --noEmit` passes
    - Hook exports `useCanvasResize` function
    - ResizeObserver cleanup is in the useEffect return
  </verify>
  <done>
    Canvas resize hook handles retina DPR scaling with Safari fallback chain. Buffer dimensions update on resize, CSS sizing left to parent.
  </done>
</task>

<task type="auto">
  <name>Task 2: Hive renderer -- batched drawing functions + skeleton</name>
  <files>src/components/hive/hive-renderer.ts</files>
  <action>
    Create `src/components/hive/hive-renderer.ts` with pure drawing functions (no React, no hooks, no DOM queries -- only CanvasRenderingContext2D operations):

    **Internal helper functions (not exported):**

    1. `drawConnectionLines(ctx, links, transform)`:
       - Group links by target node tier for batched opacity
       - For each tier group: single `beginPath()`, loop `moveTo()`/`lineTo()` with transformed coordinates, single `stroke()`
       - Line color: `rgba(255, 255, 255, opacity)` where opacity comes from `LINE_OPACITY[tier]`
       - Line width: 1 (CSS pixel, will be scaled by DPR via ctx.scale)
       - Apply transform (scale + offset) to source/target coordinates before drawing

    2. `drawNodes(ctx, nodes, transform)`:
       - Group nodes by tier for batched rendering
       - For each tier group: single `beginPath()`, loop `moveTo()`/`arc()`, single `fill()`
       - Tier colors from `TIER_COLORS`, radii from `NODE_SIZES`
       - Skip tier 0 (center) -- handled separately
       - Use `Math.round()` on all coordinates after transform for integer pixel alignment
       - Support optional `visibility` param: `Record<number, { opacity: number; scale: number }>` for animation. Default all tiers fully visible. When opacity < 1, set `ctx.globalAlpha`. When scale < 1, multiply node radius by scale.

    3. `drawCenterRect(ctx, centerNode, transform)`:
       - Draw a rounded rectangle at center position using `ctx.roundRect()`
       - Dimensions from `NODE_SIZES.center` (80x60), border radius 8px
       - Fill: `rgba(255, 255, 255, 0.04)` (subtle dark fill)
       - Stroke: `TIER_COLORS[0]` which is `rgba(255, 255, 255, 0.10)`
       - Line width 1
       - Support visibility param (opacity + scale) for animation

    **Exported functions:**

    4. `renderHive(ctx, layout: LayoutResult, canvasWidth, canvasHeight, visibility?)`:
       - Clear canvas: `ctx.clearRect(0, 0, canvasWidth * dpr, canvasHeight * dpr)` -- actually, caller handles clear. This function just draws.
       - Compute fit transform using `computeFitTransform(layout.bounds, canvasWidth, canvasHeight)`
       - Draw in order: connection lines first (underneath), then nodes on top, then center rect on top of everything
       - Pass transform to all draw helpers
       - The `visibility` param is `Record<number, { opacity: number; scale: number }>` -- if provided, controls per-tier visibility for progressive build animation. Tiers not in the record are hidden (opacity 0).

    5. `renderSkeletonHive(ctx, canvasWidth, canvasHeight)`:
       - Draw at canvas center (canvasWidth/2, canvasHeight/2)
       - Draw concentric rings using `SKELETON_RINGS` radii: `ctx.arc()` with `rgba(255, 255, 255, 0.06)` stroke
       - Draw placeholder dots on each ring: `SKELETON_DOTS[i]` dots evenly spaced at `SKELETON_RINGS[i]` radius, filled with `rgba(255, 255, 255, 0.05)`, radius from `SKELETON_DOT_RADII[i]`
       - Draw center rectangle placeholder: 80x60 filled with `rgba(255, 255, 255, 0.04)`, 8px border-radius
       - All dots batched per ring (single beginPath per ring)

    Import from `./hive-types` (LayoutResult, LayoutNode, LayoutLink) and `./hive-constants` (TIER_CONFIG, NODE_SIZES, LINE_OPACITY, TIER_COLORS, SKELETON_*, VIEWPORT_PADDING).
    Import `computeFitTransform` from `./hive-layout`.

    ANTI-PATTERNS TO AVOID:
    - Do NOT use `ctx.save()`/`ctx.restore()` in tight loops -- set styles once per batch
    - Do NOT call `beginPath()`/`fill()` per individual node -- batch by tier
    - Do NOT use floating point coordinates -- `Math.round()` everything after transform
    - Do NOT re-compute the fit transform inside draw helpers -- compute once in `renderHive` and pass down
  </action>
  <verify>
    - `pnpm exec tsc --noEmit` passes
    - `renderHive` and `renderSkeletonHive` are exported
    - Drawing is batched: grep for `beginPath` should show one per tier group, not one per node
    - No `ctx.save()`/`ctx.restore()` inside loops
  </verify>
  <done>
    Renderer draws all hive elements (connections, nodes by tier, center rect, skeleton) using batched Canvas 2D calls. All coordinates integer-aligned. Supports per-tier visibility for animation integration.
  </done>
</task>

</tasks>

<verification>
- `pnpm exec tsc --noEmit` passes
- use-canvas-resize.ts handles DPR fallback chain (devicePixelContentBoxSize -> contentBoxSize -> contentRect)
- hive-renderer.ts uses batched draw calls (single beginPath/fill per tier)
- renderSkeletonHive draws concentric rings with placeholder dots
- renderHive draws connections, nodes, and center rect with fit-to-viewport transform
</verification>

<success_criteria>
- useCanvasResize hook correctly handles retina DPR scaling with Safari fallback
- renderHive draws a complete hive from LayoutResult with batched tier rendering
- renderSkeletonHive draws a loading skeleton with 3 concentric rings and placeholder dots
- Per-tier visibility support enables animation integration in Plan 03
- No performance anti-patterns (individual node draw calls, save/restore in loops)
</success_criteria>

<output>
After completion, create `.planning/phases/48-hive-foundation/48-02-SUMMARY.md`
</output>
