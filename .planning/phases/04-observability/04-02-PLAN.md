---
phase: 04-observability
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/logger.ts
autonomous: true

must_haves:
  truths:
    - "Logger outputs valid JSON in production (NODE_ENV=production)"
    - "Logger outputs human-readable pretty format in development"
    - "Logger supports child() method with persistent bindings (requestId, stage)"
    - "Logger has debug/info/warn/error levels with minimum level filtering"
    - "Logger includes timestamp in every log entry"
  artifacts:
    - path: "src/lib/logger.ts"
      provides: "Structured logger utility with JSON prod output and pretty dev output"
      exports: ["createLogger", "logger", "Logger"]
      min_lines: 50
  key_links: []
---

<objective>
Build a lightweight structured logger utility (~60 lines) that outputs JSON in production and pretty-prints in development. Supports child loggers with bindings for `requestId`, `stage`, `duration_ms`, `cost_cents`.

Purpose: OBS-03, OBS-04 — Structured logger with required fields, used by Plan 04-03 to replace all console.* calls.
Output: `src/lib/logger.ts`
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-observability/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create structured logger utility</name>
  <files>src/lib/logger.ts</files>
  <action>
    Create `src/lib/logger.ts` with the following implementation:

    ```typescript
    type LogLevel = "debug" | "info" | "warn" | "error";

    const LEVEL_VALUES: Record<LogLevel, number> = {
      debug: 10,
      info: 20,
      warn: 30,
      error: 40,
    };

    const MIN_LEVEL: LogLevel = process.env.NODE_ENV === "production" ? "info" : "debug";

    interface LogEntry {
      level: LogLevel;
      msg: string;
      timestamp: string;
      [key: string]: unknown;
    }

    function shouldLog(level: LogLevel): boolean {
      return LEVEL_VALUES[level] >= LEVEL_VALUES[MIN_LEVEL];
    }

    function formatEntry(entry: LogEntry): string {
      if (process.env.NODE_ENV === "production") {
        return JSON.stringify(entry);
      }
      // Pretty format for development
      const { level, msg, timestamp, ...rest } = entry;
      const extra = Object.keys(rest).length > 0 ? ` ${JSON.stringify(rest)}` : "";
      return `[${timestamp}] ${level.toUpperCase()} ${msg}${extra}`;
    }

    function emit(level: LogLevel, msg: string, bindings: Record<string, unknown>, data: Record<string, unknown>): void {
      if (!shouldLog(level)) return;
      const entry: LogEntry = {
        level,
        msg,
        timestamp: new Date().toISOString(),
        ...bindings,
        ...data,
      };
      const formatted = formatEntry(entry);
      if (level === "error") console.error(formatted);
      else if (level === "warn") console.warn(formatted);
      else console.log(formatted);
    }

    export interface Logger {
      debug(msg: string, data?: Record<string, unknown>): void;
      info(msg: string, data?: Record<string, unknown>): void;
      warn(msg: string, data?: Record<string, unknown>): void;
      error(msg: string, data?: Record<string, unknown>): void;
      child(bindings: Record<string, unknown>): Logger;
    }

    export function createLogger(bindings: Record<string, unknown> = {}): Logger {
      return {
        debug: (msg, data = {}) => emit("debug", msg, bindings, data),
        info: (msg, data = {}) => emit("info", msg, bindings, data),
        warn: (msg, data = {}) => emit("warn", msg, bindings, data),
        error: (msg, data = {}) => emit("error", msg, bindings, data),
        child: (extra) => createLogger({ ...bindings, ...extra }),
      };
    }

    export const logger = createLogger();
    ```

    Key design decisions:
    - `emit()` takes bindings and per-call data separately so child logger bindings persist across all calls without spread per-invocation.
    - Production output is a single `JSON.stringify(entry)` line — parseable by any log aggregator.
    - Dev output is `[timestamp] LEVEL msg {extras}` — human-readable.
    - `console.error/warn/log` is used intentionally — this file is the ONLY place in the codebase allowed to call `console.*` after migration.
    - No external dependencies. Edge-runtime compatible.
    - `logger` is a convenience export for top-level module usage. Engine modules should use `createLogger({ module: "gemini" })` or `.child()`.
  </action>
  <verify>
    - File exists: `ls src/lib/logger.ts`
    - Exports check: `grep "export" src/lib/logger.ts` shows createLogger, logger, Logger
    - TypeScript compiles: `npx tsc --noEmit src/lib/logger.ts` (or `pnpm build`)
  </verify>
  <done>
    `src/lib/logger.ts` exports `createLogger`, `logger`, and `Logger` type. Outputs JSON in production, pretty text in dev. Supports `.child()` for bindings.
  </done>
</task>

</tasks>

<verification>
1. `src/lib/logger.ts` exists with ~60-70 lines
2. Exports: `createLogger` (function), `logger` (default instance), `Logger` (interface)
3. `JSON.stringify` appears in formatEntry for production path
4. `console.error`, `console.warn`, `console.log` are only in `emit()` function
5. `child` method creates new logger with merged bindings
</verification>

<success_criteria>
- Logger outputs valid JSON when NODE_ENV=production
- Logger outputs pretty format when NODE_ENV=development
- child() method works for requestId/stage/module bindings
- debug/info/warn/error levels with minimum-level filtering
- No external dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/04-observability/04-02-SUMMARY.md`
</output>
