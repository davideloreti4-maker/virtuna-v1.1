---
phase: 04-observability
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - src/lib/engine/pipeline.ts
  - src/lib/engine/gemini.ts
  - src/lib/engine/deepseek.ts
  - src/lib/engine/rules.ts
  - src/lib/engine/ml.ts
  - src/lib/engine/calibration.ts
  - src/app/api/analyze/route.ts
  - src/app/api/admin/calibration-report/route.ts
autonomous: true

must_haves:
  truths:
    - "Zero console.log/console.error/console.warn calls remain in any src/lib/engine/ file"
    - "Every engine module uses createLogger from @/lib/logger instead of console.*"
    - "Pipeline stage completions emit Sentry breadcrumbs with category, duration_ms, and cost data"
    - "Hard failures in engine stages call Sentry.captureException with stage tags"
    - "Graceful-degradation catch blocks also call Sentry.captureException before returning fallback"
    - "requestId is generated per pipeline run and threaded through all stage loggers"
  artifacts:
    - path: "src/lib/engine/pipeline.ts"
      provides: "Pipeline with requestId generation and Sentry breadcrumbs on each stage"
      contains: "createLogger"
    - path: "src/lib/engine/gemini.ts"
      provides: "Gemini module with structured logging and Sentry exception capture"
      contains: "createLogger"
    - path: "src/lib/engine/deepseek.ts"
      provides: "DeepSeek module with structured logging and Sentry exception capture"
      contains: "createLogger"
    - path: "src/lib/engine/rules.ts"
      provides: "Rules module with structured logging replacing 7+ console.* calls"
      contains: "createLogger"
    - path: "src/lib/engine/ml.ts"
      provides: "ML module with structured logging replacing 7+ console.* calls"
      contains: "createLogger"
    - path: "src/lib/engine/calibration.ts"
      provides: "Calibration module with structured logging"
      contains: "createLogger"
  key_links:
    - from: "src/lib/engine/pipeline.ts"
      to: "@/lib/logger"
      via: "import createLogger, generate requestId, create child loggers per stage"
      pattern: "createLogger"
    - from: "src/lib/engine/gemini.ts"
      to: "@sentry/nextjs"
      via: "Sentry.captureException in catch, Sentry.addBreadcrumb on success"
      pattern: "Sentry\\.captureException|Sentry\\.addBreadcrumb"
    - from: "src/lib/engine/deepseek.ts"
      to: "@sentry/nextjs"
      via: "Sentry.captureException in catch, Sentry.addBreadcrumb on success"
      pattern: "Sentry\\.captureException|Sentry\\.addBreadcrumb"
---

<objective>
Replace all `console.*` calls in engine modules with the structured logger (from 04-02). Add Sentry breadcrumbs on stage completion and `Sentry.captureException()` in every catch block (from 04-01). Thread `requestId` through the pipeline for log correlation.

Purpose: OBS-02, OBS-04, OBS-05 — Pipeline stages emit Sentry breadcrumbs, structured logs with requestId/stage/duration_ms/cost_cents, zero console.* in engine.
Output: 8 files modified (6 engine modules + 2 API routes)
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-observability/04-RESEARCH.md
@.planning/phases/04-observability/04-01-SUMMARY.md
@.planning/phases/04-observability/04-02-SUMMARY.md
@src/lib/logger.ts
@src/lib/engine/pipeline.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Instrument pipeline.ts with requestId, Sentry breadcrumbs, and structured logging</name>
  <files>src/lib/engine/pipeline.ts</files>
  <action>
    1. Add imports at top of `pipeline.ts`:
       ```typescript
       import * as Sentry from "@sentry/nextjs";
       import { nanoid } from "nanoid";
       import { createLogger } from "@/lib/logger";
       ```

    2. Modify `runPredictionPipeline` signature to accept an optional options object:
       ```typescript
       export async function runPredictionPipeline(
         input: AnalysisInput,
         opts?: { requestId?: string }
       ): Promise<PipelineResult> {
       ```

    3. At the top of the function body, create a requestId and logger:
       ```typescript
       const requestId = opts?.requestId ?? nanoid(12);
       const log = createLogger({ requestId, module: "pipeline" });
       log.info("Pipeline started", { input_mode: input.input_mode });
       ```

    4. Add `requestId` to PipelineResult interface so downstream consumers (analyze/route.ts) have access:
       ```typescript
       export interface PipelineResult {
         // ... existing fields ...
         requestId: string;
       }
       ```
       And include it in the return object.

    5. After each Wave completes, add a Sentry breadcrumb:
       ```typescript
       // After Wave 1:
       Sentry.addBreadcrumb({
         category: "engine.pipeline",
         message: "Wave 1 complete",
         level: "info",
         data: { requestId, stages: ["gemini", "audio", "creator", "rules"] },
       });

       // After Wave 2:
       Sentry.addBreadcrumb({
         category: "engine.pipeline",
         message: "Wave 2 complete",
         level: "info",
         data: { requestId, stages: ["deepseek", "trends"] },
       });
       ```

    6. In each non-critical catch block (creator, rules, trends, deepseek), add `Sentry.captureException`:
       ```typescript
       } catch (error) {
         Sentry.captureException(error, {
           tags: { stage: "creator_context", requestId },
         });
         warnings.push(...);
         // ... existing fallback logic
       }
       ```
       Do this for all 4 non-critical stage catch blocks.

    7. At the end before return, log pipeline completion:
       ```typescript
       log.info("Pipeline complete", {
         stage: "pipeline",
         duration_ms: total_duration_ms,
         warnings_count: warnings.length,
       });
       ```

    8. Do NOT change the critical Gemini catch block behavior (it re-throws). But add `Sentry.captureException` before re-throw:
       ```typescript
       } catch (error) {
         Sentry.captureException(error, {
           tags: { stage: "gemini_analysis", requestId },
         });
         throw new Error(...);
       }
       ```
  </action>
  <verify>
    - `grep "console\." src/lib/engine/pipeline.ts` returns nothing
    - `grep "Sentry.captureException" src/lib/engine/pipeline.ts` returns 5+ matches (gemini, creator, rules, deepseek, trends)
    - `grep "Sentry.addBreadcrumb" src/lib/engine/pipeline.ts` returns 2 matches (wave 1, wave 2)
    - `grep "requestId" src/lib/engine/pipeline.ts` confirms threading
  </verify>
  <done>
    pipeline.ts generates requestId per run, logs with structured logger, emits Sentry breadcrumbs after each wave, captures exceptions in all catch blocks. No console.* calls remain.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace console.* in all engine modules with structured logger + Sentry</name>
  <files>
    src/lib/engine/gemini.ts
    src/lib/engine/deepseek.ts
    src/lib/engine/rules.ts
    src/lib/engine/ml.ts
    src/lib/engine/calibration.ts
    src/app/api/analyze/route.ts
    src/app/api/admin/calibration-report/route.ts
  </files>
  <action>
    For EACH file below, add imports and replace every `console.*` call:

    **Common pattern for each engine module:**
    ```typescript
    import * as Sentry from "@sentry/nextjs";
    import { createLogger } from "@/lib/logger";
    const log = createLogger({ module: "<module_name>" });
    ```

    **`src/lib/engine/rules.ts` (8 calls to replace):**
    - Line ~114: `console.error("Failed to load rules:", error)` → `log.error("Failed to load rules", { error: error instanceof Error ? error.message : String(error) }); Sentry.captureException(error, { tags: { stage: "rule_loading" } });`
    - Line ~166: `console.debug(...)` → `log.debug("Unknown regex pattern", { pattern })`
    - Line ~186: `console.warn(...)` → `log.warn("Skipping semantic rule", { rule_name: ... })`
    - Line ~230: `console.warn(...)` → `log.warn("Semantic eval response validation failed", { ... })`
    - Line ~243: `console.log(...)` → `log.info("Semantic evaluation started", { rule_count: evaluableRules.length })`
    - Line ~252: `console.warn(...)` → `log.warn("Semantic evaluation failed", { ... }); Sentry.captureException(error, { tags: { stage: "semantic_eval" } });`
    - Line ~304: `console.debug(...)` → `log.debug("Regex rule has no pattern", { rule_name: rule.name })`
    - Line ~322: `console.debug(...)` → `log.debug("Semantic eval returned unknown rule", { ... })`

    **`src/lib/engine/gemini.ts` (2 calls to replace):**
    - Line ~316: `console.warn("...cost exceeds soft cap")` → `log.warn("Text analysis cost exceeds soft cap", { cost_cents: ..., soft_cap: ... })`
    - Line ~436: `console.warn("...cost exceeds soft cap")` → `log.warn("Video analysis cost exceeds soft cap", { cost_cents: ..., soft_cap: ... })`
    - Also add `Sentry.addBreadcrumb` at the end of successful analysis with `{ category: "engine.gemini", data: { duration_ms, cost_cents, model } }`.
    - Add `Sentry.captureException` in any existing catch blocks.

    **`src/lib/engine/deepseek.ts` (5 calls to replace):**
    - Line ~128: `console.warn("Circuit breaker OPEN")` → `log.warn("Circuit breaker OPEN", { ... })`
    - Line ~415: `console.warn("...cost exceeds soft cap")` → `log.warn("Reasoning cost exceeds soft cap", { cost_cents: ..., soft_cap: ... })`
    - Line ~444: `console.error("DeepSeek failed after attempts")` → `log.error("DeepSeek failed after retries", { attempts: MAX_RETRIES + 1 }); Sentry.captureException(error, { tags: { stage: "deepseek_reasoning" } });`
    - Line ~449: `console.warn("Falling back to Gemini")` → `log.warn("Falling back to Gemini for reasoning")`
    - Line ~500: `console.log("DeepSeek->Gemini fallback complete")` → `log.info("DeepSeek->Gemini fallback complete", { duration_ms, cost_cents })`
    - Add `Sentry.addBreadcrumb` at end of successful reasoning with `{ category: "engine.deepseek", data: { duration_ms, cost_cents, model } }`.

    **`src/lib/engine/calibration.ts` (1 call to replace):**
    - Line ~79: `console.error("Failed to fetch outcome pairs")` → `log.error("Failed to fetch outcome pairs", { error: ... }); Sentry.captureException(error, { tags: { stage: "calibration" } });`

    **`src/lib/engine/ml.ts` (7 calls to replace):**
    - Line ~266: `console.log(...)` tier metrics → `log.info("Training tier metrics", { setName, tier: c + 1, precision, recall, f1 })`
    - Line ~321: `console.log(...)` class weights → `log.info("Class weights computed", { weights: weightLog })`
    - Line ~395: `console.log(...)` epoch progress → `log.debug("Training epoch", { epoch: epoch + 1, total: EPOCHS, ... })`
    - Line ~405: `console.log(...)` final accuracy → `log.info("Training complete", { train_accuracy, test_accuracy })`
    - Line ~435: `console.error("Failed to upload weights")` → `log.error("Failed to upload weights", { error: ... }); Sentry.captureException(uploadError, { tags: { stage: "ml_upload" } });`
    - Line ~438: `console.log("Model weights saved")` → `log.info("Model weights saved", { bucket: STORAGE_BUCKET, path: STORAGE_PATH })`
    - Line ~474: `console.error("Failed to load ML model weights")` → `log.error("Failed to load ML model weights"); Sentry.captureException(error, { tags: { stage: "ml_load" } });`

    **`src/app/api/analyze/route.ts` (1 call to replace):**
    - Line ~254: `console.error("[analyze] Request error:", error)` → `import { createLogger } from "@/lib/logger"; import * as Sentry from "@sentry/nextjs";` at top. Replace with: `const log = createLogger({ module: "analyze" }); ... log.error("Request error", { error: error instanceof Error ? error.message : String(error) }); Sentry.captureException(error, { tags: { stage: "analyze_route" } });`
    - Also generate requestId at the start of the POST handler and pass to `runPredictionPipeline(validated, { requestId })`.

    **`src/app/api/admin/calibration-report/route.ts` (1 call to replace):**
    - Line ~41: `console.error("[calibration-report]...")` → Add imports, replace with `log.error("Failed to generate report", { error: ... }); Sentry.captureException(error, { tags: { stage: "calibration_report" } });`

    **IMPORTANT rules for replacement:**
    - Never log `content_text`, user IDs, or API keys in structured logs. Only log: requestId, stage, duration_ms, cost_cents, model, error messages.
    - For `error` objects, log `error.message` as a string, never the full Error object (it doesn't serialize to JSON).
    - Use `Sentry.captureException` in catch blocks that handle errors gracefully (return fallback). Use it BEFORE the fallback return.
    - For catch blocks that re-throw, still add `Sentry.captureException` before the re-throw.
  </action>
  <verify>
    - `grep -r "console\.\(log\|error\|warn\)" src/lib/engine/` returns ZERO results
    - `grep -r "console\.\(log\|error\|warn\)" src/app/api/analyze/route.ts src/app/api/admin/calibration-report/route.ts` returns ZERO results
    - `grep -r "createLogger" src/lib/engine/` returns matches in all 6 engine files (pipeline, gemini, deepseek, rules, ml, calibration)
    - `grep -r "Sentry.captureException" src/lib/engine/` returns multiple matches
    - `pnpm build` succeeds
  </verify>
  <done>
    All 25+ console.* calls replaced with structured logger. Sentry.captureException added in every catch block. requestId threaded from analyze route through pipeline to all stage loggers. Zero console.* remains in src/lib/engine/ or the two API routes.
  </done>
</task>

</tasks>

<verification>
1. `grep -r "console\.\(log\|error\|warn\)" src/lib/engine/` — ZERO results
2. `grep -r "console\.\(log\|error\|warn\)" src/app/api/analyze/route.ts src/app/api/admin/calibration-report/route.ts` — ZERO results
3. `grep -r "createLogger" src/lib/engine/` — matches in pipeline, gemini, deepseek, rules, ml, calibration
4. `grep -r "Sentry.captureException" src/lib/engine/` — matches in all files with catch blocks
5. `grep -r "Sentry.addBreadcrumb" src/lib/engine/` — matches in pipeline, gemini, deepseek
6. `grep "requestId" src/lib/engine/pipeline.ts src/app/api/analyze/route.ts` — both files thread requestId
7. `pnpm build` exits 0
</verification>

<success_criteria>
- Zero console.* in src/lib/engine/ (OBS-05)
- Every catch block has Sentry.captureException (OBS-02)
- Pipeline and major stages emit Sentry breadcrumbs (OBS-02)
- All log calls include structured fields: requestId, stage/module, duration_ms, cost_cents where applicable (OBS-04)
- requestId generated per pipeline run and threaded through (OBS-04)
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/04-observability/04-03-SUMMARY.md`
</output>
