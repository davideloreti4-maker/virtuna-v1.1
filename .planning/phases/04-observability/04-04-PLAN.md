---
phase: 04-observability
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/admin/costs/route.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/admin/costs returns JSON array of { date, model, total_cost_cents } rows"
    - "Results are grouped by day and model combination"
    - "Endpoint is protected by CRON_SECRET Bearer token auth"
    - "Default query returns last 30 days; ?days=N overrides"
    - "NULL cost_cents rows are handled (COALESCE to 0 or filtered)"
  artifacts:
    - path: "src/app/api/admin/costs/route.ts"
      provides: "Admin cost aggregation endpoint"
      exports: ["GET"]
      min_lines: 30
  key_links:
    - from: "src/app/api/admin/costs/route.ts"
      to: "analysis_results table"
      via: "Supabase client-side aggregation query"
      pattern: "from.*analysis_results"
    - from: "src/app/api/admin/costs/route.ts"
      to: "@/lib/cron-auth"
      via: "verifyCronAuth for Bearer token protection"
      pattern: "verifyCronAuth"
---

<objective>
Build the `/api/admin/costs` GET endpoint that aggregates `cost_cents` from `analysis_results` grouped by day and model combination. Uses existing Supabase client-side query (no RPC/migration needed). Protected by CRON_SECRET auth.

Purpose: OBS-06 — Admin cost aggregation endpoint for monitoring daily spend by model.
Output: `src/app/api/admin/costs/route.ts`
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-observability/04-RESEARCH.md
@src/lib/cron-auth.ts
@src/app/api/admin/calibration-report/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create /api/admin/costs aggregation endpoint</name>
  <files>src/app/api/admin/costs/route.ts</files>
  <action>
    Create `src/app/api/admin/costs/route.ts` following the exact pattern from the existing `calibration-report/route.ts`:

    ```typescript
    import { NextResponse } from "next/server";
    import { verifyCronAuth } from "@/lib/cron-auth";
    import { createServiceClient } from "@/lib/supabase/service";

    /**
     * GET /api/admin/costs
     *
     * Returns daily cost aggregates grouped by model combination.
     * Protected by CRON_SECRET Bearer token auth.
     *
     * Query params:
     *   ?days=30  — look back N days (default: 30)
     *
     * Response: JSON array of { date, model, total_cost_cents }
     *
     * Uses client-side aggregation (no RPC needed):
     * - Fetches rows from analysis_results for the date range
     * - Groups by date + gemini_model in JS
     * - Returns sorted by date DESC, model ASC
     *
     * Note: cost_cents is the total pipeline cost per analysis (Gemini + DeepSeek combined).
     * Grouped by gemini_model since that's always present (deepseek_model may be null).
     */
    export async function GET(request: Request) {
      const authError = verifyCronAuth(request);
      if (authError) return authError;

      try {
        const url = new URL(request.url);
        const daysParam = url.searchParams.get("days");
        const days = daysParam ? parseInt(daysParam, 10) : 30;

        // Validate days param
        if (isNaN(days) || days <= 0 || days > 365) {
          return NextResponse.json(
            { error: "Invalid 'days' parameter — must be 1-365" },
            { status: 400 }
          );
        }

        const supabase = createServiceClient();

        // Calculate date cutoff
        const cutoff = new Date();
        cutoff.setDate(cutoff.getDate() - days);
        const cutoffISO = cutoff.toISOString();

        // Fetch raw data — select only needed columns
        const { data, error } = await supabase
          .from("analysis_results")
          .select("created_at, cost_cents, gemini_model")
          .gte("created_at", cutoffISO)
          .is("deleted_at", null)
          .order("created_at", { ascending: false });

        if (error) {
          return NextResponse.json({ error: error.message }, { status: 500 });
        }

        // Client-side aggregation: group by (date, gemini_model)
        const aggregates = new Map<string, number>();

        for (const row of data ?? []) {
          const date = row.created_at?.split("T")[0] ?? "unknown";
          const model = row.gemini_model ?? "unknown";
          const cost = row.cost_cents ?? 0; // COALESCE null to 0
          const key = `${date}|${model}`;
          aggregates.set(key, (aggregates.get(key) ?? 0) + cost);
        }

        // Convert to sorted array
        const result = Array.from(aggregates.entries())
          .map(([key, total_cost_cents]) => {
            const [date, model] = key.split("|");
            return { date, model, total_cost_cents: Math.round(total_cost_cents) };
          })
          .sort((a, b) => {
            // Sort by date DESC, then model ASC
            const dateCompare = (b.date ?? "").localeCompare(a.date ?? "");
            if (dateCompare !== 0) return dateCompare;
            return (a.model ?? "").localeCompare(b.model ?? "");
          });

        return NextResponse.json(result);
      } catch (error) {
        return NextResponse.json(
          { error: "Internal server error" },
          { status: 500 }
        );
      }
    }
    ```

    Design decisions:
    - **Client-side aggregation** (not SQL RPC): Avoids needing a Supabase migration to create an SQL function. For the expected data volume (<10k rows per 30 days), in-memory aggregation is fast enough.
    - **Group by gemini_model**: Per planning context decision (b) — show total pipeline cost grouped by model combination. `gemini_model` is always present; `deepseek_model` may be null (Gemini fallback). Grouping by gemini_model gives the most useful view.
    - **COALESCE cost_cents to 0**: Handles pre-v2 rows where cost_cents may be NULL (Pitfall 6 from research).
    - **CRON_SECRET auth**: Same pattern as calibration-report endpoint — admin endpoints are not user-facing.
    - **365-day max**: Prevents abuse/OOM from requesting years of data.

    2. Verify build: `pnpm build`
  </action>
  <verify>
    - File exists: `ls src/app/api/admin/costs/route.ts`
    - Exports GET: `grep "export async function GET" src/app/api/admin/costs/route.ts`
    - Uses verifyCronAuth: `grep "verifyCronAuth" src/app/api/admin/costs/route.ts`
    - Queries analysis_results: `grep "analysis_results" src/app/api/admin/costs/route.ts`
    - `pnpm build` exits 0
  </verify>
  <done>
    GET /api/admin/costs returns JSON array of { date, model, total_cost_cents } rows grouped by day and gemini_model, protected by CRON_SECRET auth, defaulting to last 30 days.
  </done>
</task>

</tasks>

<verification>
1. `src/app/api/admin/costs/route.ts` exists and exports GET handler
2. Protected by verifyCronAuth (same as calibration-report)
3. Queries analysis_results with date filter and deleted_at IS NULL
4. Groups by date + gemini_model, sums cost_cents with null handling
5. Returns sorted array of { date, model, total_cost_cents }
6. Accepts ?days=N query param (default 30, max 365)
7. `pnpm build` succeeds
</verification>

<success_criteria>
- GET /api/admin/costs returns JSON array grouped by day/model (OBS-06)
- Endpoint protected by CRON_SECRET (same auth pattern as calibration-report)
- NULL cost_cents handled via COALESCE to 0
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/04-observability/04-04-SUMMARY.md`
</output>
