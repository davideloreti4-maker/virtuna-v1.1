---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/supabase/middleware.ts
  - src/middleware.ts
  - src/components/app/auth-guard.tsx
  - src/components/app/app-shell.tsx
  - src/app/(onboarding)/layout.tsx
  - src/app/(onboarding)/login/page.tsx
  - src/app/(onboarding)/login/actions.ts
  - src/app/(onboarding)/signup/page.tsx
  - src/app/(onboarding)/signup/actions.ts
  - src/app/auth/callback/route.ts
autonomous: true

must_haves:
  truths:
    - "Unauthenticated user visiting /dashboard is redirected to /login"
    - "Authenticated user stays logged in across browser sessions"
    - "User can sign up with email/password and is redirected to /dashboard"
    - "User can sign in with email/password and is redirected to /dashboard"
    - "User can sign in with Google OAuth and is redirected to /dashboard"
    - "Deep link is preserved: visiting /brand-deals while unauthenticated redirects to /login, then back to /brand-deals after auth"
    - "Full-page skeleton (sidebar + content area) shows while auth state is checked, not a spinner or blank page"
  artifacts:
    - path: "src/lib/supabase/middleware.ts"
      provides: "Auth redirect enforcement"
      contains: "redirect.*login"
    - path: "src/app/(onboarding)/login/page.tsx"
      provides: "Login page with email/password form and Google OAuth button"
      min_lines: 40
    - path: "src/app/(onboarding)/signup/page.tsx"
      provides: "Signup page with email/password form and Google OAuth button"
      min_lines: 40
    - path: "src/app/(onboarding)/login/actions.ts"
      provides: "Server actions for email/password sign-in"
      exports: ["login"]
    - path: "src/app/(onboarding)/signup/actions.ts"
      provides: "Server actions for email/password sign-up"
      exports: ["signup"]
    - path: "src/app/auth/callback/route.ts"
      provides: "OAuth PKCE code exchange handler"
      exports: ["GET"]
    - path: "src/app/(onboarding)/layout.tsx"
      provides: "Minimal centered layout for auth pages (no sidebar)"
      min_lines: 15
  key_links:
    - from: "src/lib/supabase/middleware.ts"
      to: "supabase.auth.getUser()"
      via: "Server-side auth check before page render"
      pattern: "getUser.*redirect"
    - from: "src/app/(onboarding)/login/actions.ts"
      to: "supabase.auth.signInWithPassword()"
      via: "Server action form submission"
      pattern: "signInWithPassword"
    - from: "src/app/auth/callback/route.ts"
      to: "supabase.auth.exchangeCodeForSession()"
      via: "OAuth PKCE callback"
      pattern: "exchangeCodeForSession"
---

<objective>
Replace the mock AuthGuard (350ms setTimeout that always returns "logged in") with real Supabase authentication. Wire middleware to enforce auth redirects server-side, create login and signup pages with email/password and Google OAuth, and add the OAuth callback route handler.

Purpose: This is the critical foundation for the entire MVP. Every downstream feature (onboarding, payments, referrals) requires real authentication. Without this, the app is a demo, not a product.

Output: Working auth flow -- unauthenticated users redirect to /login, authenticated users access (app) routes, sessions persist across browser restarts.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-CONTEXT.md

@src/lib/supabase/middleware.ts
@src/lib/supabase/client.ts
@src/lib/supabase/server.ts
@src/middleware.ts
@src/components/app/auth-guard.tsx
@src/components/app/app-shell.tsx
@src/app/(app)/layout.tsx
@src/app/(marketing)/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire middleware auth redirects + create OAuth callback route</name>
  <files>
    src/lib/supabase/middleware.ts
    src/middleware.ts
    src/app/auth/callback/route.ts
  </files>
  <action>
    **Middleware auth enforcement (src/lib/supabase/middleware.ts):**
    Update the existing `updateSession()` function. After calling `supabase.auth.getUser()`, capture the result. Add redirect logic:
    - If user is NOT authenticated AND path starts with known protected prefixes (`/dashboard`, `/brand-deals`, `/settings`, or any (app) route), redirect to `/login?next={encodeURIComponent(request.nextUrl.pathname + request.nextUrl.search)}`. The `?next=` param preserves the deep link.
    - If user IS authenticated AND path is `/login` or `/signup`, redirect to `/dashboard` (prevent authenticated users from seeing auth pages).
    - Public routes that skip auth checks: `/`, `/coming-soon`, `/showcase`, `/primitives-showcase`, `/viral-score-test`, `/viral-results-showcase`, `/viz-test`, `/auth/callback`, `/api/`, any static asset.
    - Use `NextResponse.redirect(new URL('/login', request.url))` pattern.
    - IMPORTANT: After calling `setAll` in the cookies handler, must re-create `NextResponse.next({ request })` (this is already done correctly in existing code -- preserve that pattern).

    **Root middleware (src/middleware.ts):**
    Keep existing matcher (already correct -- matches all non-static routes). No changes needed if already calling `updateSession()`. Verify it passes through correctly.

    **OAuth callback route (src/app/auth/callback/route.ts):**
    Create a GET route handler for the Supabase PKCE OAuth flow:
    ```
    1. Extract `code` and `next` from searchParams
    2. If `code` exists, create Supabase server client from cookies
    3. Call `supabase.auth.exchangeCodeForSession(code)`
    4. Redirect to `next` param (default: '/dashboard')
    5. If no code or exchange fails, redirect to '/login?error=auth_callback_failed'
    ```
    Use `createServerClient` from `@supabase/ssr` with cookie handling via `request.cookies` and `response.cookies` (not the `cookies()` function -- this is a Route Handler, not a Server Component). Follow the same pattern as middleware for cookie handling.
  </action>
  <verify>
    - `pnpm build` succeeds (no TypeScript errors in new/modified files)
    - Manual check: middleware.ts imports and calls updateSession correctly
    - Manual check: auth/callback/route.ts exports a GET function that handles code exchange
  </verify>
  <done>
    Middleware redirects unauthenticated users from protected routes to /login with ?next= param. Authenticated users on /login or /signup are redirected to /dashboard. OAuth callback route exchanges PKCE code for session.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create auth pages (login + signup) with email/password and Google OAuth</name>
  <files>
    src/app/(onboarding)/layout.tsx
    src/app/(onboarding)/login/page.tsx
    src/app/(onboarding)/login/actions.ts
    src/app/(onboarding)/signup/page.tsx
    src/app/(onboarding)/signup/actions.ts
  </files>
  <action>
    **Onboarding layout (src/app/(onboarding)/layout.tsx):**
    Create a root layout for the (onboarding) route group. This is a separate route group with its own `<html>` element (matching the existing (app) and (marketing) layouts pattern). Use Inter font (same config as other layouts). Minimal centered layout -- no sidebar, no header. Dark background (`bg-background`). Center children vertically and horizontally with flexbox. Include the Virtuna "V" logo at the top (same SVG from sidebar.tsx).

    **Login page (src/app/(onboarding)/login/page.tsx):**
    Server component page with metadata `{ title: "Sign In | Virtuna" }`. Renders a client component `LoginForm`. The form includes:
    - Email input (type="email", required)
    - Password input (type="password", required)
    - Submit button ("Sign in") -- uses form action from actions.ts
    - Google OAuth button ("Continue with Google") -- client-side, calls `supabase.auth.signInWithOAuth({ provider: 'google', options: { redirectTo: '{origin}/auth/callback?next={nextParam}' } })`
    - Link to /signup ("Don't have an account? Sign up")
    - Error display: read `?error=` and `?expired=true` from searchParams, show relevant message
    - Read `?next=` from searchParams and pass to form action as hidden input

    Style with Raycast design language: dark bg, white/[0.06] borders on inputs, 8px radius on inputs/buttons, coral primary button, Inter font. Card container with 12px radius, bg-transparent, border white/[0.06].

    **Login server action (src/app/(onboarding)/login/actions.ts):**
    `'use server'` directive. Export async function `login(formData: FormData)`. Extract email, password, and next (redirect target) from formData. Create Supabase server client, call `signInWithPassword({ email, password })`. If error, `redirect('/login?error=' + encodeURIComponent(error.message))`. If success, `redirect(next || '/dashboard')`. Use `redirect()` from `next/navigation`.

    **Signup page (src/app/(onboarding)/signup/page.tsx):**
    Same structure as login but for registration. Metadata `{ title: "Sign Up | Virtuna" }`. Form fields: email, password, confirm password (client-side validation: passwords match). Submit calls signup action. Google OAuth button (same as login). Link to /login ("Already have an account? Sign in").

    **Signup server action (src/app/(onboarding)/signup/actions.ts):**
    `'use server'` directive. Export async function `signup(formData: FormData)`. Extract email, password. Create Supabase server client, call `signUp({ email, password })`. If error, `redirect('/signup?error=' + encodeURIComponent(error.message))`. If success, `redirect('/login?message=Check your email to confirm your account')`. Note: redirect to login with success message, NOT directly to dashboard (email confirmation needed first).

    **IMPORTANT design constraints (per locked decisions):**
    - Separate routes for login and signup (NOT same page with toggle)
    - Both pages offer Email/password + Google OAuth
    - Match Raycast design language (dark, minimal, coral accents)
  </action>
  <verify>
    - `pnpm build` succeeds with no errors
    - `/login` route resolves (check with `curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/login`)
    - `/signup` route resolves
    - Login form has email, password fields and Google button
    - Signup form has email, password, confirm password fields and Google button
  </verify>
  <done>
    Login and signup pages render at /login and /signup. Email/password auth uses server actions. Google OAuth initiates PKCE flow. Both pages match Raycast design language. Deep link ?next= param is preserved through auth flow.
  </done>
</task>

<task type="auto">
  <name>Task 3: Replace mock AuthGuard with real session check in AppShell</name>
  <files>
    src/components/app/auth-guard.tsx
    src/components/app/app-shell.tsx
  </files>
  <action>
    **Replace AuthGuard (src/components/app/auth-guard.tsx):**
    The middleware now handles redirecting unauthenticated users server-side, so the AuthGuard no longer needs to verify authentication. Replace the mock 350ms setTimeout with a real Supabase session check that shows the full-page skeleton (per locked decision: "full-page skeleton with sidebar + content area layout, no flash of content, no bare spinner").

    New implementation:
    - Keep `"use client"` directive
    - Use `createClient()` from `@/lib/supabase/client` (browser client)
    - On mount, call `supabase.auth.getSession()` to check for existing session
    - Also subscribe to `supabase.auth.onAuthStateChange()` for real-time auth events
    - While checking: show `AppShellSkeleton` (keep existing skeleton component)
    - If session exists: render children
    - If no session (edge case -- middleware should have caught this but handle gracefully): redirect to `/login` using `router.push('/login')`
    - On auth state change to `SIGNED_OUT`: redirect to `/` (landing page -- per discretion recommendation)
    - Clean up subscription on unmount

    Keep the existing `AppShellSkeleton` component (it already matches the full-page skeleton requirement with sidebar + content area).

    **Update AppShell (src/components/app/app-shell.tsx):**
    No structural changes needed -- it already wraps children in AuthGuard. Verify it still works with the updated AuthGuard. The middleware is the primary auth enforcement; AuthGuard is the client-side safety net and loading state handler.
  </action>
  <verify>
    - `pnpm build` succeeds
    - AuthGuard no longer has `setTimeout` or `350`
    - AuthGuard imports from `@/lib/supabase/client`
    - AuthGuard calls `supabase.auth.getSession()` and `onAuthStateChange()`
    - AppShell still wraps children in AuthGuard
  </verify>
  <done>
    AuthGuard checks real Supabase session on the client. Shows full-page skeleton during check. Middleware handles the redirect enforcement server-side. No more fake 350ms delay. Session-expired users are silently redirected to login.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` completes without errors
2. Visit /dashboard without auth cookie -> middleware redirects to /login
3. Visit /login with auth cookie -> middleware redirects to /dashboard
4. Visit /brand-deals without auth -> redirects to /login?next=/brand-deals
5. After login, redirects back to /brand-deals (deep link preserved)
6. Login page renders with email/password form and Google OAuth button
7. Signup page renders with email/password form, confirm password, and Google OAuth button
8. /auth/callback handles OAuth code exchange
9. AppShell shows skeleton during auth check, then renders app
10. No reference to mock 350ms timeout remains in auth-guard.tsx
</verification>

<success_criteria>
- All (app) routes are protected by real Supabase middleware auth
- Login and signup pages exist at /login and /signup with email/password and Google OAuth
- OAuth callback route properly exchanges PKCE codes for sessions
- Deep links are preserved through the auth flow via ?next= param
- AuthGuard shows real skeleton during actual session check
- Session expired: silent redirect to /login
- `pnpm build` passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
