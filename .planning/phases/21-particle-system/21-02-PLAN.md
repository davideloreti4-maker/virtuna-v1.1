---
phase: 21-particle-system
plan: 02
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - src/components/visualization/particle-system.tsx
  - src/components/visualization/index.ts
autonomous: true

must_haves:
  truths:
    - "Ambient particles flow continuously around the orb in idle state"
    - "Particles rush toward the orb when processing begins"
    - "Idle state is captivating enough to hook users before any interaction"
    - "Particle system uses requestAnimationFrame for smooth animation loop"
    - "Particle count is configurable for performance optimization"
  artifacts:
    - path: "src/components/visualization/particle-system.tsx"
      provides: "Canvas-based particle system with idle/processing states"
      exports: ["ParticleSystem"]
      min_lines: 150
    - path: "src/components/visualization/index.ts"
      provides: "Barrel export for visualization components"
      exports: ["ParticleSystem"]
  key_links:
    - from: "src/components/visualization/particle-system.tsx"
      to: "src/components/visualization/particle-types.ts"
      via: "Particle and ParticleSystemProps imports"
      pattern: "import.*Particle.*from.*particle-types"
    - from: "src/components/visualization/particle-system.tsx"
      to: "src/lib/particle-utils.ts"
      via: "Utility function imports"
      pattern: "import.*createParticlePool.*from.*particle-utils"
    - from: "src/components/visualization/particle-system.tsx"
      to: "simplex-noise"
      via: "Noise function for organic movement"
      pattern: "import.*createNoise2D.*from.*simplex-noise"
---

<objective>
Build the ParticleSystem component â€” a Canvas 2D particle system that creates ambient flowing particles around the orb in idle state and rushes them toward the center when processing begins.

Purpose: Deliver the "captivating idle hook" (VIZ-08) and the dramatic "rush toward orb" effect (VIZ-04) that makes the visualization mesmerizing before and during user interaction.

Output: Fully functional ParticleSystem component ready for integration with the orb visualization.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-particle-system/21-RESEARCH.md
@.planning/phases/21-particle-system/21-01-SUMMARY.md

Reference for established Canvas patterns:
@src/components/app/network-visualization.tsx

Dependencies created in 21-01:
@src/components/visualization/particle-types.ts
@src/lib/particle-utils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ParticleSystem component</name>
  <files>src/components/visualization/particle-system.tsx</files>
  <action>
Create the main ParticleSystem component following the NetworkVisualization pattern:

```typescript
// src/components/visualization/particle-system.tsx
"use client";

import { useEffect, useRef, useState, useCallback } from "react";
import { createNoise2D } from "simplex-noise";
import { cn } from "@/lib/utils";
import type { Particle, ParticleSystemProps, ParticleState } from "./particle-types";
import {
  createParticlePool,
  resetParticle,
  easeInOutCubic,
  clampVelocity,
  getDefaultParticleCount,
} from "@/lib/particle-utils";

// Visual constants
const PARTICLE_COLOR = "#72C5E0"; // Cyan from v1.4 palette
const PARTICLE_RADIUS = 2;
const ORB_RADIUS = 80; // Approximate orb size for spawn calculations

// Physics constants
const IDLE_FLOW_SCALE = 0.003; // Lower = larger flow patterns
const IDLE_FLOW_SPEED = 0.0003; // Slower = more hypnotic
const IDLE_DAMPING = 0.97;
const PROCESSING_ATTRACTION = 0.03;
const PROCESSING_MAX_SPEED = 8;
const STATE_TRANSITION_MS = 400;

/**
 * ParticleSystem - Canvas-based ambient particle flow
 *
 * Features:
 * - Organic flowing motion in idle state (simplex noise)
 * - Rush toward center in processing state
 * - Smooth eased transitions between states
 * - Object pooling for 60fps performance
 * - Configurable particle count
 * - Respects prefers-reduced-motion
 * - High-DPI canvas rendering
 */
export function ParticleSystem({
  state,
  centerX,
  centerY,
  particleCount,
  className,
}: ParticleSystemProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const particlesRef = useRef<Particle[]>([]);
  const animationIdRef = useRef<number>(0);
  const noise2DRef = useRef<ReturnType<typeof createNoise2D> | null>(null);

  // Track state transitions for smooth easing
  const stateRef = useRef<ParticleState>(state);
  const transitionStartRef = useRef<number>(0);
  const transitionProgressRef = useRef<number>(state === 'processing' ? 1 : 0);

  // Reduced motion preference
  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);

  // Initialize noise generator once
  useEffect(() => {
    noise2DRef.current = createNoise2D();
  }, []);

  // Handle reduced motion preference
  useEffect(() => {
    const mediaQuery = window.matchMedia("(prefers-reduced-motion: reduce)");
    setPrefersReducedMotion(mediaQuery.matches);

    const handler = (e: MediaQueryListEvent) => setPrefersReducedMotion(e.matches);
    mediaQuery.addEventListener("change", handler);
    return () => mediaQuery.removeEventListener("change", handler);
  }, []);

  // Handle state transitions
  useEffect(() => {
    if (stateRef.current !== state) {
      stateRef.current = state;
      transitionStartRef.current = performance.now();
    }
  }, [state]);

  // Setup canvas with High-DPI support
  const setupCanvas = useCallback(() => {
    const container = containerRef.current;
    const canvas = canvasRef.current;
    if (!container || !canvas) return null;

    const ctx = canvas.getContext("2d");
    if (!ctx) return null;

    const dpr = window.devicePixelRatio || 1;
    const rect = container.getBoundingClientRect();

    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    canvas.style.width = `${rect.width}px`;
    canvas.style.height = `${rect.height}px`;
    ctx.scale(dpr, dpr);

    return { ctx, width: rect.width, height: rect.height };
  }, []);

  // Initialize particles
  const initParticles = useCallback((count: number, width: number, height: number) => {
    const pool = createParticlePool(count);
    const cx = centerX || width / 2;
    const cy = centerY || height / 2;

    // Activate and position all particles
    pool.forEach((p) => {
      resetParticle(p, cx, cy, ORB_RADIUS);
    });

    particlesRef.current = pool;
  }, [centerX, centerY]);

  // Update particle based on current state
  const updateParticle = useCallback((
    p: Particle,
    progress: number, // 0 = idle, 1 = processing
    cx: number,
    cy: number,
    time: number,
    width: number,
    height: number
  ) => {
    const noise2D = noise2DRef.current;
    if (!noise2D || !p.active) return;

    // Idle behavior: organic flowing motion
    const idleAngle = noise2D(
      p.x * IDLE_FLOW_SCALE + p.noiseOffset,
      p.y * IDLE_FLOW_SCALE + time * IDLE_FLOW_SPEED
    ) * Math.PI * 2;

    const idleVx = Math.cos(idleAngle) * 0.3;
    const idleVy = Math.sin(idleAngle) * 0.3;

    // Processing behavior: rush toward center
    const dx = cx - p.x;
    const dy = cy - p.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    let processVx = 0;
    let processVy = 0;
    if (dist > 5) {
      const force = PROCESSING_ATTRACTION * (1 + 100 / dist); // Stronger near center
      processVx = (dx / dist) * force * 10;
      processVy = (dy / dist) * force * 10;
    }

    // Blend between idle and processing based on eased progress
    const easedProgress = easeInOutCubic(progress);
    p.vx += idleVx * (1 - easedProgress) + processVx * easedProgress;
    p.vy += idleVy * (1 - easedProgress) + processVy * easedProgress;

    // Apply damping (less during processing for dramatic rush)
    const damping = progress > 0.5 ? 0.99 : IDLE_DAMPING;
    p.vx *= damping;
    p.vy *= damping;

    // Clamp velocity
    const clamped = clampVelocity(p.vx, p.vy, PROCESSING_MAX_SPEED);
    p.vx = clamped.vx;
    p.vy = clamped.vy;

    // Update position
    p.x += p.vx;
    p.y += p.vy;

    // Respawn if particle reaches center during processing
    if (progress > 0.5 && dist < ORB_RADIUS * 0.5) {
      p.alpha = 0; // Fade out at center
    } else if (progress < 0.5) {
      // Slowly restore alpha in idle mode
      p.alpha = Math.min(0.7, p.alpha + 0.01);
    }

    // Respawn if particle goes off-screen (idle only)
    if (progress < 0.5) {
      if (p.x < -50 || p.x > width + 50 || p.y < -50 || p.y > height + 50) {
        resetParticle(p, cx, cy, ORB_RADIUS);
      }
    }
  }, []);

  // Draw particles
  const drawParticles = useCallback((
    ctx: CanvasRenderingContext2D,
    particles: Particle[],
    progress: number
  ) => {
    particles.forEach((p) => {
      if (!p.active || p.alpha <= 0) return;

      // Adjust alpha based on state transition
      const alpha = p.alpha * (progress > 0.5 ? 0.8 : 1);

      ctx.beginPath();
      ctx.arc(p.x, p.y, PARTICLE_RADIUS, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(114, 197, 224, ${alpha})`; // Cyan with variable alpha
      ctx.fill();
    });
  }, []);

  // Main animation loop
  useEffect(() => {
    const result = setupCanvas();
    if (!result) return;

    const { ctx, width, height } = result;
    const count = particleCount ?? getDefaultParticleCount();
    initParticles(count, width, height);

    const animate = (time: number) => {
      // Calculate transition progress
      const elapsed = time - transitionStartRef.current;
      const targetProgress = stateRef.current === 'processing' ? 1 : 0;

      if (elapsed < STATE_TRANSITION_MS) {
        const rawProgress = elapsed / STATE_TRANSITION_MS;
        if (targetProgress === 1) {
          transitionProgressRef.current = rawProgress;
        } else {
          transitionProgressRef.current = 1 - rawProgress;
        }
      } else {
        transitionProgressRef.current = targetProgress;
      }

      const progress = transitionProgressRef.current;

      // Clear canvas
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

      // Get current dimensions
      const dpr = window.devicePixelRatio || 1;
      const currentWidth = ctx.canvas.width / dpr;
      const currentHeight = ctx.canvas.height / dpr;
      const cx = centerX || currentWidth / 2;
      const cy = centerY || currentHeight / 2;

      // Update and draw particles (skip updates if reduced motion)
      if (!prefersReducedMotion) {
        particlesRef.current.forEach((p) => {
          updateParticle(p, progress, cx, cy, time, currentWidth, currentHeight);
        });
      }

      drawParticles(ctx, particlesRef.current, progress);

      animationIdRef.current = requestAnimationFrame(animate);
    };

    animationIdRef.current = requestAnimationFrame(animate);

    // Handle resize
    const resizeObserver = new ResizeObserver(() => {
      const newResult = setupCanvas();
      if (newResult) {
        // Reinitialize particles on significant resize
        initParticles(count, newResult.width, newResult.height);
      }
    });

    if (containerRef.current) {
      resizeObserver.observe(containerRef.current);
    }

    return () => {
      cancelAnimationFrame(animationIdRef.current);
      resizeObserver.disconnect();
    };
  }, [
    setupCanvas,
    initParticles,
    updateParticle,
    drawParticles,
    particleCount,
    centerX,
    centerY,
    prefersReducedMotion,
  ]);

  return (
    <div
      ref={containerRef}
      className={cn("absolute inset-0 pointer-events-none", className)}
    >
      <canvas
        ref={canvasRef}
        className="h-full w-full"
        aria-hidden="true"
      />
    </div>
  );
}
```

Key implementation notes:
- Follows NetworkVisualization pattern exactly (refs, ResizeObserver, cleanup)
- Simplex noise creates organic flowing paths in idle state
- Distance-based attraction creates dramatic rush in processing state
- Eased 400ms transition between states prevents jarring changes
- Object pooling with in-place mutation avoids GC pressure
- Particles spawn in ring around orb, not inside it
- Particles fade when reaching orb center during processing
- Respects prefers-reduced-motion by skipping position updates
  </action>
  <verify>
```bash
pnpm exec tsc --noEmit src/components/visualization/particle-system.tsx
```
No TypeScript errors.
  </verify>
  <done>ParticleSystem component renders with idle flow and processing rush behaviors</done>
</task>

<task type="auto">
  <name>Task 2: Create barrel export for visualization components</name>
  <files>src/components/visualization/index.ts</files>
  <action>
Create a barrel export file for the visualization directory:

```typescript
// src/components/visualization/index.ts
export { ParticleSystem } from './particle-system';
export type { Particle, ParticleState, ParticleSystemProps } from './particle-types';
```

This provides a clean import path for consuming components:
```typescript
import { ParticleSystem } from '@/components/visualization';
```
  </action>
  <verify>
```bash
pnpm exec tsc --noEmit src/components/visualization/index.ts
```
No TypeScript errors.
  </verify>
  <done>Barrel export provides clean import path for ParticleSystem</done>
</task>

<task type="auto">
  <name>Task 3: Verify build and imports</name>
  <files>N/A (verification only)</files>
  <action>
Run full TypeScript check and build to ensure all files compile correctly:

1. Run TypeScript check:
```bash
pnpm exec tsc --noEmit
```

2. Verify the import path works by checking module resolution:
```bash
pnpm exec tsc --traceResolution 2>&1 | grep -A 2 "visualization"
```

3. Run build to catch any runtime issues:
```bash
pnpm build
```

Expected: All commands succeed without errors.
  </action>
  <verify>
```bash
pnpm exec tsc --noEmit && pnpm build
```
Both commands should complete successfully.
  </verify>
  <done>ParticleSystem builds and can be imported from @/components/visualization</done>
</task>

</tasks>

<verification>
Full verification after all tasks:

1. TypeScript strict mode passes:
```bash
pnpm exec tsc --noEmit
```

2. Build succeeds:
```bash
pnpm build
```

3. Verify ParticleSystem can be imported:
```bash
node -e "console.log('Import check passed')"
```

4. Visual verification (manual):
- Import ParticleSystem in a test page
- Confirm particles flow organically in idle state
- Confirm particles rush toward center when state='processing'
- Confirm smooth transition between states
</verification>

<success_criteria>
- ParticleSystem component renders flowing ambient particles around the orb center
- Particles use simplex noise for organic, hypnotic idle movement
- Particles rush toward orb center when state changes to 'processing'
- State transitions are smooth (400ms eased)
- Component respects prefers-reduced-motion
- Particle count is configurable via prop
- High-DPI canvas rendering is crisp
- Animation uses requestAnimationFrame with proper cleanup
- Build passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/21-particle-system/21-02-SUMMARY.md`
</output>
