---
phase: 49-hive-interactions
plan: 02
type: execute
wave: 2
depends_on: ["49-01"]
files_modified:
  - src/components/hive/use-hive-interaction.ts
  - src/components/hive/hive-renderer.ts
autonomous: true

must_haves:
  truths:
    - "Hovering a node highlights it and dims unrelated nodes"
    - "Connected nodes remain fully visible when a node is hovered"
    - "Hover state transitions are debounced to prevent flicker in dense clusters"
    - "Click-vs-drag discrimination prevents pan gestures from triggering node selection"
    - "Selected node has a visible glow/scale effect on canvas"
  artifacts:
    - path: "src/components/hive/use-hive-interaction.ts"
      provides: "React hook managing interaction state, event handlers, hover debounce, click discrimination"
      exports: ["useHiveInteraction"]
    - path: "src/components/hive/hive-renderer.ts"
      provides: "Augmented renderHive with interaction-aware dimming/highlighting/glow"
      exports: ["renderHive"]
  key_links:
    - from: "src/components/hive/use-hive-interaction.ts"
      to: "src/components/hive/hive-interaction.ts"
      via: "imports buildHiveQuadtree, findHoveredNode, screenToWorld, buildAdjacencyMap"
      pattern: "import.*hive-interaction"
    - from: "src/components/hive/hive-renderer.ts"
      to: "src/components/hive/hive-constants.ts"
      via: "imports DIM_OPACITY, DIM_LINE_OPACITY, SELECTED_GLOW_BLUR, SELECTED_GLOW_COLOR, SELECTED_SCALE"
      pattern: "DIM_OPACITY|SELECTED_GLOW"
---

<objective>
Create the interaction hook and augment the renderer to support hover highlighting, click selection with glow, and dim/highlight mode.

Purpose: This plan bridges the pure utility functions (Plan 01) with the final HiveCanvas integration (Plan 03). The hook encapsulates all interaction state management and event handling. The renderer gains the ability to draw nodes with interaction-aware opacity and selection glow.

Output: `use-hive-interaction.ts` (new), augmented `hive-renderer.ts`.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-hive-interactions/49-RESEARCH.md
@.planning/phases/49-hive-interactions/49-CONTEXT.md

@src/components/hive/hive-types.ts
@src/components/hive/hive-constants.ts
@src/components/hive/hive-interaction.ts
@src/components/hive/hive-renderer.ts
@src/components/hive/HiveCanvas.tsx
@src/components/hive/use-hive-animation.ts

# Prior plan context
@.planning/phases/49-hive-interactions/49-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create use-hive-interaction.ts hook</name>
  <files>
    src/components/hive/use-hive-interaction.ts
  </files>
  <action>
Create `src/components/hive/use-hive-interaction.ts` exporting `useHiveInteraction(options)`:

**Options interface:**
```typescript
interface UseHiveInteractionOptions {
  canvasRef: RefObject<HTMLCanvasElement | null>;
  layoutRef: RefObject<LayoutResult | null>;
  cameraRef: RefObject<Camera>;
  sizeRef: RefObject<CanvasSize>;
  render: () => void;
}
```

**Return interface:**
```typescript
interface UseHiveInteractionResult {
  /** Current interaction state ref (read by renderer). */
  readonly interactionRef: RefObject<InteractionState>;
  /** Selected node data (triggers React re-render for overlay). */
  readonly selectedNode: LayoutNode | null;
  /** Screen position of selected node (for overlay positioning). */
  readonly selectedNodeScreen: { x: number; y: number } | null;
  /** Clear the current selection (dismiss overlay). */
  readonly clearSelection: () => void;
  /** Whether camera has been moved from default position. */
  readonly isCameraMoved: boolean;
  /** Reset camera to default zoom=1, pan=0,0. */
  readonly resetCamera: () => void;
  /** Notify hook that camera changed (recalculates overlay position + isCameraMoved). Call after zoom/pan mutations. */
  readonly onCameraChange: () => void;
}
```

**Internal state (all refs except selectedNode/selectedNodeScreen/isCameraMoved):**
- `interactionRef` = `useRef<InteractionState>({ hoveredNodeId: null, selectedNodeId: null, connectedNodeIds: new Set() })`
- `quadtreeRef` = `useRef(null)` -- rebuilt when layout changes
- `adjacencyMapRef` = `useRef(new Map())` -- rebuilt when layout changes
- `mouseDownPosRef` = `useRef({ x: 0, y: 0 })` -- for click-vs-drag
- `hoverDebounceRef` = `useRef(null)` -- timeout ID
- `fitTransformRef` = `useRef<FitTransform>({ scale: 1, offsetX: 0, offsetY: 0 })` -- recomputed from layout + size

**selectedNode and selectedNodeScreen and isCameraMoved:** These are `useState` because they drive React re-renders for the DOM overlay and reset button visibility. All other interaction state is ref-based.

**Quadtree + adjacency rebuild:**
- `useEffect` keyed on layout (from layoutRef.current via a useMemo or a layout prop). When layout changes, call `buildHiveQuadtree(layout)` and `buildAdjacencyMap(layout.links)`. Store results in refs.
- Also recompute fitTransform via `computeFitTransform(layout.bounds, sizeRef.current.width, sizeRef.current.height)` -- import `computeFitTransform` from `./hive-layout` (it already exists there as an export, do NOT recreate it in hive-interaction.ts).

**NOTE:** The hook needs a `layout` prop (not just layoutRef) to react to layout changes. Add `layout: LayoutResult | null` to options.

**Event handlers (attached via useEffect on canvasRef):**

1. **mousemove handler:**
   - Get canvas rect, compute CSS-pixel mouse position.
   - Call `screenToWorld()` with camera, canvasSize, fitTransform.
   - Call `findHoveredNode(quadtree, worldX, worldY, camera.zoom)`.
   - Apply hover debounce (from RESEARCH.md):
     - node -> null: instant clear (set hoveredNodeId=null, connectedNodeIds=empty, call render())
     - node -> different node: debounce with HOVER_DEBOUNCE_MS timeout. On timeout, set hoveredNodeId, look up connectedNodeIds from adjacencyMap, call render().
     - same node: no-op
   - Cursor: set canvas cursor to 'pointer' when over a node, 'grab' when not (respect isDragging state).

2. **mousedown handler:**
   - Record mouseDownPosRef = { x: clientX, y: clientY }
   - Do NOT set isDragging yet (defer to mousemove threshold)

3. **mouseup handler:**
   - Compute distance from mouseDownPosRef to current position.
   - If distance < CLICK_DRAG_THRESHOLD: this is a click.
     - Compute world coords, find node.
     - If node found and node !== current selectedNode:
       - Set selectedNodeId in interactionRef.
       - Set connectedNodeIds from adjacencyMap (union of hovered and selected connections).
       - Compute screen position via worldToScreen(), set selectedNodeScreen state.
       - Set selectedNode state (triggers React re-render for overlay).
     - If node found and node === current selectedNode: deselect (clearSelection).
     - If no node found: clearSelection.
     - Call render().

4. **clearSelection function:**
   - Set interactionRef.selectedNodeId = null.
   - Clear selectedNode and selectedNodeScreen state.
   - Call render().

5. **Camera tracking for reset button:**
   - Track isCameraMoved state. Set to `true` when camera.zoom !== 1 || camera.panX !== 0 || camera.panY !== 0.
   - Update this in the existing wheel and mouse-drag handlers (those will be in HiveCanvas, but the hook can expose an `onCameraChange` callback that HiveCanvas calls after modifying camera).
   - Actually: cleaner approach is to track it in a `useEffect` that runs after render. Check cameraRef values and update isCameraMoved state.
   - Simplest: expose `checkCameraMoved()` that HiveCanvas calls after zoom/pan. It reads cameraRef and sets isCameraMoved.

6. **resetCamera function:**
   - Set cameraRef.current = { zoom: 1, panX: 0, panY: 0 }.
   - Set isCameraMoved = false.
   - Clear selection (overlay would be mispositioned after reset).
   - Call render().

**Recalculate overlay position on camera change:**
- When selectedNode is set and camera changes (zoom/pan), recalculate selectedNodeScreen. The render() callback already fires on camera change. Add a function `updateSelectedNodeScreen()` that reads the selected node's world coords and recomputes screen position. Call this from within the hook whenever camera changes are detected.
- Approach: the hook exposes a `onCameraChange()` callback. HiveCanvas calls it after any camera mutation (wheel, pan). This recalculates overlay position and camera-moved state.

**Cleanup:** Clean up event listeners on unmount. Clear hover debounce timeout.

**IMPORTANT patterns to follow:**
- Ref-based interaction state (not useState) for per-frame data (hoveredNodeId, connectedNodeIds).
- useState ONLY for selectedNode (drives overlay render) and isCameraMoved (drives reset button visibility).
- All coordinate math uses CSS pixel space (not buffer pixels). DPR is handled by the canvas transform, not the interaction layer.
  </action>
  <verify>
    - `pnpm exec tsc --noEmit` passes
    - `grep "useHiveInteraction" src/components/hive/use-hive-interaction.ts` confirms export
    - Hook returns interactionRef, selectedNode, selectedNodeScreen, clearSelection, isCameraMoved, resetCamera, onCameraChange
  </verify>
  <done>
    use-hive-interaction.ts exports a single hook that manages quadtree-based hit detection, hover debounce, click-vs-drag discrimination, selection state (ref for canvas, useState for overlay), camera-move tracking, and overlay position recalculation. All event handlers attach to the canvas element.
  </done>
</task>

<task type="auto">
  <name>Task 2: Augment hive-renderer.ts with interaction-aware drawing</name>
  <files>
    src/components/hive/hive-renderer.ts
  </files>
  <action>
Modify `hive-renderer.ts` to support interaction-aware rendering:

1. **Add InteractionRenderState to the render pipeline:**
   Add a new optional parameter to `renderHive()`:
   ```typescript
   interface InteractionRenderState {
     hoveredNodeId: string | null;
     selectedNodeId: string | null;
     connectedNodeIds: Set<string>;
   }
   ```
   Updated signature:
   ```typescript
   export function renderHive(
     ctx: CanvasRenderingContext2D,
     layout: LayoutResult,
     canvasWidth: number,
     canvasHeight: number,
     visibility?: Record<number, TierVisibility>,
     interaction?: InteractionRenderState,
   ): void
   ```

2. **Per-node opacity function:**
   Add internal helper `getNodeInteractionOpacity(nodeId, interaction)`:
   - If no interaction or no active node (neither hovered nor selected): return 1 (full opacity).
   - Determine `activeId = interaction.selectedNodeId ?? interaction.hoveredNodeId`.
   - If `nodeId === activeId`: return 1 (hovered/selected node at full).
   - If `interaction.connectedNodeIds.has(nodeId)`: return 1 (connected node at full).
   - Otherwise: return DIM_OPACITY (0.15).

3. **Per-link opacity function:**
   Add internal helper `getLinkInteractionOpacity(sourceId, targetId, interaction)`:
   - If no interaction or no active node: return 1.
   - Determine `activeId = interaction.selectedNodeId ?? interaction.hoveredNodeId`.
   - If source or target is the active node, and the other is connected: return 1 (highlight).
   - If both source and target are connected to the active node: return 0.5 (secondary connection).
   - Otherwise: return DIM_LINE_OPACITY / baseOpacity ratio (effectively very dim).

   Simpler approach: in `drawConnectionLines`, multiply the final line opacity by the interaction factor. If either endpoint is the active node or both endpoints are in connectedNodeIds, keep full. Otherwise, use DIM_LINE_OPACITY as the final opacity (replacing the computed baseOpacity).

4. **Modify `drawConnectionLines`:**
   - Accept optional `interaction` parameter.
   - After computing `finalOpacity`, multiply by interaction factor:
     ```typescript
     if (interaction) {
       const activeId = interaction.selectedNodeId ?? interaction.hoveredNodeId;
       if (activeId) {
         const sourceIsRelevant = source.id === activeId || interaction.connectedNodeIds.has(source.id);
         const targetIsRelevant = target.id === activeId || interaction.connectedNodeIds.has(target.id);
         if (!sourceIsRelevant || !targetIsRelevant) {
           // Dim this link
           finalOpacity = DIM_LINE_OPACITY;
         }
       }
     }
     ```

5. **Modify `drawNodes`:**
   - Accept optional `interaction` parameter.
   - Before drawing each node, compute interaction opacity:
     ```typescript
     const interactionOpacity = getNodeInteractionOpacity(node.id, interaction);
     ```
   - Multiply `animOpacity` by `interactionOpacity` for the final globalAlpha.

6. **Modify `drawCenterRect`:**
   - Accept optional `interaction` parameter.
   - Apply interaction opacity to the center node as well.

7. **Add selected node glow effect:**
   After drawing all nodes, if `interaction?.selectedNodeId` is set, find the selected node and draw a glow:
   ```typescript
   if (interaction?.selectedNodeId) {
     const selectedNode = layout.nodes.find(n => n.id === interaction.selectedNodeId);
     if (selectedNode) {
       const sx = Math.round(selectedNode.x * scale + offsetX);
       const sy = Math.round(selectedNode.y * scale + offsetY);
       // Glow via shadowBlur
       ctx.save();
       ctx.shadowBlur = SELECTED_GLOW_BLUR;
       ctx.shadowColor = SELECTED_GLOW_COLOR;
       // Draw the node slightly larger with glow
       const isCenter = selectedNode.tier === 0;
       if (isCenter) {
         const { width, height, borderRadius } = NODE_SIZES.center;
         const w = width * SELECTED_SCALE;
         const h = height * SELECTED_SCALE;
         ctx.beginPath();
         ctx.roundRect(sx - w/2, sy - h/2, w, h, borderRadius);
         ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
         ctx.fill();
       } else {
         const config = tierRadii[selectedNode.tier]; // use same tier config
         const sizeHash = hashString(selectedNode.id);
         const baseRadius = config ? config.base * (config.minMult + sizeHash * (config.maxMult - config.minMult)) : 6;
         ctx.beginPath();
         ctx.arc(sx, sy, baseRadius * SELECTED_SCALE, 0, Math.PI * 2);
         ctx.fillStyle = selectedNode.color;
         ctx.fill();
       }
       ctx.restore();
     }
   }
   ```
   Move the `hashString` function or make the `tierRadii` config accessible to this glow section. The simplest approach: extract `tierRadii` computation to module scope or pass through internally. Since drawNodes already has it, consider drawing the glow as part of a new `drawSelectedGlow` helper.

8. **Pass interaction through `renderHive`:**
   Thread the `interaction` parameter to `drawConnectionLines`, `drawNodes`, `drawCenterRect`, and the glow effect.

Import DIM_OPACITY, DIM_LINE_OPACITY, SELECTED_GLOW_BLUR, SELECTED_GLOW_COLOR, SELECTED_SCALE from `./hive-constants`.
  </action>
  <verify>
    - `pnpm exec tsc --noEmit` passes
    - `renderHive` signature accepts optional `interaction` parameter
    - `grep "DIM_OPACITY\|SELECTED_GLOW" src/components/hive/hive-renderer.ts` confirms constant usage
    - `grep "getNodeInteractionOpacity" src/components/hive/hive-renderer.ts` confirms opacity helper exists
  </verify>
  <done>
    hive-renderer.ts renderHive() accepts an optional InteractionRenderState. When present: unrelated nodes dim to 0.15 opacity, unrelated lines dim to 0.03, connected nodes stay at full, and selected node draws with a coral glow + 1.3x scale. When absent: renders identically to before (backward compatible).
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` passes with no errors
2. use-hive-interaction.ts exports useHiveInteraction hook
3. Hook manages quadtree rebuild on layout change, hover debounce, click-vs-drag, selection state
4. hive-renderer.ts renderHive() accepts optional interaction parameter
5. Dimming logic: unrelated nodes at DIM_OPACITY (0.15), connected at 1.0
6. Selected glow: canvas shadowBlur + coral color on selected node
7. `pnpm build` succeeds
</verification>

<success_criteria>
- Interaction hook encapsulates all state management without requiring useState for per-frame data
- Renderer draws dimmed/highlighted nodes based on interaction state
- Selected node has visible coral glow effect
- Click-vs-drag threshold prevents pan from triggering selection
- Hover debounce prevents flicker when cursor moves between adjacent nodes
- Existing render behavior unchanged when no interaction state is passed
</success_criteria>

<output>
After completion, create `.planning/phases/49-hive-interactions/49-02-SUMMARY.md`
</output>
