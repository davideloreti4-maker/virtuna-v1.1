---
phase: 49-hive-interactions
plan: 03
type: execute
wave: 3
depends_on: ["49-02"]
files_modified:
  - src/components/hive/HiveCanvas.tsx
  - src/components/hive/HiveNodeOverlay.tsx
  - src/components/hive/use-hive-interaction.ts
autonomous: true

must_haves:
  truths:
    - "Hovering a node highlights it and dims unrelated nodes visually on canvas"
    - "Clicking a node shows a GlassCard info overlay near the clicked node"
    - "Overlay dismisses via X button, clicking elsewhere, or clicking another node"
    - "Overlay stays positioned near its node during zoom/pan"
    - "Pinch-to-zoom works on mobile/trackpad"
    - "Reset button appears when camera is moved and resets zoom/pan to default"
    - "Cursor changes to pointer on node hover"
  artifacts:
    - path: "src/components/hive/HiveCanvas.tsx"
      provides: "Integrated canvas component with interaction hook, overlay, pinch-to-zoom, reset button"
      exports: ["HiveCanvas"]
    - path: "src/components/hive/HiveNodeOverlay.tsx"
      provides: "GlassCard overlay component for selected node info"
      exports: ["HiveNodeOverlay"]
  key_links:
    - from: "src/components/hive/HiveCanvas.tsx"
      to: "src/components/hive/use-hive-interaction.ts"
      via: "useHiveInteraction hook wired into canvas"
      pattern: "useHiveInteraction"
    - from: "src/components/hive/HiveCanvas.tsx"
      to: "src/components/hive/HiveNodeOverlay.tsx"
      via: "Overlay rendered as DOM sibling to canvas"
      pattern: "HiveNodeOverlay"
    - from: "src/components/hive/HiveCanvas.tsx"
      to: "src/components/hive/hive-renderer.ts"
      via: "renderHive called with interaction state from hook"
      pattern: "renderHive.*interaction"
---

<objective>
Wire the interaction hook into HiveCanvas, add the DOM overlay component, implement pinch-to-zoom and reset button, completing the full interactive hive experience.

Purpose: This is the integration plan that assembles all prior work into a working interactive canvas. Users will be able to hover, click, zoom, pan, and explore the hive with responsive visual feedback and info overlays.

**NOTE: Pan logic migration.** This plan moves mouse-drag pan handling OUT of HiveCanvas.tsx and INTO the interaction hook (use-hive-interaction.ts). The hook already owns mousedown/mousemove/mouseup for click-vs-drag discrimination, so co-locating pan there eliminates dual-handler conflicts and keeps all pointer logic in one place. The existing pan useEffect in HiveCanvas.tsx is REMOVED; the hook manages pan via cameraRef directly.

Output: Updated `HiveCanvas.tsx`, new `HiveNodeOverlay.tsx`.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-hive-interactions/49-RESEARCH.md
@.planning/phases/49-hive-interactions/49-CONTEXT.md

@src/components/hive/HiveCanvas.tsx
@src/components/hive/hive-types.ts
@src/components/hive/hive-constants.ts
@src/components/hive/hive-interaction.ts
@src/components/hive/use-hive-interaction.ts
@src/components/hive/hive-renderer.ts
@src/components/primitives/GlassCard.tsx

# Prior plan context
@.planning/phases/49-hive-interactions/49-01-SUMMARY.md
@.planning/phases/49-hive-interactions/49-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HiveNodeOverlay component</name>
  <files>
    src/components/hive/HiveNodeOverlay.tsx
  </files>
  <action>
Create `src/components/hive/HiveNodeOverlay.tsx` -- a client component displaying node information as a GlassCard positioned absolutely over the canvas.

**Props:**
```typescript
interface HiveNodeOverlayProps {
  node: LayoutNode;
  screenPosition: { x: number; y: number };
  containerWidth: number;
  containerHeight: number;
  onClose: () => void;
}
```

**Implementation:**
1. Use `useRef` to measure overlay dimensions after first render (for auto-positioning).
2. Use `useEffect` + `useState` to compute final position via `computeOverlayPosition` from `hive-interaction.ts`. Initially render off-screen (opacity: 0) to measure, then animate in.
3. Render as a `div` with `position: absolute`, `pointer-events: auto`, `z-index: 10`:
   ```jsx
   <div
     className="absolute z-10 pointer-events-auto"
     style={{ left: position.left, top: position.top, opacity: isPositioned ? 1 : 0, transition: 'opacity 150ms ease-out' }}
     ref={overlayRef}
   >
     <GlassCard padding="sm" blur="md" className="w-[220px]">
       {/* Close button */}
       <button
         onClick={onClose}
         className="absolute top-2 right-2 text-white/40 hover:text-white/80 transition-colors"
         aria-label="Close overlay"
       >
         <Icon name="x" size={14} />
       </button>

       {/* Node info */}
       <div className="space-y-2 pr-6">
         <Text variant="label" className="text-white/90 font-medium">
           {node.name ?? node.id}
         </Text>
         <div className="flex items-center gap-2">
           <span
             className="w-2.5 h-2.5 rounded-full"
             style={{ backgroundColor: node.color }}
           />
           <Text variant="caption" className="text-white/50">
             {node.tier === 0 ? 'Center' : node.tier === 1 ? 'Theme' : 'Sub-theme'}
           </Text>
         </div>
         {/* Show meta values if present */}
         {node.meta && Object.entries(node.meta).slice(0, 3).map(([key, value]) => (
           <div key={key} className="flex justify-between items-center">
             <Text variant="caption" className="text-white/40 capitalize">{key}</Text>
             <Text variant="caption" className="text-white/70">{String(value)}</Text>
           </div>
         ))}
       </div>
     </GlassCard>
   </div>
   ```

4. Import `GlassCard` from `@/components/primitives/GlassCard`, `Text` from `@/components/primitives/Text`, `Icon` from `@/components/primitives/Icon`.
5. Import `computeOverlayPosition` from `./hive-interaction`.
6. The overlay should recalculate position when `screenPosition` changes (useEffect keyed on screenPosition).
7. Add `'use client'` directive at top.

**Auto-positioning via useEffect:**
```typescript
useEffect(() => {
  if (!overlayRef.current) return;
  const { offsetWidth, offsetHeight } = overlayRef.current;
  const { left, top, placement } = computeOverlayPosition(
    screenPosition.x,
    screenPosition.y,
    offsetWidth,
    offsetHeight,
    containerWidth,
    containerHeight,
  );
  setPosition({ left, top });
  setIsPositioned(true);
}, [screenPosition.x, screenPosition.y, containerWidth, containerHeight]);
```
- Initially render with `opacity: 0` so the overlay can be measured before being shown.
- After `computeOverlayPosition` returns, set `isPositioned = true` to fade in (opacity transitions to 1).
  </action>
  <verify>
    - `pnpm exec tsc --noEmit` passes
    - `grep "HiveNodeOverlay" src/components/hive/HiveNodeOverlay.tsx` confirms export
    - Component imports GlassCard and computeOverlayPosition
  </verify>
  <done>
    HiveNodeOverlay.tsx renders a GlassCard overlay with node name, tier label, color indicator, meta values, and close button. Auto-positions near the node with edge-clamping. Fades in on mount.
  </done>
</task>

<task type="auto">
  <name>Task 2a: Wire interaction hook, overlay, and reset button into HiveCanvas</name>
  <files>
    src/components/hive/HiveCanvas.tsx
  </files>
  <action>
Update HiveCanvas.tsx to integrate the interaction hook, overlay, and reset button:

**1. Wrap canvas in a container div:**
The canvas needs a positioned parent for the overlay. Change the JSX from a bare `<canvas>` to:
```jsx
<div ref={containerRef} className={cn('relative w-full h-full', className)} style={{ overflow: 'hidden' }}>
  <canvas
    ref={canvasRef}
    className="w-full h-full"
    style={{ width: '100%', height: '100%', touchAction: 'none' }}
    aria-label="Hive visualization showing test content analysis"
    role="img"
  />
  {/* Overlay rendered when a node is selected */}
  {interaction.selectedNode && interaction.selectedNodeScreen && (
    <HiveNodeOverlay
      node={interaction.selectedNode}
      screenPosition={interaction.selectedNodeScreen}
      containerWidth={sizeRef.current.width}
      containerHeight={sizeRef.current.height}
      onClose={interaction.clearSelection}
    />
  )}
  {/* Reset/fit button */}
  {interaction.isCameraMoved && (
    <button
      onClick={interaction.resetCamera}
      className="absolute bottom-4 right-4 z-10 flex items-center gap-1.5 px-3 py-1.5 rounded-lg bg-white/[0.06] border border-white/[0.06] text-white/60 hover:text-white/90 hover:bg-white/[0.1] transition-all text-xs"
      aria-label="Reset zoom and pan"
    >
      <Icon name="maximize-2" size={14} />
      <span>Reset view</span>
    </button>
  )}
</div>
```
Move `className` prop to the container div, not the canvas.

**2. Wire useHiveInteraction hook:**
```typescript
const interaction = useHiveInteraction({
  canvasRef,
  layoutRef,
  layout,
  cameraRef,
  sizeRef,
  render,
});
```

**3. Update render() to pass interaction state:**
In the render callback, pass interaction ref to renderHive:
```typescript
renderHive(
  ctx,
  layoutRef.current,
  cssWidth,
  cssHeight,
  animation.visibility,
  interactionRef.current,  // NEW: interaction state
);
```
Access `interactionRef` from the hook result: `const { interactionRef } = interaction;`

**4. Remove inline Camera interface and constants:**
Delete the local `Camera` interface, `MIN_ZOOM`, `MAX_ZOOM`, `ZOOM_SENSITIVITY` from HiveCanvas.tsx. Import them from `hive-types.ts` and `hive-constants.ts` respectively.

**5. Update wheel zoom handler:**
- Use `MIN_ZOOM` and `MAX_ZOOM` from hive-constants.ts (MIN_ZOOM is now 0.2 per CONTEXT.md).
- After modifying camera, call `interaction.onCameraChange()` to update overlay position and camera-moved state.

**6. Import cleanup:**
- Import `Camera`, `FitTransform` from `./hive-types`
- Import `MIN_ZOOM`, `MAX_ZOOM`, `ZOOM_SENSITIVITY` from `./hive-constants`
- Import `useHiveInteraction` from `./use-hive-interaction`
- Import `HiveNodeOverlay` from `./HiveNodeOverlay`
- Import `Icon` from `@/components/primitives/Icon`
  </action>
  <verify>
    - `pnpm exec tsc --noEmit` passes
    - `grep "useHiveInteraction" src/components/hive/HiveCanvas.tsx` confirms hook integration
    - `grep "HiveNodeOverlay" src/components/hive/HiveCanvas.tsx` confirms overlay rendering
    - `grep "isCameraMoved" src/components/hive/HiveCanvas.tsx` confirms reset button
    - `grep "import.*MIN_ZOOM.*hive-constants" src/components/hive/HiveCanvas.tsx` confirms constants import
  </verify>
  <done>
    HiveCanvas.tsx wires useHiveInteraction hook, renders HiveNodeOverlay when a node is selected, shows reset button when camera is moved, passes interaction state to renderer. Canvas wrapped in positioned container div. Inline Camera/constants removed in favor of imports.
  </done>
</task>

<task type="auto">
  <name>Task 2b: Migrate pan logic to hook + add pinch-to-zoom</name>
  <files>
    src/components/hive/HiveCanvas.tsx
    src/components/hive/use-hive-interaction.ts
  </files>
  <action>
This task completes the pointer-event consolidation by migrating pan logic into the interaction hook and adding pinch-to-zoom.

**1. Move pan logic INTO the interaction hook (use-hive-interaction.ts):**
The hook already handles mousedown/mousemove/mouseup for hit detection and click-vs-drag discrimination. Pan state should be co-located:
- **mousedown:** Record mouseDownPos, set `isPotentialDrag = true`.
- **mousemove:** If `isPotentialDrag` and distance from mouseDownPos > CLICK_DRAG_THRESHOLD, set `isDragging = true`. While dragging, compute delta from last position, update `cameraRef.current.panX += dx`, `cameraRef.current.panY += dy`, call `render()`. Also do hit detection for cursor changes when NOT dragging.
- **mouseup:** If `isDragging` was true, stop drag, set cursor back, call `onCameraChange()`. If NOT dragging (distance < threshold), treat as click (hit detect + select).
- **Cursor management:** `pointer` if over a node and not dragging, `grabbing` if dragging, `grab` otherwise.

**2. REMOVE the existing pan useEffect from HiveCanvas.tsx:**
Delete the existing `useEffect` that attaches mousedown/mousemove/mouseup handlers for panning. All mouse interaction now flows through the hook.

**3. Add pinch-to-zoom via Pointer Events in the interaction hook:**
Add refs:
```typescript
const pointerCacheRef = useRef<Map<number, PointerEvent>>(new Map());
const prevPinchDistRef = useRef<number>(-1);
```
Attach pointer event handlers to the canvas:
- `pointerdown`: add to cache
- `pointermove`: update cache. If 2 pointers: compute distance between them, apply zoom delta to `cameraRef.current.zoom`, clamp to `[MIN_ZOOM, MAX_ZOOM]`, call `render()` + internally call the overlay/camera-moved update logic.
- `pointerup / pointercancel`: remove from cache, reset `prevPinchDist` if fewer than 2 pointers remain.
- Canvas already has `touch-action: none` from Task 2a to prevent browser gestures.

**4. Keep wheel zoom in HiveCanvas:**
The wheel handler stays as a separate useEffect in HiveCanvas (it's already there and working). It was already updated in Task 2a to use constants and call `interaction.onCameraChange()`.
  </action>
  <verify>
    - `pnpm exec tsc --noEmit` passes
    - `pnpm build` succeeds
    - `grep "pointerdown\|pointermove" src/components/hive/use-hive-interaction.ts` confirms pinch-to-zoom events in hook
    - `grep "isDragging\|panX" src/components/hive/use-hive-interaction.ts` confirms pan logic in hook
    - No mousedown/mousemove pan useEffect remains in HiveCanvas.tsx (only the wheel useEffect)
    - Dev server starts without errors: `pnpm dev` (check console)
  </verify>
  <done>
    Pan logic fully migrated from HiveCanvas.tsx into use-hive-interaction.ts. Pinch-to-zoom implemented via pointer events in the hook. All mouse/pointer interaction flows through the hook. HiveCanvas only retains the wheel-zoom useEffect. Build compiles clean.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` passes
2. `pnpm build` succeeds
3. HiveCanvas renders canvas inside a container div with overlay and reset button
4. useHiveInteraction hook is wired up with all required refs
5. renderHive receives interaction state from hook
6. HiveNodeOverlay renders GlassCard with node info when selected
7. Reset button appears only when camera has been moved
8. Pinch-to-zoom handler exists (pointer events)
9. Dev server starts without runtime errors
</verification>

<success_criteria>
- Hovering nodes dims unrelated ones visually
- Clicking a node opens GlassCard overlay with node info near the clicked node
- Overlay dismisses via close button, clicking elsewhere, or clicking another node
- Overlay repositions during zoom/pan (stays attached to node)
- Pinch-to-zoom and scroll-wheel zoom both work
- Reset button appears when zoomed/panned, resets to default view on click
- Cursor changes: pointer on node, grab on empty space, grabbing while dragging
- No console errors during interaction
</success_criteria>

<output>
After completion, create `.planning/phases/49-hive-interactions/49-03-SUMMARY.md`
</output>
