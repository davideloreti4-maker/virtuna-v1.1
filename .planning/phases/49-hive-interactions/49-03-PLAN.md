---
phase: 49-hive-interactions
plan: 03
type: execute
wave: 3
depends_on: ["49-02"]
files_modified:
  - src/components/hive/HiveCanvas.tsx
  - src/components/hive/HiveNodeOverlay.tsx
autonomous: true

must_haves:
  truths:
    - "Hovering a node highlights it and dims unrelated nodes visually on canvas"
    - "Clicking a node shows a GlassCard info overlay near the clicked node"
    - "Overlay dismisses via X button, clicking elsewhere, or clicking another node"
    - "Overlay stays positioned near its node during zoom/pan"
    - "Pinch-to-zoom works on mobile/trackpad"
    - "Reset button appears when camera is moved and resets zoom/pan to default"
    - "Cursor changes to pointer on node hover"
  artifacts:
    - path: "src/components/hive/HiveCanvas.tsx"
      provides: "Integrated canvas component with interaction hook, overlay, pinch-to-zoom, reset button"
      exports: ["HiveCanvas"]
    - path: "src/components/hive/HiveNodeOverlay.tsx"
      provides: "GlassCard overlay component for selected node info"
      exports: ["HiveNodeOverlay"]
  key_links:
    - from: "src/components/hive/HiveCanvas.tsx"
      to: "src/components/hive/use-hive-interaction.ts"
      via: "useHiveInteraction hook wired into canvas"
      pattern: "useHiveInteraction"
    - from: "src/components/hive/HiveCanvas.tsx"
      to: "src/components/hive/HiveNodeOverlay.tsx"
      via: "Overlay rendered as DOM sibling to canvas"
      pattern: "HiveNodeOverlay"
    - from: "src/components/hive/HiveCanvas.tsx"
      to: "src/components/hive/hive-renderer.ts"
      via: "renderHive called with interaction state from hook"
      pattern: "renderHive.*interaction"
---

<objective>
Wire the interaction hook into HiveCanvas, add the DOM overlay component, implement pinch-to-zoom and reset button, completing the full interactive hive experience.

Purpose: This is the integration plan that assembles all prior work into a working interactive canvas. Users will be able to hover, click, zoom, pan, and explore the hive with responsive visual feedback and info overlays.

Output: Updated `HiveCanvas.tsx`, new `HiveNodeOverlay.tsx`.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-hive-interactions/49-RESEARCH.md
@.planning/phases/49-hive-interactions/49-CONTEXT.md

@src/components/hive/HiveCanvas.tsx
@src/components/hive/hive-types.ts
@src/components/hive/hive-constants.ts
@src/components/hive/hive-interaction.ts
@src/components/hive/use-hive-interaction.ts
@src/components/hive/hive-renderer.ts
@src/components/primitives/GlassCard.tsx

# Prior plan context
@.planning/phases/49-hive-interactions/49-01-SUMMARY.md
@.planning/phases/49-hive-interactions/49-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HiveNodeOverlay component</name>
  <files>
    src/components/hive/HiveNodeOverlay.tsx
  </files>
  <action>
Create `src/components/hive/HiveNodeOverlay.tsx` -- a client component displaying node information as a GlassCard positioned absolutely over the canvas.

**Props:**
```typescript
interface HiveNodeOverlayProps {
  node: LayoutNode;
  screenPosition: { x: number; y: number };
  containerWidth: number;
  containerHeight: number;
  onClose: () => void;
}
```

**Implementation:**
1. Use `useRef` to measure overlay dimensions after first render (for auto-positioning).
2. Use `useEffect` + `useState` to compute final position via `computeOverlayPosition` from `hive-interaction.ts`. Initially render off-screen (opacity: 0) to measure, then animate in.
3. Render as a `div` with `position: absolute`, `pointer-events: auto`, `z-index: 10`:
   ```jsx
   <div
     className="absolute z-10 pointer-events-auto"
     style={{ left: position.left, top: position.top, opacity: isPositioned ? 1 : 0, transition: 'opacity 150ms ease-out' }}
     ref={overlayRef}
   >
     <GlassCard padding="sm" blur="md" className="w-[220px]">
       {/* Close button */}
       <button
         onClick={onClose}
         className="absolute top-2 right-2 text-white/40 hover:text-white/80 transition-colors"
         aria-label="Close overlay"
       >
         <Icon name="x" size={14} />
       </button>

       {/* Node info */}
       <div className="space-y-2 pr-6">
         <Text variant="label" className="text-white/90 font-medium">
           {node.name ?? node.id}
         </Text>
         <div className="flex items-center gap-2">
           <span
             className="w-2.5 h-2.5 rounded-full"
             style={{ backgroundColor: node.color }}
           />
           <Text variant="caption" className="text-white/50">
             {node.tier === 0 ? 'Center' : node.tier === 1 ? 'Theme' : 'Sub-theme'}
           </Text>
         </div>
         {/* Show meta values if present */}
         {node.meta && Object.entries(node.meta).slice(0, 3).map(([key, value]) => (
           <div key={key} className="flex justify-between items-center">
             <Text variant="caption" className="text-white/40 capitalize">{key}</Text>
             <Text variant="caption" className="text-white/70">{String(value)}</Text>
           </div>
         ))}
       </div>
     </GlassCard>
   </div>
   ```

4. Import `GlassCard` from `@/components/primitives/GlassCard`, `Text` from `@/components/primitives/Text`, `Icon` from `@/components/primitives/Icon`.
5. Import `computeOverlayPosition` from `./hive-interaction`.
6. The overlay should recalculate position when `screenPosition` changes (useEffect keyed on screenPosition).
7. Add `'use client'` directive at top.

**Auto-positioning:**
- On mount / screenPosition change: measure overlay with `overlayRef.current.getBoundingClientRect()`
- Pass dimensions to `computeOverlayPosition(screenPosition.x, screenPosition.y, overlayWidth, overlayHeight, containerWidth, containerHeight)`
- Set position state and `isPositioned = true`
  </action>
  <verify>
    - `pnpm exec tsc --noEmit` passes
    - `grep "HiveNodeOverlay" src/components/hive/HiveNodeOverlay.tsx` confirms export
    - Component imports GlassCard and computeOverlayPosition
  </verify>
  <done>
    HiveNodeOverlay.tsx renders a GlassCard overlay with node name, tier label, color indicator, meta values, and close button. Auto-positions near the node with edge-clamping. Fades in on mount.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire interaction hook + overlay + pinch-to-zoom + reset into HiveCanvas</name>
  <files>
    src/components/hive/HiveCanvas.tsx
  </files>
  <action>
Rewrite HiveCanvas.tsx to integrate the interaction system:

**1. Wrap canvas in a container div:**
The canvas needs a positioned parent for the overlay. Change the JSX from a bare `<canvas>` to:
```jsx
<div ref={containerRef} className={cn('relative w-full h-full', className)} style={{ overflow: 'hidden' }}>
  <canvas
    ref={canvasRef}
    className="w-full h-full"
    style={{ width: '100%', height: '100%', touchAction: 'none' }}
    aria-label="Hive visualization showing test content analysis"
    role="img"
  />
  {/* Overlay rendered when a node is selected */}
  {interaction.selectedNode && interaction.selectedNodeScreen && (
    <HiveNodeOverlay
      node={interaction.selectedNode}
      screenPosition={interaction.selectedNodeScreen}
      containerWidth={sizeRef.current.width}
      containerHeight={sizeRef.current.height}
      onClose={interaction.clearSelection}
    />
  )}
  {/* Reset/fit button */}
  {interaction.isCameraMoved && (
    <button
      onClick={interaction.resetCamera}
      className="absolute bottom-4 right-4 z-10 flex items-center gap-1.5 px-3 py-1.5 rounded-lg bg-white/[0.06] border border-white/[0.06] text-white/60 hover:text-white/90 hover:bg-white/[0.1] transition-all text-xs"
      aria-label="Reset zoom and pan"
    >
      <Icon name="maximize-2" size={14} />
      <span>Reset view</span>
    </button>
  )}
</div>
```
Move `className` prop to the container div, not the canvas.

**2. Wire useHiveInteraction hook:**
```typescript
const interaction = useHiveInteraction({
  canvasRef,
  layoutRef,
  layout,
  cameraRef,
  sizeRef,
  render,
});
```

**3. Update render() to pass interaction state:**
In the render callback, pass interaction ref to renderHive:
```typescript
renderHive(
  ctx,
  layoutRef.current,
  cssWidth,
  cssHeight,
  animation.visibility,
  interactionRef.current,  // NEW: interaction state
);
```
Access `interactionRef` from the hook result: `const { interactionRef } = interaction;`

**4. Remove inline Camera interface and constants:**
Delete the local `Camera` interface, `MIN_ZOOM`, `MAX_ZOOM`, `ZOOM_SENSITIVITY` from HiveCanvas.tsx. Import them from `hive-types.ts` and `hive-constants.ts` respectively.

**5. Update wheel zoom handler:**
- Use `MIN_ZOOM` and `MAX_ZOOM` from hive-constants.ts (MIN_ZOOM is now 0.2 per CONTEXT.md).
- After modifying camera, call `interaction.onCameraChange()` to update overlay position and camera-moved state.

**6. Update mouse pan handlers:**
Integrate with the interaction hook's click-vs-drag:
- **mousedown:** Record position in hook (hook handles this via its own mousedown listener). Keep the existing pan logic BUT integrate threshold: do NOT start panning immediately. Only pan after mouse moves beyond CLICK_DRAG_THRESHOLD.
- The interaction hook handles mousedown/mouseup for click detection. The pan logic needs to coexist: approach is to let the hook handle mousedown/mouseup/mousemove for hit detection and click discrimination, and the hook internally manages drag threshold. If distance > threshold, hook sets a `isDragging` flag and delegates pan to a `onPan(dx, dy)` callback. HiveCanvas provides this callback to update camera.

  **Cleaner approach:** Move pan logic INTO the interaction hook. The hook already handles mousedown/mousemove/mouseup. It can manage pan state internally:
  - mousedown: record position, set potential drag.
  - mousemove: if distance > CLICK_DRAG_THRESHOLD, set isDragging=true, start panning (update camera via cameraRef), call render(). Also do hit detection for cursor changes.
  - mouseup: if isDragging was true, stop drag, set cursor back. If not dragging (distance < threshold), treat as click (hit detect + select).
  - Cursor: 'pointer' if over a node and not dragging, 'grabbing' if dragging, 'grab' otherwise.

  This means the existing `useEffect` for pan in HiveCanvas.tsx should be REMOVED. All mouse interaction goes through the hook.

**7. Add pinch-to-zoom via Pointer Events:**
In HiveCanvas or in the interaction hook, add pinch-to-zoom support:
```typescript
const pointerCacheRef = useRef<Map<number, PointerEvent>>(new Map());
const prevPinchDistRef = useRef<number>(-1);
```
- `pointerdown`: add to cache
- `pointermove`: update cache, if 2 pointers: compute distance, apply zoom delta to cameraRef, call render + onCameraChange
- `pointerup / pointercancel`: remove from cache, reset prevPinchDist if < 2 pointers
- Set `touch-action: none` on canvas to prevent browser gestures.

This can live in the interaction hook (add pointer event handlers alongside mouse handlers).

**8. Keep wheel zoom in HiveCanvas or move to hook:**
For consistency, keep wheel zoom as a separate useEffect in HiveCanvas (it's already there and works). Just update it to:
- Import constants from hive-constants.
- Call `interaction.onCameraChange()` after camera mutation.

**9. Import cleanup:**
- Import `Camera`, `FitTransform` from `./hive-types`
- Import `MIN_ZOOM`, `MAX_ZOOM`, `ZOOM_SENSITIVITY` from `./hive-constants`
- Import `useHiveInteraction` from `./use-hive-interaction`
- Import `HiveNodeOverlay` from `./HiveNodeOverlay`
- Import `Icon` from `@/components/primitives/Icon`

**10. Canvas touch-action:**
Add `style={{ touchAction: 'none' }}` to the canvas element to prevent default touch/gesture behavior that would conflict with pinch-to-zoom.
  </action>
  <verify>
    - `pnpm exec tsc --noEmit` passes
    - `pnpm build` succeeds
    - `grep "useHiveInteraction" src/components/hive/HiveCanvas.tsx` confirms hook integration
    - `grep "HiveNodeOverlay" src/components/hive/HiveCanvas.tsx` confirms overlay rendering
    - `grep "isCameraMoved" src/components/hive/HiveCanvas.tsx` confirms reset button
    - `grep "pointerdown\|pointermove" src/components/hive` confirms pinch-to-zoom events
    - Dev server starts without errors: `pnpm dev` (check console)
  </verify>
  <done>
    HiveCanvas.tsx integrates useHiveInteraction, renders HiveNodeOverlay when a node is selected, shows reset button when camera is moved, supports pinch-to-zoom, passes interaction state to renderer. All mouse/pointer events flow through the interaction hook. Canvas wrapped in positioned container div. Build compiles clean.
  </done>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` passes
2. `pnpm build` succeeds
3. HiveCanvas renders canvas inside a container div with overlay and reset button
4. useHiveInteraction hook is wired up with all required refs
5. renderHive receives interaction state from hook
6. HiveNodeOverlay renders GlassCard with node info when selected
7. Reset button appears only when camera has been moved
8. Pinch-to-zoom handler exists (pointer events)
9. Dev server starts without runtime errors
</verification>

<success_criteria>
- Hovering nodes dims unrelated ones visually
- Clicking a node opens GlassCard overlay with node info near the clicked node
- Overlay dismisses via close button, clicking elsewhere, or clicking another node
- Overlay repositions during zoom/pan (stays attached to node)
- Pinch-to-zoom and scroll-wheel zoom both work
- Reset button appears when zoomed/panned, resets to default view on click
- Cursor changes: pointer on node, grab on empty space, grabbing while dragging
- No console errors during interaction
</success_criteria>

<output>
After completion, create `.planning/phases/49-hive-interactions/49-03-SUMMARY.md`
</output>
