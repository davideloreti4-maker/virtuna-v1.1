---
phase: 05-test-coverage
plan: 07
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/lib/engine/__tests__/deepseek.test.ts
autonomous: true

must_haves:
  truths:
    - "Circuit breaker starts in closed state (isCircuitOpen() returns false)"
    - "Circuit breaker opens after 3 consecutive failures"
    - "Open circuit breaker blocks requests (isCircuitOpen() returns true)"
    - "Circuit breaker transitions to half-open after backoff period"
    - "Successful request in half-open state resets to closed"
    - "Failed request in half-open state reopens with increased backoff"
    - "Zod validation rejects malformed DeepSeek responses"
  artifacts:
    - path: "src/lib/engine/__tests__/deepseek.test.ts"
      provides: "Unit tests for circuit breaker state machine and Zod response parsing"
      min_lines: 80
  key_links:
    - from: "src/lib/engine/__tests__/deepseek.test.ts"
      to: "src/lib/engine/deepseek.ts"
      via: "import isCircuitOpen, resetCircuitBreaker, reasonWithDeepSeek"
      pattern: "import.*from.*deepseek"
---

<objective>
Write unit tests for deepseek.ts covering circuit breaker state transitions and Zod response validation.

Purpose: Circuit breaker prevents cascading failures when DeepSeek is down. Zod parsing ensures structural correctness.
Output: deepseek.test.ts with state machine transition tests and validation tests.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-test-coverage/05-RESEARCH.md
@.planning/phases/05-test-coverage/05-01-SUMMARY.md
@src/lib/engine/deepseek.ts
@src/lib/engine/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Unit tests for circuit breaker state transitions</name>
  <files>src/lib/engine/__tests__/deepseek.test.ts</files>
  <action>
Create `src/lib/engine/__tests__/deepseek.test.ts`.

Mock all external dependencies BEFORE importing the module under test:
- `vi.mock("@/lib/logger", ...)` — createLogger returns stub (debug/info/warn/error/child as vi.fn())
- `vi.mock("@sentry/nextjs", ...)` — captureException, addBreadcrumb as vi.fn()
- `vi.mock("openai", ...)` — default export is a class mock: `vi.fn(() => ({ chat: { completions: { create: vi.fn() } } }))`
- `vi.mock("@google/genai", ...)` — `GoogleGenAI: vi.fn(() => ({ models: { generateContent: vi.fn() } }))`
- `vi.mock("node:fs", ...)` — `promises: { readFile: vi.fn().mockResolvedValue('{}') }`
- `vi.mock("node:path", ...)` — `join: vi.fn((...args) => args.join("/")), dirname: vi.fn(() => "/mock")`

Import `isCircuitOpen`, `resetCircuitBreaker`, `reasonWithDeepSeek` from `../deepseek`.
Import factory functions from `./factories`.

Use `vi.useFakeTimers()` in beforeEach and `vi.useRealTimers()` in afterEach.
Call `resetCircuitBreaker()` in beforeEach to reset state between tests.

**describe('circuit breaker state transitions'):**

1. **Starts in closed state**: After resetCircuitBreaker(), `isCircuitOpen()` returns false.

2. **Opens after 3 consecutive failures**: Mock the OpenAI client's `chat.completions.create` to reject. Call `reasonWithDeepSeek(context)` 3+ times (catching errors). After 3 failures, `isCircuitOpen()` returns true.

   To set up context for reasonWithDeepSeek, use:
   ```typescript
   const context = {
     input: { input_mode: "text" as const, content_text: "test", content_type: "post" as const },
     gemini_analysis: makeGeminiAnalysis(),
     rule_result: makeRuleScoreResult(),
     trend_enrichment: makeTrendEnrichment(),
   };
   ```

   Mock the OpenAI create method to throw network errors (e.g., `new Error("503 Service Unavailable")`).
   Also mock `loadCalibrationData` by mocking `node:fs` readFile to return valid calibration JSON.

3. **Open circuit returns null**: After opening the circuit, `reasonWithDeepSeek(context)` returns null immediately (no API call made).

4. **Half-open after backoff**: Open the circuit (3 failures). Advance time past the first backoff (1000ms): `vi.advanceTimersByTime(1001)`. Now `isCircuitOpen()` returns false (transitioned to half-open).

5. **Success in half-open resets to closed**: After transitioning to half-open, mock a successful API response. Call `reasonWithDeepSeek(context)` — should succeed. After success, `isCircuitOpen()` returns false (back to closed).

6. **Failure in half-open reopens with higher backoff**: After half-open, mock another failure. Call `reasonWithDeepSeek(context)`. Circuit should reopen with 3000ms backoff (second level). Advance 1000ms — still open. Advance another 2001ms — half-open again.

For the successful response mock, return:
```typescript
{
  choices: [{ message: { content: JSON.stringify(makeDeepSeekReasoning()) } }],
  usage: { prompt_tokens: 1000, completion_tokens: 500 },
}
```

For the calibration data mock, have `node:fs` promises.readFile resolve with a minimal valid calibration JSON string containing primary_kpis, virality_tiers, viral_vs_average, and duration_analysis.
  </action>
  <verify>Run `pnpm test src/lib/engine/__tests__/deepseek.test.ts` — circuit breaker tests pass.</verify>
  <done>Circuit breaker tests cover: closed start, opens after 3 failures, blocks when open, half-open after backoff, success resets, failure in half-open escalates backoff</done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for DeepSeek Zod response parsing</name>
  <files>src/lib/engine/__tests__/deepseek.test.ts</files>
  <action>
In the same deepseek.test.ts file, test the Zod schema validation directly using the `DeepSeekResponseSchema` from types.ts (it's the schema used internally by parseDeepSeekResponse which is private, but we can test the schema directly).

Import `DeepSeekResponseSchema` from `../types`.

**describe('DeepSeek response validation'):**

1. **Valid response parses**: Create a valid DeepSeekReasoning-shaped object. `DeepSeekResponseSchema.safeParse(obj).success` is true.

2. **Missing behavioral_predictions fails**: Object without behavioral_predictions. safeParse returns success: false.

3. **Missing component_scores fails**: Object without component_scores. safeParse returns success: false.

4. **Score out of range (0-10) fails**: component_scores.hook_effectiveness = 15. safeParse fails.

5. **Invalid confidence value fails**: confidence = "extreme" (not "high"/"medium"/"low"). safeParse fails.

6. **Empty suggestions fails**: suggestions = [] (min 1 required). safeParse fails.

7. **Warnings default to empty array**: Object with no warnings field. safeParse succeeds with warnings = [].

8. **Markdown-fenced JSON**: Test that the internal stripFences logic works by testing through reasonWithDeepSeek with a response wrapped in ```json ... ```. (Alternative: Since parseDeepSeekResponse is private, test by mocking the OpenAI response to return fenced JSON — if the call succeeds, stripFences worked.)
  </action>
  <verify>Run `pnpm test src/lib/engine/__tests__/deepseek.test.ts` — all tests pass.</verify>
  <done>Zod validation tests cover: valid input, missing required fields, out-of-range scores, invalid enums, empty suggestions, default warnings</done>
</task>

</tasks>

<verification>
1. `pnpm test src/lib/engine/__tests__/deepseek.test.ts` passes all tests
2. Circuit breaker: 6 state transition tests
3. Zod validation: 7-8 schema tests
4. Fake timers properly managed (useFakeTimers/useRealTimers)
5. Module state reset between tests via resetCircuitBreaker()
</verification>

<success_criteria>
Circuit breaker state machine is fully tested (closed/open/half-open transitions, backoff escalation, success reset). Zod parsing rejects malformed responses and accepts valid ones.
</success_criteria>

<output>
After completion, create `.planning/phases/05-test-coverage/05-07-SUMMARY.md`
</output>
