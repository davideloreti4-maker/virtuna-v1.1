---
phase: 05-test-coverage
plan: 06
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/lib/engine/__tests__/fuzzy.test.ts
  - src/lib/engine/__tests__/rules.test.ts
autonomous: true

must_haves:
  truths:
    - "`jaroWinklerSimilarity()` returns 1.0 for identical strings and 0.0 for empty string"
    - "`bestFuzzyMatch()` returns score 1.0 for exact substring match"
    - "`bestFuzzyMatch()` returns matched:false for score below threshold"
    - "All 13+ regex patterns in matchesPattern return correct positive and negative results"
    - "`scoreContentAgainstRules()` normalizes total score to 0-100 range"
  artifacts:
    - path: "src/lib/engine/__tests__/fuzzy.test.ts"
      provides: "Unit tests for jaroWinklerSimilarity and bestFuzzyMatch"
      min_lines: 60
    - path: "src/lib/engine/__tests__/rules.test.ts"
      provides: "Unit tests for regex pattern matching and scoreContentAgainstRules"
      min_lines: 100
  key_links:
    - from: "src/lib/engine/__tests__/fuzzy.test.ts"
      to: "src/lib/engine/fuzzy.ts"
      via: "import jaroWinklerSimilarity, bestFuzzyMatch"
      pattern: "import.*from.*fuzzy"
    - from: "src/lib/engine/__tests__/rules.test.ts"
      to: "src/lib/engine/rules.ts"
      via: "import scoreContentAgainstRules, loadActiveRules"
      pattern: "import.*from.*rules"
---

<objective>
Write unit tests for fuzzy.ts (Jaro-Winkler similarity and fuzzy matching) and rules.ts (13+ regex patterns and rule scoring).

Purpose: Fuzzy matching drives trend detection accuracy; rule patterns are the deterministic scoring backbone.
Output: fuzzy.test.ts and rules.test.ts with comprehensive positive/negative test cases.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/engine/fuzzy.ts
@src/lib/engine/rules.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Unit tests for fuzzy.ts — Jaro-Winkler and bestFuzzyMatch</name>
  <files>src/lib/engine/__tests__/fuzzy.test.ts</files>
  <action>
Create `src/lib/engine/__tests__/fuzzy.test.ts`. No mocks needed — fuzzy.ts is fully pure.

Import `jaroWinklerSimilarity`, `bestFuzzyMatch` from `../fuzzy`.

**describe('jaroWinklerSimilarity'):**

1. **Identical strings**: `jaroWinklerSimilarity("hello", "hello")` returns 1.0.
2. **Case insensitive**: `jaroWinklerSimilarity("Hello", "hello")` returns 1.0.
3. **Empty string**: `jaroWinklerSimilarity("", "hello")` returns 0.0. Also `jaroWinklerSimilarity("", "")` returns 1.0 (identical).
4. **Completely different**: `jaroWinklerSimilarity("abc", "xyz")` returns a low value (< 0.5).
5. **Similar strings**: `jaroWinklerSimilarity("martha", "marhta")` should be high (> 0.9 — classic Jaro-Winkler test case).
6. **Common prefix boost**: `jaroWinklerSimilarity("prefix_abc", "prefix_xyz")` should be higher than `jaroWinklerSimilarity("abc_prefix", "xyz_prefix")` due to Winkler prefix boost.
7. **Score always 0-1**: Test several pairs. Assert all results >= 0 and <= 1.

**describe('bestFuzzyMatch'):**

8. **Exact substring match returns 1.0**: `bestFuzzyMatch("viral sound", "This viral sound is trending")` returns `{ score: 1.0, matched: true }`.
9. **No match below threshold**: `bestFuzzyMatch("completely unrelated", "hello world", 0.7)` returns `matched: false`.
10. **Empty target**: `bestFuzzyMatch("", "some content")` returns `{ score: 0, matched: false }`.
11. **Empty content**: `bestFuzzyMatch("target", "")` returns `{ score: 0, matched: false }`.
12. **Custom threshold**: `bestFuzzyMatch("sound", "soudn typo", 0.5)` — with low threshold, likely matches. With 0.95 threshold, likely doesn't.
13. **Multi-word target in content**: `bestFuzzyMatch("trending audio", "This is a trending audio clip for TikTok")` returns `{ score: 1.0, matched: true }` (exact substring).
14. **Fuzzy match (close but not exact)**: `bestFuzzyMatch("trending", "trnding")` — should produce a score above 0.7 (near match).
  </action>
  <verify>Run `pnpm test src/lib/engine/__tests__/fuzzy.test.ts` — all tests pass.</verify>
  <done>fuzzy.test.ts covers jaroWinklerSimilarity (7 cases) and bestFuzzyMatch (7 cases) including edge cases, thresholds, and exact/fuzzy matching</done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for rules.ts — regex patterns and scoreContentAgainstRules</name>
  <files>src/lib/engine/__tests__/rules.test.ts</files>
  <action>
Create `src/lib/engine/__tests__/rules.test.ts`.

Mock external dependencies:
- `vi.mock("@/lib/logger", ...)` — createLogger returns stub
- `vi.mock("@sentry/nextjs", ...)` — captureException as vi.fn()
- `vi.mock("@/lib/supabase/service", ...)` — createServiceClient as vi.fn()
- `vi.mock("@/lib/cache", ...)` — createCache returns { get: vi.fn(() => null), set: vi.fn(), invalidate: vi.fn() }
- `vi.mock("openai", ...)` — default export as vi.fn() (constructor)

Import `scoreContentAgainstRules` from `../rules`.

Since `matchesPattern` is private, test it indirectly through `scoreContentAgainstRules` by building Rule objects with specific patterns.

Create a helper function to build a mock Rule:
```typescript
function makeRule(name: string, pattern: string, overrides?: Partial<Rule>): Rule {
  return {
    id: `rule-${name}`,
    name,
    description: null,
    category: "content",
    pattern,
    score_modifier: 10,
    platform: null,
    evaluation_prompt: null,
    evaluation_tier: "regex" as const,
    weight: 1,
    max_score: 10,
    ...overrides,
  };
}
```

**describe('regex pattern matching via scoreContentAgainstRules'):**

Test each pattern with a positive and negative case:

1. **question_hook**: Positive: "What if you tried this?" Negative: "This is great."
2. **curiosity_gap**: Positive: "The secret to success" Negative: "I went to the store"
3. **negative_bias**: Positive: "Stop making this mistake" Negative: "I love cooking"
4. **bold_claim**: Positive: "Everyone needs this" Negative: "Some people might like this"
5. **story_hook**: Positive: "I remember when I first tried" Negative: "Product review 2026"
6. **loop_structure**: Always returns false — both inputs should not match.
7. **payoff_delay**: Positive: "Wait for it..." Negative: "Here is the result"
8. **pattern_interrupt**: Positive: "But wait, there's more" Negative: "Cooking recipe step 1"
9. **info_density**: Positive: (>50 words text) Negative: "Short text"
10. **emotional_arc**: Always returns false — verify no match.
11. **short_duration**: Positive: (< 300 chars) Negative: (> 300 chars)
12. **caption_hook**: Positive: "This changed everything." Negative: (very long first sentence >80 chars before first punctuation)
13. **cta_clarity**: Positive: "Follow me for more tips" Negative: "The weather is nice today"
14. **authenticity**: Positive: "I personally tried this" Negative: "Studies show that..."

**describe('scoreContentAgainstRules — scoring'):**

15. **Returns 0-100 rule_score**: Pass multiple rules, assert rule_score >= 0 and <= 100.
16. **Empty rules returns 50**: Pass empty rules array. Assert rule_score is 50 (the default when totalMaxScore === 0).
17. **matched_rules contains matched rule details**: Pass a rule that matches. Assert matched_rules has entry with rule_id, rule_name, score, max_score, tier "regex".
18. **Unmatched rules not in matched_rules**: Pass a rule that doesn't match. Assert matched_rules is empty.
  </action>
  <verify>Run `pnpm test src/lib/engine/__tests__/rules.test.ts` — all tests pass.</verify>
  <done>rules.test.ts covers all 13+ regex patterns (positive + negative), scoreContentAgainstRules scoring, and matched_rules shape</done>
</task>

</tasks>

<verification>
1. `pnpm test src/lib/engine/__tests__/fuzzy.test.ts` passes all tests
2. `pnpm test src/lib/engine/__tests__/rules.test.ts` passes all tests
3. All 13+ regex patterns tested with positive and negative cases
4. Fuzzy matching edge cases covered (empty input, thresholds, exact vs fuzzy)
</verification>

<success_criteria>
Fuzzy matching and rule evaluation are comprehensively tested. Every regex pattern has at least one positive and one negative test case. Fuzzy matching handles edge cases and threshold variations.
</success_criteria>

<output>
After completion, create `.planning/phases/05-test-coverage/05-06-SUMMARY.md`
</output>
