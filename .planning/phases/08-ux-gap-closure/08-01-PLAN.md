---
phase: 08-ux-gap-closure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/analyze/route.ts
  - src/components/app/simulation/loading-phases.tsx
  - src/app/(app)/dashboard/dashboard-client.tsx
  - src/app/(app)/dashboard/page.tsx
  - src/components/app/test-creation-flow.tsx
  - src/components/trending/video-detail-modal.tsx
  - src/components/app/content-form.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "The simulation theater never reveals results before 4.5s have elapsed since analysis submission"
    - "SSE phase events arrive spread across actual pipeline stages — not all at once before pipeline runs"
    - "LoadingPhases displays the phaseMessage text from SSE events (no underscore prefix, no unused prop)"
    - "Clicking Analyze in trending video detail modal navigates to /dashboard?url=<encoded_url> and pre-fills the content form"
    - "No reference to /viral-predictor exists anywhere in the codebase"
  artifacts:
    - path: "src/app/api/analyze/route.ts"
      provides: "SSE events interleaved with pipeline stages"
      contains: "send.*phase.*analyzing.*await.*Promise\\.all"
    - path: "src/components/app/simulation/loading-phases.tsx"
      provides: "Phase message display"
      contains: "phaseMessage"
    - path: "src/app/(app)/dashboard/dashboard-client.tsx"
      provides: "Minimum theater duration enforcement and URL pre-fill"
      contains: "MINIMUM_THEATER_MS"
    - path: "src/app/(app)/dashboard/page.tsx"
      provides: "Suspense boundary for useSearchParams"
      contains: "Suspense"
    - path: "src/components/trending/video-detail-modal.tsx"
      provides: "Fixed analyze routing"
      contains: "/dashboard?url="
  key_links:
    - from: "src/app/api/analyze/route.ts"
      to: "src/lib/engine/gemini.ts, rules.ts, trends.ts, deepseek.ts, aggregator.ts"
      via: "Inlined pipeline stages with SSE events between each stage"
      pattern: "send.*phase.*await"
    - from: "src/components/trending/video-detail-modal.tsx"
      to: "src/app/(app)/dashboard/dashboard-client.tsx"
      via: "router.push(/dashboard?url=) -> useSearchParams reads url param"
      pattern: "dashboard\\?url="
    - from: "src/app/(app)/dashboard/dashboard-client.tsx"
      to: "src/components/app/content-form.tsx"
      via: "initialContent prop passed from URL search param"
      pattern: "initialContent"
---

<objective>
Close the 2 remaining unsatisfied requirements from the milestone audit: enforce a minimum 4.5-second theater duration (UX-02) and fix the broken analyze button routing from trending (UX-08). Also fix SSE phase event timing so events are spread across actual pipeline stages, wire the unused `phaseMessage` prop in LoadingPhases, and add URL pre-fill for the dashboard content form.

Purpose: These are the last gaps blocking milestone completion — the simulation theater currently reveals results instantly when the backend is fast, SSE phases all fire before the pipeline runs, the phaseMessage prop is silently discarded, and the Analyze button navigates to a non-existent `/viral-predictor` route.

Output: 6-7 files modified, all gap closure requirements satisfied.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-ux-gap-closure/08-RESEARCH.md

@src/app/api/analyze/route.ts
@src/lib/engine/pipeline.ts
@src/hooks/queries/use-analyze.ts
@src/components/app/simulation/loading-phases.tsx
@src/app/(app)/dashboard/dashboard-client.tsx
@src/app/(app)/dashboard/page.tsx
@src/components/app/test-creation-flow.tsx
@src/components/trending/video-detail-modal.tsx
@src/components/app/content-form.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Spread SSE phase events across pipeline stages and wire phaseMessage in LoadingPhases</name>
  <files>
    src/app/api/analyze/route.ts
    src/components/app/simulation/loading-phases.tsx
  </files>
  <action>
**analyze/route.ts — Inline pipeline stages with interleaved SSE events:**

Replace the current pattern where all 4 `send("phase", ...)` calls fire synchronously before `runPredictionPipeline()` (lines 50-59). Instead, inline the pipeline stages directly in the SSE handler so events are sent BETWEEN actual work. Do NOT import or call `runPredictionPipeline` anymore — import the individual stage functions directly:

```typescript
import { analyzeWithGemini } from "@/lib/engine/gemini";
import { reasonWithDeepSeek } from "@/lib/engine/deepseek";
import { loadActiveRules, scoreContentAgainstRules } from "@/lib/engine/rules";
import { enrichWithTrends } from "@/lib/engine/trends";
import { aggregateScores } from "@/lib/engine/aggregator";
import { AnalysisInputSchema } from "@/lib/engine/types";
```

Remove the `runPredictionPipeline` import.

Inside the `start(controller)` block, after validating input:

1. `send("phase", { phase: "analyzing", message: "Analyzing content structure and patterns..." })` — then `await Promise.all([analyzeWithGemini(validated), loadActiveRules(service, validated.content_type), enrichWithTrends(service, validated)])`
2. `send("phase", { phase: "matching", message: "Matching against rule library and trends..." })` — then `await scoreContentAgainstRules(validated.content_text, rules)`
3. `send("phase", { phase: "simulating", message: "Simulating audience reactions..." })` — then `await reasonWithDeepSeek({input: validated, gemini_analysis: geminiResult.analysis, rule_result: ruleResult, trend_enrichment: trendEnrichment})`
4. `send("phase", { phase: "generating", message: "Generating predictions and insights..." })` — then `aggregateScores(...)` synchronously

Track `performance.now()` at the start for latency calculation. Create `const service = createServiceClient()` BEFORE the pipeline stages (it's needed for `loadActiveRules` and `enrichWithTrends`). Keep the DB save (`analysis_results` insert) and usage tracking (`usage_tracking` upsert) AFTER aggregation but BEFORE `send("complete", result)` — exactly as current code does.

The validation step (`AnalysisInputSchema.parse(body)`) should happen INSIDE the stream's `start()`, using `body` which is already parsed from `request.json()` above. Use `const validated = AnalysisInputSchema.parse(body)` (not `safeParse` — the `try/catch` in the stream handles errors).

**loading-phases.tsx — Wire phaseMessage prop:**

1. On line 127, change `phaseMessage: _phaseMessage` to just `phaseMessage` (remove the underscore alias)
2. Add the phaseMessage display inside the return JSX, as a `<p>` element above the `<AnimatePresence>` block:
   ```tsx
   {phaseMessage && (
     <p className="text-sm text-foreground-muted text-center animate-pulse">
       {phaseMessage}
     </p>
   )}
   ```
3. This goes BEFORE the `<AnimatePresence mode="popLayout">` block inside the outer `<div className="space-y-3">`
  </action>
  <verify>
    1. `npx tsc --noEmit` passes — no TypeScript errors
    2. `grep -n "runPredictionPipeline" src/app/api/analyze/route.ts` returns nothing (import removed)
    3. `grep -n "_phaseMessage" src/components/app/simulation/loading-phases.tsx` returns nothing (underscore removed)
    4. `grep -n "phaseMessage" src/components/app/simulation/loading-phases.tsx` returns matches showing the prop is used in JSX
  </verify>
  <done>
    SSE events are interleaved with actual pipeline stages (analyzing -> Gemini+rules+trends parallel, matching -> rule scoring, simulating -> DeepSeek, generating -> aggregation). LoadingPhases renders the phaseMessage text from SSE events.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enforce 4.5s minimum theater duration with cancel safety</name>
  <files>
    src/app/(app)/dashboard/dashboard-client.tsx
    src/components/app/test-creation-flow.tsx
  </files>
  <action>
**Both files need the same pattern applied to their `handleContentSubmit` and `handleSurveySubmit` handlers.**

Define a constant at the top of each file (or import from a shared location — but since there are only 2 consumers, inline is fine):

```typescript
const MINIMUM_THEATER_MS = 4500;
```

**dashboard-client.tsx:**

1. Add `useRef` to the React import
2. Add a ref to track cancellation: `const isCancelledRef = useRef(false);`
3. In `handleContentSubmit`:
   - Add `const theatreStart = Date.now();` and `isCancelledRef.current = false;` at the top (before `setSubmittedContent`)
   - Change the `onSuccess` callback to be async and enforce minimum duration:
     ```typescript
     onSuccess: async () => {
       const elapsed = Date.now() - theatreStart;
       const remaining = MINIMUM_THEATER_MS - elapsed;
       if (remaining > 0) {
         await new Promise((resolve) => setTimeout(resolve, remaining));
       }
       if (!isCancelledRef.current) {
         setStatus("viewing-results");
       }
     },
     ```
4. Apply the exact same pattern to `handleSurveySubmit` (it has its own `analyzeMutation.mutate` call with `onSuccess`)
5. Update the cancel handler in the LoadingPhases `onCancel` prop (around line 194): add `isCancelledRef.current = true;` BEFORE the existing `setStatus("filling-form")` and `analyzeMutation.reset()` calls

**test-creation-flow.tsx:**

1. Add `useRef` to the React import
2. Add `const MINIMUM_THEATER_MS = 4500;` at module level (above the component)
3. Add `const isCancelledRef = useRef(false);`
4. Apply the same pattern to `handleContentSubmit` (lines 77-93):
   - Add `const theatreStart = Date.now();` and `isCancelledRef.current = false;`
   - Wrap `onSuccess` in async with minimum duration wait + cancel check
5. Apply to `handleSurveySubmit` (lines 97-116) — same pattern
6. TestCreationFlow doesn't currently have a cancel button during "simulating" state (it shows a plain Spinner with no cancel). This is acceptable — the `isCancelledRef` is still needed as a safety mechanism in case the component unmounts.

**Important:** The `onSuccess` callback in TanStack Query's `mutate()` accepts async functions — they just won't block the mutation lifecycle. The `await` inside `onSuccess` will correctly delay the `setStatus("viewing-results")` call, which is the desired behavior.
  </action>
  <verify>
    1. `npx tsc --noEmit` passes — no TypeScript errors
    2. `grep -rn "MINIMUM_THEATER_MS" src/` returns matches in both dashboard-client.tsx and test-creation-flow.tsx
    3. `grep -n "isCancelledRef" src/app/\\(app\\)/dashboard/dashboard-client.tsx` returns matches showing ref is created and used
    4. `grep -n "theatreStart" src/app/\\(app\\)/dashboard/dashboard-client.tsx` returns matches in both handlers
  </verify>
  <done>
    Both DashboardClient and TestCreationFlow enforce a minimum 4.5s theater duration. Results are never revealed before 4.5s even if the backend responds instantly. Cancel during the wait period prevents stale status transition via isCancelledRef.
  </done>
</task>

<task type="auto">
  <name>Task 3: Fix analyze button routing and add URL pre-fill to dashboard</name>
  <files>
    src/components/trending/video-detail-modal.tsx
    src/app/(app)/dashboard/dashboard-client.tsx
    src/app/(app)/dashboard/page.tsx
    src/components/app/content-form.tsx
  </files>
  <action>
**video-detail-modal.tsx — Fix routing:**

On line 131, change:
```typescript
const url = `/viral-predictor?url=${encodeURIComponent(video.tiktokUrl)}`;
```
to:
```typescript
const url = `/dashboard?url=${encodeURIComponent(video.tiktokUrl)}`;
```

That's the only change in this file.

**content-form.tsx — Add initialContent prop:**

1. Add `initialContent?: string` to the `ContentFormProps` interface
2. Destructure `initialContent` in the component function parameters
3. Add a `useEffect` to pre-fill content when `initialContent` is provided (similar to the existing history pre-fill pattern at lines 77-81):
   ```typescript
   useEffect(() => {
     if (initialContent) {
       setContent(initialContent);
     }
   }, [initialContent]);
   ```
   Place this AFTER the existing history pre-fill `useEffect` (line 81). The initialContent takes effect only once (on mount or when the prop changes). It should NOT override content while the user is typing — the `[initialContent]` dependency ensures it only fires when the prop value changes.

**dashboard-client.tsx — Read URL param and pre-fill:**

1. Add `import { useSearchParams } from "next/navigation";` to imports
2. Inside `DashboardClient`, add: `const searchParams = useSearchParams();` and `const urlParam = searchParams.get("url");`
3. Add a `useEffect` to auto-start the flow when a URL param is present:
   ```typescript
   useEffect(() => {
     if (urlParam && currentStatus === "idle") {
       setTestType("tiktok-script" as TestType);
       setStatus("filling-form");
     }
   }, [urlParam]); // eslint-disable-line react-hooks/exhaustive-deps
   ```
   Place this after the hydration `useEffect` blocks. The `// eslint-disable-line` is needed because we intentionally only want this to run when `urlParam` changes, not when `currentStatus` changes.
4. Pass `initialContent` to `ContentForm` when rendering it (around line 184):
   ```tsx
   <ContentForm
     testType={currentTestType}
     onChangeType={handleChangeType}
     onSubmit={handleContentSubmit}
     initialContent={urlParam ?? undefined}
   />
   ```

**page.tsx — Add Suspense boundary:**

Wrap `DashboardClient` in a `<Suspense>` boundary (required by Next.js 15 for components using `useSearchParams`):

```typescript
import type { Metadata } from "next";
import { Suspense } from "react";
import { DashboardClient } from "./dashboard-client";

export const metadata: Metadata = {
  title: "Dashboard | Artificial Societies",
  description: "Manage your AI personas and research simulations.",
};

export default function DashboardPage() {
  return (
    <Suspense fallback={null}>
      <DashboardClient />
    </Suspense>
  );
}
```

Using `fallback={null}` to avoid any flash — the dashboard renders the same content either way, `useSearchParams` just needs the boundary to exist.
  </action>
  <verify>
    1. `npx tsc --noEmit` passes — no TypeScript errors
    2. `grep -rn "viral-predictor" src/` returns NO matches (completely removed)
    3. `grep -n "dashboard?url=" src/components/trending/video-detail-modal.tsx` returns a match
    4. `grep -n "useSearchParams" src/app/\\(app\\)/dashboard/dashboard-client.tsx` returns a match
    5. `grep -n "Suspense" src/app/\\(app\\)/dashboard/page.tsx` returns a match
    6. `grep -n "initialContent" src/components/app/content-form.tsx` returns matches showing prop in interface and useEffect
  </verify>
  <done>
    Clicking "Analyze" in the trending video detail modal navigates to `/dashboard?url=<encoded_url>`. The dashboard reads the URL param, auto-selects "tiktok-script" type, transitions to "filling-form" status, and pre-fills the ContentForm with the video URL. No reference to `/viral-predictor` exists anywhere in the codebase.
  </done>
</task>

</tasks>

<verification>
After all 3 tasks complete:

1. **TypeScript compilation:** `npx tsc --noEmit` passes with zero errors
2. **No viral-predictor references:** `grep -rn "viral-predictor" src/` returns empty
3. **No unused phaseMessage:** `grep -rn "_phaseMessage" src/` returns empty
4. **SSE events interleaved:** Verify `route.ts` has `send("phase", ...)` calls between `await` calls (not all grouped before pipeline)
5. **Minimum duration enforced:** Both `dashboard-client.tsx` and `test-creation-flow.tsx` contain `MINIMUM_THEATER_MS = 4500`
6. **Cancel safety:** `dashboard-client.tsx` contains `isCancelledRef` usage
7. **URL pre-fill wired:** `dashboard-client.tsx` contains `useSearchParams` and passes `initialContent` to `ContentForm`
8. **Suspense boundary:** `page.tsx` wraps `DashboardClient` in `<Suspense>`
</verification>

<success_criteria>
- The simulation theater never reveals results before 4.5 seconds have elapsed since analysis submission
- SSE phase events are spread across pipeline stages (analyzing -> parallel work, matching -> rule scoring, simulating -> DeepSeek, generating -> aggregation)
- LoadingPhases displays the phaseMessage text from SSE events
- Clicking "Analyze" in trending navigates to `/dashboard?url=<video_url>` and pre-fills the content form
- No reference to `/viral-predictor` remains in the codebase
- Cancel during minimum duration wait does not produce stale status transitions
</success_criteria>

<output>
After completion, create `.planning/phases/08-ux-gap-closure/08-01-SUMMARY.md`
</output>
