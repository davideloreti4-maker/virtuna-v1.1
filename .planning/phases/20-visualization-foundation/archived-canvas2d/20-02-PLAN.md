---
phase: 20-visualization-foundation
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - src/components/app/orb-renderer.ts
  - src/components/app/progressive-visualization.tsx
  - src/lib/visualization-types.ts
autonomous: true

must_haves:
  truths:
    - "Orb renders as a glass-like translucent sphere with white/silver base"
    - "Orb has subtle orange inner glow as accent color"
    - "Orb size is 15-20% of the visualization area"
    - "Orb has subtle soft outer glow effect"
    - "Canvas renders crisply on retina displays"
  artifacts:
    - path: "src/lib/visualization-types.ts"
      provides: "OrbState type and orb configuration constants"
      exports: ["OrbState", "ORB_CONFIG"]
    - path: "src/components/app/orb-renderer.ts"
      provides: "Canvas rendering functions for glass orb"
      exports: ["drawGlassOrb", "createOrbGradient"]
    - path: "src/components/app/progressive-visualization.tsx"
      provides: "Updated component with canvas rendering"
      exports: ["ProgressiveVisualization"]
  key_links:
    - from: "src/components/app/progressive-visualization.tsx"
      to: "src/components/app/orb-renderer.ts"
      via: "import drawGlassOrb"
      pattern: "drawGlassOrb\\("
    - from: "src/components/app/orb-renderer.ts"
      to: "src/lib/visualization-types.ts"
      via: "import OrbState, ORB_CONFIG"
      pattern: "ORB_CONFIG"
---

<objective>
Implement the glass orb rendering with Canvas 2D radial gradients and glow effects.

Purpose: Create the central "AI brain" visual element that is the focal point of the progressive disclosure visualization. The orb should feel like looking into a glass sphere with something alive inside.

Output: Glass-like orb rendering on canvas with proper radial gradients, orange accent glow, and crisp retina display support.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/20-visualization-foundation/20-CONTEXT.md
@.planning/phases/20-visualization-foundation/20-RESEARCH.md
@.planning/phases/20-visualization-foundation/20-01-SUMMARY.md
@src/components/app/network-visualization.tsx (canvas patterns reference)
@src/app/globals.css (design tokens - --color-accent: #E57850)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create visualization types and constants</name>
  <files>src/lib/visualization-types.ts</files>
  <action>
Create types and configuration constants for the visualization:

```typescript
/**
 * Orb animation states for the progressive disclosure visualization
 */
export type OrbState = 'idle' | 'gathering' | 'analyzing' | 'complete';

/**
 * Configuration constants for the orb
 * Orb size is 15-20% of visualization area per CONTEXT.md
 */
export const ORB_CONFIG = {
  // Size as percentage of min(width, height)
  sizePercent: 0.17, // ~17% - middle of 15-20% range

  // Colors - using design tokens values
  baseColor: 'rgba(255, 255, 255, 0.9)', // White/silver base
  midColor: 'rgba(240, 240, 240, 0.7)',  // Mid-tone
  accentColor: 'rgba(229, 120, 80, 0.4)', // Orange accent (#E57850)
  edgeColor: 'rgba(200, 200, 200, 0.2)',  // Transparent edge
  glowColor: 'rgba(229, 120, 80, 0.5)',   // Outer glow

  // Glow settings
  glowBlur: 15, // Subtle soft glow per CONTEXT.md

  // Gradient stops for glass effect (offset from center for light refraction look)
  lightOffsetPercent: 0.3, // 30% offset for inner light source
} as const;

/**
 * Configuration for breathing animation
 */
export const BREATHING_CONFIG = {
  duration: 2500, // 2.5 seconds per CONTEXT.md (2-3 second range)
  scaleMin: 1,
  scaleMax: 1.05,
  glowMin: 0.8,
  glowMax: 1,
} as const;
```
  </action>
  <verify>File exists and TypeScript compiles: `pnpm build`</verify>
  <done>OrbState type and ORB_CONFIG constants are defined with correct values per CONTEXT.md.</done>
</task>

<task type="auto">
  <name>Task 2: Create orb renderer module</name>
  <files>src/components/app/orb-renderer.ts</files>
  <action>
Create the Canvas 2D rendering functions for the glass orb:

```typescript
import { ORB_CONFIG } from "@/lib/visualization-types";

/**
 * Create the radial gradient for the glass orb
 * Uses offset center for light refraction effect
 */
export function createOrbGradient(
  ctx: CanvasRenderingContext2D,
  centerX: number,
  centerY: number,
  radius: number
): CanvasGradient {
  // Offset light source for glass refraction look
  const lightX = centerX - radius * ORB_CONFIG.lightOffsetPercent;
  const lightY = centerY - radius * ORB_CONFIG.lightOffsetPercent;

  const gradient = ctx.createRadialGradient(
    lightX, lightY, 0,  // Inner circle at light source
    centerX, centerY, radius // Outer circle at orb edge
  );

  // Glass-like gradient: bright center -> mid-tone -> orange accent -> transparent edge
  gradient.addColorStop(0, ORB_CONFIG.baseColor);
  gradient.addColorStop(0.3, ORB_CONFIG.midColor);
  gradient.addColorStop(0.6, ORB_CONFIG.accentColor);
  gradient.addColorStop(1, ORB_CONFIG.edgeColor);

  return gradient;
}

/**
 * Draw the glass orb on canvas
 *
 * @param ctx - Canvas 2D context
 * @param centerX - X center coordinate
 * @param centerY - Y center coordinate
 * @param radius - Orb radius
 * @param glowIntensity - Glow intensity multiplier (0-1), default 1
 */
export function drawGlassOrb(
  ctx: CanvasRenderingContext2D,
  centerX: number,
  centerY: number,
  radius: number,
  glowIntensity: number = 1
): void {
  // Use Math.floor to avoid sub-pixel anti-aliasing overhead per RESEARCH.md
  const x = Math.floor(centerX);
  const y = Math.floor(centerY);
  const r = Math.floor(radius);

  // Create and apply gradient
  const gradient = createOrbGradient(ctx, x, y, r);

  // Draw main orb body
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2);
  ctx.fill();

  // Draw outer glow (apply shadowBlur only once, reset immediately per RESEARCH.md)
  ctx.shadowColor = ORB_CONFIG.glowColor;
  ctx.shadowBlur = ORB_CONFIG.glowBlur * glowIntensity;
  ctx.fill();
  ctx.shadowBlur = 0; // Reset immediately for performance

  // Add subtle inner highlight for glass depth
  const highlightGradient = ctx.createRadialGradient(
    x - r * 0.4, y - r * 0.4, 0,
    x - r * 0.4, y - r * 0.4, r * 0.3
  );
  highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
  highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

  ctx.fillStyle = highlightGradient;
  ctx.beginPath();
  ctx.arc(x - r * 0.2, y - r * 0.2, r * 0.4, 0, Math.PI * 2);
  ctx.fill();
}

/**
 * Calculate orb radius based on container dimensions
 * Orb is 15-20% of the visualization area per CONTEXT.md
 */
export function calculateOrbRadius(width: number, height: number): number {
  const minDimension = Math.min(width, height);
  return Math.floor(minDimension * ORB_CONFIG.sizePercent / 2);
}
```

Key implementation details per RESEARCH.md:
- Math.floor() on all coordinates to avoid anti-aliasing overhead
- shadowBlur reset immediately after use
- Offset gradient center for glass light refraction effect
- Inner highlight for depth
  </action>
  <verify>File exists and TypeScript compiles: `pnpm build`</verify>
  <done>Orb renderer module created with drawGlassOrb, createOrbGradient, and calculateOrbRadius functions.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate canvas rendering into ProgressiveVisualization</name>
  <files>src/components/app/progressive-visualization.tsx</files>
  <action>
Update ProgressiveVisualization to use canvas rendering for the orb:

```typescript
"use client";

import { useRef, useState, useCallback, useEffect } from "react";
import { TransformWrapper, TransformComponent } from "react-zoom-pan-pinch";
import { cn } from "@/lib/utils";
import { VisualizationResetButton } from "./visualization-reset-button";
import { drawGlassOrb, calculateOrbRadius } from "./orb-renderer";
import type { OrbState } from "@/lib/visualization-types";

interface ProgressiveVisualizationProps {
  className?: string;
  state?: OrbState;
}

/**
 * ProgressiveVisualization - Canvas-based visualization with pan/zoom support
 *
 * Phase 20: Central orb with glass effect and pan/zoom infrastructure
 * - Canvas 2D for orb rendering with radial gradients
 * - Pan/zoom via react-zoom-pan-pinch
 * - Responsive canvas with ResizeObserver
 * - Crisp retina display support via devicePixelRatio
 */
export function ProgressiveVisualization({
  className,
  state = 'idle'
}: ProgressiveVisualizationProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [hasTransformed, setHasTransformed] = useState(false);
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });

  // Track when user has moved the view
  const handleTransform = useCallback(() => {
    if (!hasTransformed) {
      setHasTransformed(true);
    }
  }, [hasTransformed]);

  // Hide reset button when view is reset
  const handleReset = useCallback(() => {
    setHasTransformed(false);
  }, []);

  // Canvas setup with ResizeObserver pattern from NetworkVisualization
  useEffect(() => {
    const container = containerRef.current;
    const canvas = canvasRef.current;
    if (!container || !canvas) return;

    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    const resizeCanvas = () => {
      const dpr = window.devicePixelRatio || 1;
      const rect = container.getBoundingClientRect();

      // Set canvas dimensions accounting for devicePixelRatio
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      canvas.style.width = `${rect.width}px`;
      canvas.style.height = `${rect.height}px`;
      ctx.scale(dpr, dpr);

      setDimensions({ width: rect.width, height: rect.height });
    };

    const resizeObserver = new ResizeObserver(resizeCanvas);
    resizeObserver.observe(container);
    resizeCanvas();

    return () => {
      resizeObserver.disconnect();
    };
  }, []);

  // Draw orb on canvas
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || dimensions.width === 0) return;

    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    // Clear canvas
    const dpr = window.devicePixelRatio || 1;
    ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);

    // Calculate orb position and size
    const centerX = dimensions.width / 2;
    const centerY = dimensions.height / 2;
    const radius = calculateOrbRadius(dimensions.width, dimensions.height);

    // Draw the glass orb
    drawGlassOrb(ctx, centerX, centerY, radius, 1);
  }, [dimensions, state]);

  return (
    <div ref={containerRef} className={cn("absolute inset-0 overflow-hidden", className)}>
      <TransformWrapper
        initialScale={1}
        minScale={0.5}
        maxScale={3}
        centerOnInit={true}
        wheel={{ smoothStep: 0.05 }}
        panning={{ velocityDisabled: true }}
        pinch={{ disabled: false }}
        doubleClick={{ disabled: true }}
        onTransformed={handleTransform}
        onInit={handleReset}
      >
        {() => (
          <>
            <VisualizationResetButton visible={hasTransformed} />
            <TransformComponent
              wrapperClass="!w-full !h-full"
              contentClass="!w-full !h-full"
            >
              <canvas
                ref={canvasRef}
                className="w-full h-full"
                aria-label="AI visualization orb"
              />
            </TransformComponent>
          </>
        )}
      </TransformWrapper>
    </div>
  );
}
```

Key changes:
- Added canvas rendering with ResizeObserver pattern from NetworkVisualization
- Integrated drawGlassOrb and calculateOrbRadius from orb-renderer.ts
- Added OrbState prop for future animation states
- Crisp retina rendering via devicePixelRatio scaling
- Removed placeholder div, now renders actual glass orb
  </action>
  <verify>
1. `pnpm build` completes without errors
2. `pnpm dev` and visually inspect the orb renders as glass sphere with orange glow
  </verify>
  <done>ProgressiveVisualization renders glass orb on canvas with proper gradients, glow, and retina support.</done>
</task>

</tasks>

<verification>
1. `pnpm build` completes without errors
2. Files exist:
   - src/lib/visualization-types.ts
   - src/components/app/orb-renderer.ts
   - src/components/app/progressive-visualization.tsx (updated)
3. Orb renders with:
   - Glass-like radial gradient (white/silver base)
   - Orange inner glow accent
   - Soft outer glow
   - 15-20% of visualization area size
4. Canvas renders crisply on retina displays
</verification>

<success_criteria>
- OrbState type and ORB_CONFIG constants are defined
- drawGlassOrb function renders glass orb with radial gradients
- Orb has orange accent glow matching --color-accent (#E57850)
- Canvas uses devicePixelRatio for crisp retina rendering
- Orb size is 15-20% of visualization area
- Pan/zoom still works with canvas element
</success_criteria>

<output>
After completion, create `.planning/phases/20-visualization-foundation/20-02-SUMMARY.md`
</output>
