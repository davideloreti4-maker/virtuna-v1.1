---
phase: 20-visualization-foundation
plan: 03
type: execute
wave: 3
depends_on: ["20-02"]
files_modified:
  - src/components/app/use-orb-animation.ts
  - src/components/app/progressive-visualization.tsx
  - src/lib/visualization-types.ts
autonomous: true

must_haves:
  truths:
    - "Orb has ambient breathing animation with 2-3 second cycle"
    - "Breathing combines scale pulse and glow intensity changes"
    - "Orb responds to hover with subtle glow brighten"
    - "Orb responds to tap/click with subtle glow brighten"
    - "Users with prefers-reduced-motion see static orb (no animation)"
    - "State transitions between idle, gathering, analyzing, complete are smooth"
  artifacts:
    - path: "src/components/app/use-orb-animation.ts"
      provides: "Animation hook for orb states"
      exports: ["useOrbAnimation"]
    - path: "src/components/app/progressive-visualization.tsx"
      provides: "Updated component with animation integration"
      exports: ["ProgressiveVisualization"]
    - path: "src/lib/visualization-types.ts"
      provides: "Updated with animation state config"
      exports: ["OrbState", "ORB_CONFIG", "ANIMATION_CONFIG"]
  key_links:
    - from: "src/components/app/progressive-visualization.tsx"
      to: "src/components/app/use-orb-animation.ts"
      via: "import useOrbAnimation"
      pattern: "useOrbAnimation\\("
    - from: "src/components/app/use-orb-animation.ts"
      to: "motion"
      via: "animate function import"
      pattern: "from \"motion"
---

<objective>
Implement orb animations: idle breathing, state transitions, and hover/tap interactions.

Purpose: Bring the orb to life with ambient breathing that makes it feel like something alive is inside. Add interaction feedback for hover/tap and smooth transitions between processing states.

Output: Animated orb with breathing cycle, hover/tap glow response, and state-based animations (idle, gathering, analyzing, complete).
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/20-visualization-foundation/20-CONTEXT.md
@.planning/phases/20-visualization-foundation/20-RESEARCH.md
@.planning/phases/20-visualization-foundation/20-02-SUMMARY.md
@src/components/app/network-visualization.tsx (prefers-reduced-motion pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend visualization types with animation config</name>
  <files>src/lib/visualization-types.ts</files>
  <action>
Add animation configuration constants to visualization-types.ts:

```typescript
/**
 * Orb animation states for the progressive disclosure visualization
 */
export type OrbState = 'idle' | 'gathering' | 'analyzing' | 'complete';

/**
 * Configuration constants for the orb
 */
export const ORB_CONFIG = {
  // Size as percentage of min(width, height)
  sizePercent: 0.17,

  // Colors - using design tokens values
  baseColor: 'rgba(255, 255, 255, 0.9)',
  midColor: 'rgba(240, 240, 240, 0.7)',
  accentColor: 'rgba(229, 120, 80, 0.4)',
  edgeColor: 'rgba(200, 200, 200, 0.2)',
  glowColor: 'rgba(229, 120, 80, 0.5)',

  // Glow settings
  glowBlur: 15,

  // Gradient light offset
  lightOffsetPercent: 0.3,
} as const;

/**
 * Animation configuration per CONTEXT.md
 * - Idle breathing: 2-3 second cycle
 * - Gathering: 3-4 seconds duration
 * - Transitions: 0.3-0.5s ease
 */
export const ANIMATION_CONFIG = {
  // Idle breathing animation
  breathing: {
    duration: 2500,      // 2.5s cycle (middle of 2-3s range)
    scaleMin: 1,
    scaleMax: 1.05,      // 5% scale increase
    glowMin: 0.8,
    glowMax: 1.2,
  },

  // Gathering state (builds anticipation)
  gathering: {
    duration: 3500,      // 3.5s (middle of 3-4s range)
    scaleTo: 1.1,        // Larger scale
    glowIntensity: 1.5,  // Brighter glow
    bounce: 0.25,        // Spring bounce
  },

  // Analyzing state (particles swirl inside)
  analyzing: {
    rotationSpeed: 0.02, // Radians per frame for internal motion
    glowPulse: true,
    glowIntensity: 1.3,
  },

  // Complete state (celebration flash, then dim)
  complete: {
    flashDuration: 300,  // Brief flash
    flashIntensity: 2,
    settleIntensity: 0.6, // Dimmer passive state
    settleDuration: 500,
  },

  // State transitions
  transition: {
    duration: 400,       // 0.4s (middle of 0.3-0.5s range)
    easing: 'ease-out',
  },

  // Hover/tap interaction
  interaction: {
    glowBoost: 1.3,      // 30% brighter on hover
    duration: 200,       // Quick response
  },
} as const;
```
  </action>
  <verify>File compiles with `pnpm build`</verify>
  <done>ANIMATION_CONFIG constants defined with values per CONTEXT.md specifications.</done>
</task>

<task type="auto">
  <name>Task 2: Create useOrbAnimation hook</name>
  <files>src/components/app/use-orb-animation.ts</files>
  <action>
Create a custom hook to manage orb animation state:

```typescript
"use client";

import { useEffect, useRef, useCallback, useState } from "react";
import type { OrbState } from "@/lib/visualization-types";
import { ANIMATION_CONFIG } from "@/lib/visualization-types";

interface OrbAnimationState {
  scale: number;
  glowIntensity: number;
  rotation: number;
}

interface UseOrbAnimationReturn {
  animationState: OrbAnimationState;
  isHovered: boolean;
  setIsHovered: (hovered: boolean) => void;
}

/**
 * Hook for managing orb animation state
 * Handles breathing, state transitions, and interaction feedback
 */
export function useOrbAnimation(state: OrbState): UseOrbAnimationReturn {
  const [animationState, setAnimationState] = useState<OrbAnimationState>({
    scale: 1,
    glowIntensity: 1,
    rotation: 0,
  });
  const [isHovered, setIsHovered] = useState(false);
  const animationRef = useRef<number | null>(null);
  const startTimeRef = useRef<number>(0);

  // Check for reduced motion preference
  const prefersReducedMotion = typeof window !== 'undefined'
    ? window.matchMedia("(prefers-reduced-motion: reduce)").matches
    : false;

  // Breathing animation loop
  const breathe = useCallback((timestamp: number) => {
    if (!startTimeRef.current) {
      startTimeRef.current = timestamp;
    }

    const elapsed = timestamp - startTimeRef.current;
    const { breathing, interaction } = ANIMATION_CONFIG;
    const progress = (elapsed % breathing.duration) / breathing.duration;

    // Sinusoidal breathing pattern
    const breathPhase = Math.sin(progress * Math.PI * 2);
    const scale = breathing.scaleMin + (breathing.scaleMax - breathing.scaleMin) * (0.5 + breathPhase * 0.5);
    const baseGlow = breathing.glowMin + (breathing.glowMax - breathing.glowMin) * (0.5 + breathPhase * 0.5);

    // Apply hover boost if hovered
    const glowIntensity = isHovered ? baseGlow * interaction.glowBoost : baseGlow;

    setAnimationState(prev => ({
      ...prev,
      scale,
      glowIntensity,
    }));

    animationRef.current = requestAnimationFrame(breathe);
  }, [isHovered]);

  // Gathering animation (builds anticipation)
  const gathering = useCallback((timestamp: number) => {
    if (!startTimeRef.current) {
      startTimeRef.current = timestamp;
    }

    const elapsed = timestamp - startTimeRef.current;
    const { gathering: config } = ANIMATION_CONFIG;
    const progress = Math.min(elapsed / config.duration, 1);

    // Ease-out curve for anticipation build
    const eased = 1 - Math.pow(1 - progress, 3);
    const scale = 1 + (config.scaleTo - 1) * eased;
    const glowIntensity = 1 + (config.glowIntensity - 1) * eased;

    setAnimationState(prev => ({
      ...prev,
      scale,
      glowIntensity,
    }));

    if (progress < 1) {
      animationRef.current = requestAnimationFrame(gathering);
    }
  }, []);

  // Analyzing animation (rotation + glow pulse)
  const analyzing = useCallback((timestamp: number) => {
    if (!startTimeRef.current) {
      startTimeRef.current = timestamp;
    }

    const elapsed = timestamp - startTimeRef.current;
    const { analyzing: config, gathering: gatherConfig } = ANIMATION_CONFIG;

    // Maintain gathered scale, add rotation
    const rotation = (elapsed * config.rotationSpeed) % (Math.PI * 2);

    // Subtle glow pulse
    const pulsePhase = Math.sin(elapsed / 500);
    const glowIntensity = config.glowIntensity + pulsePhase * 0.1;

    setAnimationState({
      scale: gatherConfig.scaleTo,
      glowIntensity,
      rotation,
    });

    animationRef.current = requestAnimationFrame(analyzing);
  }, []);

  // Complete animation (flash then settle)
  const complete = useCallback((timestamp: number) => {
    if (!startTimeRef.current) {
      startTimeRef.current = timestamp;
    }

    const elapsed = timestamp - startTimeRef.current;
    const { complete: config } = ANIMATION_CONFIG;

    let glowIntensity: number;
    let scale: number;

    if (elapsed < config.flashDuration) {
      // Flash phase
      const flashProgress = elapsed / config.flashDuration;
      glowIntensity = config.flashIntensity * (1 - flashProgress * 0.5);
      scale = 1.1 + flashProgress * 0.05;
    } else {
      // Settle phase
      const settleElapsed = elapsed - config.flashDuration;
      const settleProgress = Math.min(settleElapsed / config.settleDuration, 1);
      const eased = 1 - Math.pow(1 - settleProgress, 2);

      glowIntensity = config.flashIntensity * 0.5 + (config.settleIntensity - config.flashIntensity * 0.5) * eased;
      scale = 1.15 - 0.15 * eased;
    }

    setAnimationState({
      scale,
      glowIntensity,
      rotation: 0,
    });

    if (elapsed < config.flashDuration + config.settleDuration) {
      animationRef.current = requestAnimationFrame(complete);
    }
  }, []);

  // Start animation based on state
  useEffect(() => {
    // Cancel any existing animation
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }
    startTimeRef.current = 0;

    // If reduced motion, show static state
    if (prefersReducedMotion) {
      setAnimationState({
        scale: state === 'complete' ? 1 : state === 'gathering' ? 1.1 : 1,
        glowIntensity: state === 'complete' ? 0.6 : 1,
        rotation: 0,
      });
      return;
    }

    // Start appropriate animation
    switch (state) {
      case 'idle':
        animationRef.current = requestAnimationFrame(breathe);
        break;
      case 'gathering':
        animationRef.current = requestAnimationFrame(gathering);
        break;
      case 'analyzing':
        animationRef.current = requestAnimationFrame(analyzing);
        break;
      case 'complete':
        animationRef.current = requestAnimationFrame(complete);
        break;
    }

    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [state, prefersReducedMotion, breathe, gathering, analyzing, complete]);

  return { animationState, isHovered, setIsHovered };
}
```

Key features:
- requestAnimationFrame for smooth 60fps animations
- prefers-reduced-motion support per CONTEXT.md
- Sinusoidal breathing pattern
- Hover interaction boost
- Clean animation cancellation on state change
  </action>
  <verify>File compiles with `pnpm build`</verify>
  <done>useOrbAnimation hook created with breathing, state transitions, and interaction support.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate animations into ProgressiveVisualization</name>
  <files>src/components/app/progressive-visualization.tsx</files>
  <action>
Update ProgressiveVisualization to use the animation hook:

```typescript
"use client";

import { useRef, useState, useCallback, useEffect } from "react";
import { TransformWrapper, TransformComponent } from "react-zoom-pan-pinch";
import { cn } from "@/lib/utils";
import { VisualizationResetButton } from "./visualization-reset-button";
import { drawGlassOrb, calculateOrbRadius } from "./orb-renderer";
import { useOrbAnimation } from "./use-orb-animation";
import type { OrbState } from "@/lib/visualization-types";

interface ProgressiveVisualizationProps {
  className?: string;
  state?: OrbState;
  onStateChange?: (state: OrbState) => void;
}

/**
 * ProgressiveVisualization - Animated orb with pan/zoom support
 *
 * Phase 20: Central orb with glass effect, animations, and pan/zoom
 * - Breathing animation (2-3s cycle) in idle state
 * - State transitions: idle → gathering → analyzing → complete
 * - Hover/tap interaction feedback
 * - prefers-reduced-motion support
 */
export function ProgressiveVisualization({
  className,
  state = 'idle',
  onStateChange
}: ProgressiveVisualizationProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [hasTransformed, setHasTransformed] = useState(false);
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });

  // Animation state from hook
  const { animationState, isHovered, setIsHovered } = useOrbAnimation(state);

  // Track when user has moved the view
  const handleTransform = useCallback(() => {
    if (!hasTransformed) {
      setHasTransformed(true);
    }
  }, [hasTransformed]);

  // Hide reset button when view is reset
  const handleReset = useCallback(() => {
    setHasTransformed(false);
  }, []);

  // Canvas setup with ResizeObserver
  useEffect(() => {
    const container = containerRef.current;
    const canvas = canvasRef.current;
    if (!container || !canvas) return;

    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    const resizeCanvas = () => {
      const dpr = window.devicePixelRatio || 1;
      const rect = container.getBoundingClientRect();

      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      canvas.style.width = `${rect.width}px`;
      canvas.style.height = `${rect.height}px`;
      ctx.scale(dpr, dpr);

      setDimensions({ width: rect.width, height: rect.height });
    };

    const resizeObserver = new ResizeObserver(resizeCanvas);
    resizeObserver.observe(container);
    resizeCanvas();

    return () => {
      resizeObserver.disconnect();
    };
  }, []);

  // Animation loop - redraw orb with current animation state
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || dimensions.width === 0) return;

    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    let animationFrameId: number;

    const draw = () => {
      const dpr = window.devicePixelRatio || 1;
      ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);

      const centerX = dimensions.width / 2;
      const centerY = dimensions.height / 2;
      const baseRadius = calculateOrbRadius(dimensions.width, dimensions.height);

      // Apply animation state
      const scaledRadius = baseRadius * animationState.scale;

      // Save context for rotation
      ctx.save();

      // Apply rotation for analyzing state
      if (animationState.rotation !== 0) {
        ctx.translate(centerX, centerY);
        ctx.rotate(animationState.rotation);
        ctx.translate(-centerX, -centerY);
      }

      // Draw the glass orb with animated glow intensity
      drawGlassOrb(ctx, centerX, centerY, scaledRadius, animationState.glowIntensity);

      ctx.restore();

      animationFrameId = requestAnimationFrame(draw);
    };

    draw();

    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  }, [dimensions, animationState]);

  // Mouse/touch handlers for interaction feedback
  const handlePointerEnter = useCallback(() => {
    setIsHovered(true);
  }, [setIsHovered]);

  const handlePointerLeave = useCallback(() => {
    setIsHovered(false);
  }, [setIsHovered]);

  const handleClick = useCallback(() => {
    // Brief glow boost on click/tap (handled via hover state for simplicity)
    setIsHovered(true);
    setTimeout(() => setIsHovered(false), 200);
  }, [setIsHovered]);

  return (
    <div ref={containerRef} className={cn("absolute inset-0 overflow-hidden", className)}>
      <TransformWrapper
        initialScale={1}
        minScale={0.5}
        maxScale={3}
        centerOnInit={true}
        wheel={{ smoothStep: 0.05 }}
        panning={{ velocityDisabled: true }}
        pinch={{ disabled: false }}
        doubleClick={{ disabled: true }}
        onTransformed={handleTransform}
        onInit={handleReset}
      >
        {() => (
          <>
            <VisualizationResetButton visible={hasTransformed} />
            <TransformComponent
              wrapperClass="!w-full !h-full"
              contentClass="!w-full !h-full"
            >
              <canvas
                ref={canvasRef}
                className="w-full h-full cursor-pointer"
                aria-label="AI visualization orb"
                onPointerEnter={handlePointerEnter}
                onPointerLeave={handlePointerLeave}
                onClick={handleClick}
              />
            </TransformComponent>
          </>
        )}
      </TransformWrapper>
    </div>
  );
}
```

Key changes:
- Integrated useOrbAnimation hook for animation state
- Animation loop redraws orb each frame with current scale/glow/rotation
- Pointer events for hover/tap interaction feedback
- Click triggers brief glow boost
- Rotation applied via canvas transform for analyzing state
  </action>
  <verify>
1. `pnpm build` completes without errors
2. `pnpm dev` and verify:
   - Orb breathes with scale/glow pulsing
   - Hover brightens glow
   - Click/tap triggers brief glow boost
   - Test with prefers-reduced-motion: reduce to verify static fallback
  </verify>
  <done>ProgressiveVisualization has working breathing animation, hover/tap feedback, and state transitions.</done>
</task>

</tasks>

<verification>
1. `pnpm build` completes without errors
2. Files exist:
   - src/lib/visualization-types.ts (updated with ANIMATION_CONFIG)
   - src/components/app/use-orb-animation.ts
   - src/components/app/progressive-visualization.tsx (updated)
3. Orb animation:
   - Breathing cycle ~2.5 seconds
   - Scale pulses between 1x and 1.05x
   - Glow intensity pulses
4. Interaction:
   - Hover increases glow ~30%
   - Click/tap triggers brief glow boost
5. Reduced motion:
   - Enable prefers-reduced-motion in browser settings
   - Verify orb is static (no animation)
</verification>

<success_criteria>
- Orb has smooth breathing animation (2-3s cycle)
- Breathing combines scale and glow intensity changes
- Hover interaction brightens glow
- Click/tap triggers brief glow response
- prefers-reduced-motion shows static orb
- Animation states (idle, gathering, analyzing, complete) transition smoothly
- All animations run at 60fps
</success_criteria>

<output>
After completion, create `.planning/phases/20-visualization-foundation/20-03-SUMMARY.md`
</output>
