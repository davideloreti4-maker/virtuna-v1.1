---
phase: 20-visualization-foundation
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - src/components/visualization/GlassOrb.tsx
  - src/components/visualization/shaders/orbVertex.glsl.ts
  - src/components/visualization/shaders/orbFragment.glsl.ts
  - src/lib/noise.ts
autonomous: true

must_haves:
  truths:
    - "Orb displays with organic blob morphing (visible vertex displacement)"
    - "Orb has gradient colors from orange core to coral to magenta rim"
    - "Fresnel rim lighting creates edge glow effect"
    - "Morphing animation uses simplex noise for organic feel"
  artifacts:
    - path: "src/components/visualization/GlassOrb.tsx"
      provides: "Main orb component with custom shader material"
      contains: "shaderMaterial"
      min_lines: 60
    - path: "src/components/visualization/shaders/orbVertex.glsl.ts"
      provides: "Vertex shader with noise displacement"
      contains: "gl_Position"
      min_lines: 40
    - path: "src/components/visualization/shaders/orbFragment.glsl.ts"
      provides: "Fragment shader with gradient and fresnel"
      contains: "gl_FragColor"
      min_lines: 30
    - path: "src/lib/noise.ts"
      provides: "Noise utilities for blob morphing"
      exports: ["createNoise3D"]
      min_lines: 10
  key_links:
    - from: "src/components/visualization/GlassOrb.tsx"
      to: "shaders/orbVertex.glsl.ts"
      via: "import and vertexShader prop"
      pattern: "import.*orbVertex"
    - from: "src/components/visualization/GlassOrb.tsx"
      to: "@react-three/fiber"
      via: "useFrame for time uniform"
      pattern: "useFrame"
---

<objective>
Create the glass orb component with custom vertex displacement shaders matching the Dribbble reference

Purpose: Build the visual core of the visualization - an organic, morphing blob orb with gradient colors and fresnel rim lighting. This is the "AI brain" focal point that users will see.

Output:
- GlassOrb component with custom ShaderMaterial
- Vertex shader with multi-octave simplex noise displacement
- Fragment shader with gradient colors and fresnel rim glow
- Noise utilities using simplex-noise library
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-visualization-foundation/20-RESEARCH.md
@.planning/phases/20-visualization-foundation/20-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shader files with noise displacement and gradient</name>
  <files>
    - src/components/visualization/shaders/orbVertex.glsl.ts
    - src/components/visualization/shaders/orbFragment.glsl.ts
    - src/lib/noise.ts
  </files>
  <action>
Create directory structure:
- `src/components/visualization/shaders/`
- `src/lib/` (if not exists)

Create noise utilities at `src/lib/noise.ts`:

```typescript
import { createNoise3D as createSimplexNoise3D } from 'simplex-noise'

/**
 * Create a seeded 3D noise function for reproducible results.
 * Uses simplex noise which is faster and smoother than Perlin.
 */
export function createNoise3D(seed?: number) {
  // simplex-noise uses alea internally if no seed provided
  return createSimplexNoise3D()
}

// Re-export for convenience
export { createSimplexNoise3D as createNoise3D } from 'simplex-noise'
```

Create vertex shader at `src/components/visualization/shaders/orbVertex.glsl.ts`:

```typescript
/**
 * Vertex shader for organic blob morphing.
 * Uses 3D Perlin noise to displace vertices along their normals.
 */
export const orbVertexShader = /* glsl */ `
uniform float uTime;
uniform float uNoiseScale;
uniform float uNoiseStrength;
uniform float uBreathingScale;

varying vec3 vNormal;
varying vec3 vPosition;
varying vec3 vWorldPosition;
varying float vDisplacement;

//
// GLSL textureless classic 3D Perlin noise "cnoise"
// by Stefan Gustavson (stefan.gustavson@liu.se)
// https://github.com/stegu/webgl-noise
//
vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }

float cnoise(vec3 P) {
  vec3 Pi0 = floor(P);
  vec3 Pi1 = Pi0 + vec3(1.0);
  Pi0 = mod289(Pi0);
  Pi1 = mod289(Pi1);
  vec3 Pf0 = fract(P);
  vec3 Pf1 = Pf0 - vec3(1.0);
  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec4 iy = vec4(Pi0.yy, Pi1.yy);
  vec4 iz0 = Pi0.zzzz;
  vec4 iz1 = Pi1.zzzz;

  vec4 ixy = permute(permute(ix) + iy);
  vec4 ixy0 = permute(ixy + iz0);
  vec4 ixy1 = permute(ixy + iz1);

  vec4 gx0 = ixy0 * (1.0 / 7.0);
  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
  gx0 = fract(gx0);
  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
  vec4 sz0 = step(gz0, vec4(0.0));
  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

  vec4 gx1 = ixy1 * (1.0 / 7.0);
  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
  gx1 = fract(gx1);
  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
  vec4 sz1 = step(gz1, vec4(0.0));
  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 *= norm0.x;
  g010 *= norm0.y;
  g100 *= norm0.z;
  g110 *= norm0.w;
  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 *= norm1.x;
  g011 *= norm1.y;
  g101 *= norm1.z;
  g111 *= norm1.w;

  float n000 = dot(g000, Pf0);
  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
  float n111 = dot(g111, Pf1);

  vec3 fade_xyz = fade(Pf0);
  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
  return 2.2 * n_xyz;
}

void main() {
  vNormal = normalize(normalMatrix * normal);
  vPosition = position;

  // Multi-octave noise for organic feel (per research)
  // Primary large-scale deformation
  float noise1 = cnoise(position * uNoiseScale + vec3(uTime * 0.15)) * 0.6;
  // Medium frequency detail
  float noise2 = cnoise(position * uNoiseScale * 2.0 + vec3(uTime * 0.2)) * 0.3;
  // High frequency subtle detail
  float noise3 = cnoise(position * uNoiseScale * 4.0 + vec3(uTime * 0.25)) * 0.1;

  // Combine noise octaves
  vDisplacement = (noise1 + noise2 + noise3);

  // Apply displacement along normal
  vec3 newPosition = position + normal * vDisplacement * uNoiseStrength;

  // Apply breathing scale (for ambient pulse animation)
  newPosition *= uBreathingScale;

  // Calculate world position for fresnel
  vec4 worldPosition = modelMatrix * vec4(newPosition, 1.0);
  vWorldPosition = worldPosition.xyz;

  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
}
`
```

Create fragment shader at `src/components/visualization/shaders/orbFragment.glsl.ts`:

```typescript
/**
 * Fragment shader with gradient colors and fresnel rim lighting.
 * Creates the glass-like appearance with orange core to magenta rim.
 */
export const orbFragmentShader = /* glsl */ `
uniform vec3 uColorCore;      // Orange center
uniform vec3 uColorMid;       // Coral/Pink middle
uniform vec3 uColorRim;       // Magenta/Purple rim
uniform float uFresnelPower;
uniform float uFresnelIntensity;
uniform float uGlowIntensity;

varying vec3 vNormal;
varying vec3 vPosition;
varying vec3 vWorldPosition;
varying float vDisplacement;

void main() {
  // Calculate view direction for fresnel
  vec3 viewDirection = normalize(cameraPosition - vWorldPosition);

  // Fresnel calculation - stronger at edges (grazing angles)
  float fresnel = 1.0 - max(dot(viewDirection, vNormal), 0.0);
  fresnel = pow(fresnel, uFresnelPower);

  // Gradient based on fresnel (center to rim)
  // Orange core -> Coral middle -> Magenta rim
  vec3 color = mix(uColorCore, uColorMid, fresnel * 0.6);
  color = mix(color, uColorRim, pow(fresnel, 1.5));

  // Add rim glow (stronger at edges)
  vec3 rimGlow = uColorRim * fresnel * uFresnelIntensity * uGlowIntensity;
  color += rimGlow;

  // Subtle color variation based on displacement for organic look
  color += vec3(vDisplacement * 0.05);

  // Alpha: slightly transparent in center, more opaque at edges
  float alpha = 0.85 + fresnel * 0.15;

  gl_FragColor = vec4(color, alpha);
}
`
```
  </action>
  <verify>
1. Files exist at correct paths
2. No TypeScript syntax errors
3. GLSL syntax is valid (will be validated at runtime)
4. `pnpm build` passes
  </verify>
  <done>
- Vertex shader implements multi-octave noise displacement
- Fragment shader implements gradient + fresnel rim lighting
- Noise utilities ready for use
- Shader code follows research patterns
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GlassOrb component with custom shader material</name>
  <files>
    - src/components/visualization/GlassOrb.tsx
  </files>
  <action>
Create the main orb component at `src/components/visualization/GlassOrb.tsx`:

```typescript
'use client'

import { useRef, useMemo } from 'react'
import { useFrame } from '@react-three/fiber'
import * as THREE from 'three'
import { orbVertexShader } from './shaders/orbVertex.glsl'
import { orbFragmentShader } from './shaders/orbFragment.glsl'

interface GlassOrbProps {
  /** Disable animation for reduced motion preference */
  reducedMotion?: boolean
  /** Orb radius (default: 1.5) */
  radius?: number
  /** Animation speed multiplier (default: 1.0) */
  animationSpeed?: number
  /** Glow intensity multiplier for hover/active states (default: 1.0) */
  glowIntensity?: number
}

/**
 * GlassOrb - Organic morphing orb with gradient colors and fresnel rim glow
 *
 * Matches the Dribbble reference visual:
 * - Orange core fading to coral to magenta rim
 * - Organic blob morphing via vertex displacement
 * - Fresnel rim lighting for edge glow
 * - Semi-transparent glass-like appearance
 *
 * Performance considerations:
 * - Uses refs for all animation values (no React state)
 * - icosahedronGeometry with 64 subdivisions for smooth morphing
 * - Uniforms updated directly in useFrame
 */
export function GlassOrb({
  reducedMotion = false,
  radius = 1.5,
  animationSpeed = 1.0,
  glowIntensity = 1.0,
}: GlassOrbProps) {
  const materialRef = useRef<THREE.ShaderMaterial>(null)

  // Memoize uniforms to prevent recreation
  const uniforms = useMemo(
    () => ({
      // Time for animation
      uTime: { value: 0 },

      // Noise parameters (per research)
      uNoiseScale: { value: 1.2 },
      uNoiseStrength: { value: 0.18 },

      // Breathing scale (controlled externally via props)
      uBreathingScale: { value: 1.0 },

      // Color gradient (orange -> coral -> magenta per reference)
      uColorCore: { value: new THREE.Color('#FF6B35') },   // Warm orange
      uColorMid: { value: new THREE.Color('#FF8E72') },    // Coral
      uColorRim: { value: new THREE.Color('#C850C0') },    // Magenta

      // Fresnel parameters
      uFresnelPower: { value: 2.5 },
      uFresnelIntensity: { value: 0.9 },

      // Glow intensity (can be boosted for hover)
      uGlowIntensity: { value: glowIntensity },
    }),
    [glowIntensity]
  )

  // Update uniforms each frame
  useFrame(({ clock }) => {
    if (materialRef.current && !reducedMotion) {
      // Update time uniform for morphing animation
      materialRef.current.uniforms.uTime.value =
        clock.getElapsedTime() * animationSpeed
    }
  })

  // Update glow intensity when prop changes
  useFrame(() => {
    if (materialRef.current) {
      materialRef.current.uniforms.uGlowIntensity.value = glowIntensity
    }
  })

  return (
    <mesh>
      {/* icosahedronGeometry provides even vertex distribution for smooth noise */}
      <icosahedronGeometry args={[radius, 64]} />
      <shaderMaterial
        ref={materialRef}
        vertexShader={orbVertexShader}
        fragmentShader={orbFragmentShader}
        uniforms={uniforms}
        transparent
        side={THREE.DoubleSide}
        depthWrite={false} // Better blending with transparent background
      />
    </mesh>
  )
}
```

Key implementation decisions:
- icosahedronGeometry with 64 subdivisions: Provides smooth vertex distribution for noise displacement (per research)
- DoubleSide rendering: Ensures orb looks correct from all angles
- depthWrite={false}: Better transparency blending
- Uniforms in useMemo: Prevents recreation on re-render
- Direct uniform mutation in useFrame: No React state = 60fps
  </action>
  <verify>
1. File exists and TypeScript compiles
2. Import paths are correct
3. `pnpm build` passes
  </verify>
  <done>
- GlassOrb component created with custom shader material
- Vertex displacement creates organic blob morphing
- Gradient colors match reference (orange -> coral -> magenta)
- Fresnel rim lighting creates edge glow
  </done>
</task>

<task type="auto">
  <name>Task 3: Update test page to display GlassOrb</name>
  <files>
    - src/app/(marketing)/viz-test/page.tsx
  </files>
  <action>
Update the test page to use GlassOrb instead of the basic sphere:

```typescript
import { VisualizationCanvas } from '@/components/visualization/VisualizationCanvas'
import { GlassOrb } from '@/components/visualization/GlassOrb'

export default function VizTestPage() {
  return (
    <main className="min-h-screen bg-background-base">
      <div className="h-screen w-full">
        <VisualizationCanvas className="h-full w-full">
          <GlassOrb />
        </VisualizationCanvas>
      </div>
    </main>
  )
}
```

This allows visual verification of:
- Blob morphing animation
- Gradient colors (orange core to magenta rim)
- Fresnel rim glow effect
- Pan/zoom with orb visible
  </action>
  <verify>
1. Run `pnpm dev`
2. Navigate to http://localhost:3000/viz-test
3. Verify: Orb displays with visible morphing/wobble animation
4. Verify: Gradient colors visible (orange center, magenta edges)
5. Verify: Rim glow effect visible at edges
6. Verify: Pan/zoom still works
7. Verify: No WebGL errors in console
8. Run `pnpm build` - should pass
  </verify>
  <done>
- Test page displays GlassOrb with all visual effects
- Blob morphing animation runs smoothly
- Gradient and fresnel effects visible
- Build passes
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Visual verification:**
   - Visit /viz-test in development mode
   - Orb has organic blob morphing (vertices move smoothly)
   - Colors gradient from orange center to magenta rim
   - Edge glow (fresnel) visible when viewing at angles
   - Animation is smooth (~60fps)

2. **Build verification:**
   ```bash
   pnpm build
   ```
   Must pass without errors.

3. **Shader validation:**
   - No WebGL shader compilation errors in console
   - Uniforms update smoothly (time-based animation)

4. **Performance check:**
   - Open browser DevTools Performance tab
   - Animation maintains 60fps
   - No jank or frame drops
</verification>

<success_criteria>
- [x] GlassOrb component renders with custom shader material
- [x] Vertex shader displaces vertices with multi-octave noise
- [x] Fragment shader applies gradient (orange -> coral -> magenta)
- [x] Fresnel rim lighting creates edge glow effect
- [x] Animation runs smoothly without React re-renders
- [x] icosahedronGeometry with 64 subdivisions for smooth morphing
- [x] Test page displays orb with all visual effects
- [x] Build passes (`pnpm build`)
</success_criteria>

<output>
After completion, create `.planning/phases/20-visualization-foundation/20-02-SUMMARY.md`
</output>
