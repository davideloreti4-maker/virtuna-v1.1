---
phase: 20-visualization-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - next.config.ts
  - src/components/visualization/VisualizationCanvas.tsx
  - src/components/visualization/VisualizationContext.tsx
  - src/hooks/usePrefersReducedMotion.ts
  - src/hooks/useIsMobile.ts
  - src/app/(marketing)/viz-test/page.tsx
autonomous: true

must_haves:
  truths:
    - "R3F Canvas renders without hydration errors"
    - "WebGL context initializes with high-performance mode"
    - "Camera controls work on desktop (mouse drag) and touch (pinch/drag)"
    - "VisualizationContext provides reducedMotion and isMobile values"
    - "Old Canvas 2D visualization files are removed"
  artifacts:
    - path: "src/components/visualization/VisualizationCanvas.tsx"
      provides: "R3F Canvas wrapper with camera controls"
      contains: "'use client'"
      min_lines: 50
    - path: "src/components/visualization/VisualizationContext.tsx"
      provides: "React Context for visualization settings"
      exports: ["VisualizationProvider", "useVisualization"]
      min_lines: 30
    - path: "src/hooks/usePrefersReducedMotion.ts"
      provides: "Accessibility hook for motion preferences"
      exports: ["usePrefersReducedMotion"]
      min_lines: 20
    - path: "src/hooks/useIsMobile.ts"
      provides: "Mobile detection hook"
      exports: ["useIsMobile"]
      min_lines: 15
  key_links:
    - from: "src/components/visualization/VisualizationCanvas.tsx"
      to: "@react-three/fiber"
      via: "Canvas component import"
      pattern: "import.*Canvas.*@react-three/fiber"
    - from: "src/components/visualization/VisualizationCanvas.tsx"
      to: "VisualizationContext.tsx"
      via: "Provider wrapping Canvas"
      pattern: "VisualizationProvider"
---

<objective>
Set up React Three Fiber infrastructure with context-based settings and clean up old Canvas 2D implementation

Purpose: Establish the WebGL rendering pipeline with proper React Context for visualization settings (reduced motion, mobile detection). Remove old Canvas 2D code to avoid confusion.

Output:
- R3F Canvas wrapper with OrbitControls and reset functionality
- VisualizationContext providing reducedMotion and isMobile to all children
- Accessibility hooks (usePrefersReducedMotion, useIsMobile)
- Old Canvas 2D files removed
- Test page to verify setup
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-visualization-foundation/20-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install R3F dependencies and configure Next.js</name>
  <files>
    - package.json
    - next.config.ts
  </files>
  <action>
Install Three.js and React Three Fiber stack:

```bash
pnpm add three @react-three/fiber @react-three/drei
pnpm add -D @types/three
```

Note: We do NOT need simplex-noise - the shaders use inline GLSL noise functions.

Update next.config.ts to transpile Three.js (required for proper ESM handling):

```typescript
/** @type {import('next').NextConfig} */
const nextConfig = {
  transpilePackages: ['three'],
  // ... existing config
}
```

Note: Keep existing config options, only add transpilePackages if not already present.
  </action>
  <verify>
Run `pnpm build` - should complete without errors.
Check package.json contains: three, @react-three/fiber, @react-three/drei, @types/three
  </verify>
  <done>
All R3F dependencies installed, Next.js configured to transpile Three.js, build passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Create hooks and VisualizationContext</name>
  <files>
    - src/hooks/usePrefersReducedMotion.ts
    - src/hooks/useIsMobile.ts
    - src/components/visualization/VisualizationContext.tsx
  </files>
  <action>
Create directory if needed: `src/hooks/`

Create the usePrefersReducedMotion hook at `src/hooks/usePrefersReducedMotion.ts`:

```typescript
'use client'

import { useState, useEffect } from 'react'

const QUERY = '(prefers-reduced-motion: no-preference)'

/**
 * Detects user's motion preference from OS settings.
 * Returns true if user prefers reduced motion, false otherwise.
 * Defaults to true (reduced motion) for SSR safety.
 */
export function usePrefersReducedMotion(): boolean {
  const [prefersReducedMotion, setPrefersReducedMotion] = useState(true)

  useEffect(() => {
    const mediaQueryList = window.matchMedia(QUERY)
    // If no-preference matches, user does NOT prefer reduced motion
    setPrefersReducedMotion(!mediaQueryList.matches)

    const listener = (event: MediaQueryListEvent) => {
      setPrefersReducedMotion(!event.matches)
    }

    mediaQueryList.addEventListener('change', listener)
    return () => mediaQueryList.removeEventListener('change', listener)
  }, [])

  return prefersReducedMotion
}
```

Create the useIsMobile hook at `src/hooks/useIsMobile.ts`:

```typescript
'use client'

import { useState, useEffect } from 'react'

const MOBILE_BREAKPOINT = 768

/**
 * Detects if viewport is mobile-sized.
 * Used to reduce WebGL complexity on mobile devices.
 * Defaults to true (mobile) for SSR safety - better to start low-perf.
 */
export function useIsMobile(): boolean {
  const [isMobile, setIsMobile] = useState(true)

  useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }

    checkMobile()
    window.addEventListener('resize', checkMobile)
    return () => window.removeEventListener('resize', checkMobile)
  }, [])

  return isMobile
}
```

Create directory: `src/components/visualization/`

Create the VisualizationContext at `src/components/visualization/VisualizationContext.tsx`:

```typescript
'use client'

import { createContext, useContext, useMemo, ReactNode } from 'react'
import { usePrefersReducedMotion } from '@/hooks/usePrefersReducedMotion'
import { useIsMobile } from '@/hooks/useIsMobile'

interface VisualizationContextValue {
  /** User prefers reduced motion (OS setting) */
  reducedMotion: boolean
  /** Viewport is mobile-sized */
  isMobile: boolean
  /** Geometry detail level based on device capability */
  geometryDetail: number
}

const VisualizationContext = createContext<VisualizationContextValue | null>(null)

interface VisualizationProviderProps {
  children: ReactNode
  /** Force reduced motion (for testing) */
  forceReducedMotion?: boolean
}

/**
 * Provides visualization settings to all child components.
 * Handles reduced motion detection and mobile optimization.
 */
export function VisualizationProvider({
  children,
  forceReducedMotion = false,
}: VisualizationProviderProps) {
  const systemReducedMotion = usePrefersReducedMotion()
  const isMobile = useIsMobile()

  const value = useMemo<VisualizationContextValue>(
    () => ({
      reducedMotion: forceReducedMotion || systemReducedMotion,
      isMobile,
      // Mobile: 32 subdivisions (~5K vertices), Desktop: 64 (~40K vertices)
      geometryDetail: isMobile ? 32 : 64,
    }),
    [forceReducedMotion, systemReducedMotion, isMobile]
  )

  return (
    <VisualizationContext.Provider value={value}>
      {children}
    </VisualizationContext.Provider>
  )
}

/**
 * Hook to access visualization settings.
 * Must be used within VisualizationProvider.
 */
export function useVisualization(): VisualizationContextValue {
  const context = useContext(VisualizationContext)
  if (!context) {
    throw new Error('useVisualization must be used within VisualizationProvider')
  }
  return context
}
```
  </action>
  <verify>
1. Files exist at correct paths
2. TypeScript compiles without errors: `pnpm build`
  </verify>
  <done>
- usePrefersReducedMotion detects OS motion preference
- useIsMobile detects mobile viewport
- VisualizationContext provides settings to children via useVisualization hook
- geometryDetail adapts based on device (32 mobile, 64 desktop)
  </done>
</task>

<task type="auto">
  <name>Task 3: Create VisualizationCanvas with OrbitControls</name>
  <files>
    - src/components/visualization/VisualizationCanvas.tsx
  </files>
  <action>
Create the VisualizationCanvas component at `src/components/visualization/VisualizationCanvas.tsx`:

```typescript
'use client'

import { Suspense, useRef, useCallback } from 'react'
import { Canvas } from '@react-three/fiber'
import { OrbitControls, PerspectiveCamera } from '@react-three/drei'
import type { OrbitControls as OrbitControlsImpl } from 'three-stdlib'
import { VisualizationProvider } from './VisualizationContext'

interface VisualizationCanvasProps {
  children?: React.ReactNode
  className?: string
  /** Force reduced motion for testing */
  forceReducedMotion?: boolean
  /** Show reset button when view is transformed */
  showResetButton?: boolean
}

/**
 * VisualizationCanvas - R3F Canvas wrapper for the visualization
 *
 * Features:
 * - High-performance WebGL context
 * - OrbitControls with pan/zoom (rotation disabled for 2D feel)
 * - Reset button to return to default view
 * - VisualizationProvider for settings context
 * - Transparent background for integration with dark theme
 */
export function VisualizationCanvas({
  children,
  className,
  forceReducedMotion = false,
  showResetButton = true,
}: VisualizationCanvasProps) {
  const controlsRef = useRef<OrbitControlsImpl>(null)

  const handleReset = useCallback(() => {
    if (controlsRef.current) {
      controlsRef.current.reset()
    }
  }, [])

  return (
    <VisualizationProvider forceReducedMotion={forceReducedMotion}>
      <div className={className} style={{ position: 'relative' }}>
        <Canvas
          gl={{
            antialias: true,
            alpha: true,
            powerPreference: 'high-performance',
          }}
          dpr={[1, 2]} // Retina support capped at 2x for performance
        >
          <PerspectiveCamera makeDefault position={[0, 0, 5]} fov={45} />

          <OrbitControls
            ref={controlsRef}
            enablePan={true}
            enableZoom={true}
            enableRotate={false} // 2D-style controls
            minDistance={2}
            maxDistance={10}
            zoomSpeed={0.5}
            panSpeed={0.5}
          />

          {/* Ambient light for basic illumination */}
          <ambientLight intensity={0.5} />

          <Suspense fallback={null}>{children}</Suspense>
        </Canvas>

        {/* Reset button */}
        {showResetButton && (
          <button
            onClick={handleReset}
            className="absolute bottom-4 right-4 px-3 py-1.5 text-xs font-medium
                       bg-surface-elevated/80 backdrop-blur-sm rounded-md
                       text-text-secondary hover:text-text-primary
                       border border-border-subtle hover:border-border-default
                       transition-colors"
            aria-label="Reset view"
          >
            Reset View
          </button>
        )}
      </div>
    </VisualizationProvider>
  )
}
```

Key decisions:
- enableRotate={false}: Keeps 2D feel (pan/zoom but not 3D rotation)
- minDistance/maxDistance: 2-10 provides reasonable zoom range
- dpr={[1, 2]}: Retina support capped at 2x for performance
- alpha: true: Transparent background integrates with dark theme
- powerPreference: 'high-performance': Request GPU acceleration
- Reset button always visible (simpler UX than appearing after transform)
  </action>
  <verify>
1. File exists at correct path
2. TypeScript compiles without errors: `pnpm build`
  </verify>
  <done>
- VisualizationCanvas exports functional R3F Canvas with OrbitControls
- VisualizationProvider wraps children with context
- Reset button allows returning to default view
- No hydration errors when used in Next.js pages
  </done>
</task>

<task type="auto">
  <name>Task 4: Remove old Canvas 2D visualization files</name>
  <files>
    - src/components/app/orb-renderer.ts (DELETE)
    - src/components/app/use-orb-animation.ts (DELETE)
    - src/components/app/progressive-visualization.tsx (DELETE)
    - src/components/app/visualization-reset-button.tsx (DELETE)
  </files>
  <action>
Remove the old Canvas 2D visualization files that are no longer needed:

```bash
rm -f src/components/app/orb-renderer.ts
rm -f src/components/app/use-orb-animation.ts
rm -f src/components/app/progressive-visualization.tsx
rm -f src/components/app/visualization-reset-button.tsx
```

Check if react-zoom-pan-pinch is still used elsewhere:

```bash
grep -r "react-zoom-pan-pinch" src/
```

If no other usages found, remove the dependency:

```bash
pnpm remove react-zoom-pan-pinch
```

Update src/lib/visualization-types.ts to remove old types if they exist. Keep only types that will be used by the new implementation:

If the file only contains old Canvas 2D types, delete it:
```bash
rm -f src/lib/visualization-types.ts
```

If it has shared types, keep those and remove only the obsolete ones.
  </action>
  <verify>
1. Old files no longer exist
2. No TypeScript errors from missing imports
3. `pnpm build` passes
4. Check for any broken imports in dashboard or other components
  </verify>
  <done>
- Old Canvas 2D orb-renderer.ts removed
- Old use-orb-animation.ts removed
- Old progressive-visualization.tsx removed
- Old visualization-reset-button.tsx removed
- react-zoom-pan-pinch removed if unused
- Build passes with no broken imports
  </done>
</task>

<task type="auto">
  <name>Task 5: Create test page to verify R3F setup</name>
  <files>
    - src/app/(marketing)/viz-test/page.tsx
  </files>
  <action>
Create a test page to verify R3F renders correctly.

Create `src/app/(marketing)/viz-test/page.tsx`:

```typescript
'use client'

import { useState } from 'react'
import { VisualizationCanvas } from '@/components/visualization/VisualizationCanvas'
import { useVisualization } from '@/components/visualization/VisualizationContext'

function TestSphere() {
  const { geometryDetail, reducedMotion, isMobile } = useVisualization()

  return (
    <mesh>
      <sphereGeometry args={[1, geometryDetail, geometryDetail]} />
      <meshStandardMaterial color="#FF6B35" wireframe />
    </mesh>
  )
}

function DebugInfo() {
  const { reducedMotion, isMobile, geometryDetail } = useVisualization()

  return (
    <div className="text-text-tertiary text-xs space-y-1">
      <div>Reduced motion: {reducedMotion ? 'Yes' : 'No'}</div>
      <div>Mobile: {isMobile ? 'Yes' : 'No'}</div>
      <div>Geometry detail: {geometryDetail}</div>
    </div>
  )
}

export default function VizTestPage() {
  const [forceReducedMotion, setForceReducedMotion] = useState(false)

  return (
    <main className="min-h-screen bg-background-base">
      {/* Controls overlay */}
      <div className="absolute top-4 left-4 z-10 p-4 rounded-lg bg-surface-elevated/80 backdrop-blur-sm space-y-3">
        <div className="text-text-primary text-sm font-medium">
          R3F Setup Test
        </div>

        <label className="flex items-center gap-2 text-text-secondary text-xs">
          <input
            type="checkbox"
            checked={forceReducedMotion}
            onChange={(e) => setForceReducedMotion(e.target.checked)}
            className="rounded"
          />
          Force reduced motion
        </label>

        <VisualizationCanvas forceReducedMotion={forceReducedMotion} className="hidden">
          <DebugInfoWrapper setInfo={() => {}} />
        </VisualizationCanvas>

        <div className="text-text-tertiary text-xs mt-2">
          Test:
          <ul className="list-disc list-inside mt-1">
            <li>Orange wireframe sphere visible</li>
            <li>Drag to pan the view</li>
            <li>Scroll to zoom in/out</li>
            <li>Reset View button works</li>
          </ul>
        </div>
      </div>

      {/* Canvas */}
      <div className="h-screen w-full">
        <VisualizationCanvas
          className="h-full w-full"
          forceReducedMotion={forceReducedMotion}
        >
          <TestSphere />
        </VisualizationCanvas>
      </div>
    </main>
  )
}

// Helper to extract debug info from context
function DebugInfoWrapper({ setInfo }: { setInfo: (info: string) => void }) {
  return null
}
```

Wait, that's getting complicated. Let me simplify:

```typescript
'use client'

import { useState } from 'react'
import { VisualizationCanvas } from '@/components/visualization/VisualizationCanvas'

function TestSphere() {
  return (
    <mesh>
      <sphereGeometry args={[1, 32, 32]} />
      <meshStandardMaterial color="#FF6B35" />
    </mesh>
  )
}

export default function VizTestPage() {
  const [forceReducedMotion, setForceReducedMotion] = useState(false)

  return (
    <main className="min-h-screen bg-background-base">
      {/* Controls overlay */}
      <div className="absolute top-4 left-4 z-10 p-4 rounded-lg bg-surface-elevated/80 backdrop-blur-sm space-y-3">
        <div className="text-text-primary text-sm font-medium">
          R3F Setup Test
        </div>

        <label className="flex items-center gap-2 text-text-secondary text-xs">
          <input
            type="checkbox"
            checked={forceReducedMotion}
            onChange={(e) => setForceReducedMotion(e.target.checked)}
            className="rounded"
          />
          Force reduced motion
        </label>

        <div className="text-text-tertiary text-xs mt-2">
          Test:
          <ul className="list-disc list-inside mt-1">
            <li>Orange sphere visible</li>
            <li>Drag to pan the view</li>
            <li>Scroll to zoom in/out</li>
            <li>Reset View button works</li>
          </ul>
        </div>
      </div>

      {/* Canvas */}
      <div className="h-screen w-full">
        <VisualizationCanvas
          className="h-full w-full"
          forceReducedMotion={forceReducedMotion}
        >
          <TestSphere />
        </VisualizationCanvas>
      </div>
    </main>
  )
}
```

This page:
- Renders an orange sphere to verify WebGL works
- Uses full viewport to test canvas sizing
- Applies dark background from design tokens
- Allows testing pan/zoom controls manually
- Has reset button to test OrbitControls.reset()
  </action>
  <verify>
1. Run `pnpm dev`
2. Navigate to http://localhost:3000/viz-test
3. Verify: Orange sphere visible on dark background
4. Verify: Mouse drag pans the view
5. Verify: Scroll wheel zooms in/out
6. Verify: Reset View button returns to default view
7. Verify: No console errors about hydration or WebGL
8. Run `pnpm build` - should pass
  </verify>
  <done>
- Test page renders R3F canvas with sphere
- Pan/zoom controls work via mouse and touch
- Reset button returns to default view
- No hydration or WebGL errors in console
- Build passes
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build verification:**
   ```bash
   pnpm build
   ```
   Must pass without errors.

2. **Runtime verification:**
   - Visit /viz-test in development mode
   - Sphere renders on dark background
   - Pan (drag), zoom (scroll) work
   - Reset View button works
   - No console errors

3. **Dependency check:**
   ```bash
   pnpm list three @react-three/fiber @react-three/drei
   ```
   All packages should be installed.

4. **Cleanup verification:**
   - Old Canvas 2D files no longer exist
   - No broken imports in codebase

5. **Type safety:**
   - No TypeScript errors in IDE
   - @types/three providing type definitions
</verification>

<success_criteria>
- [x] R3F dependencies installed (three, @react-three/fiber, @react-three/drei)
- [x] Next.js transpilePackages includes 'three'
- [x] VisualizationContext provides reducedMotion, isMobile, geometryDetail
- [x] VisualizationCanvas wraps children with context provider
- [x] OrbitControls enable pan/zoom, disable rotation
- [x] Reset button returns to default view
- [x] Old Canvas 2D files removed (orb-renderer, use-orb-animation, progressive-visualization)
- [x] Test page at /viz-test displays orange sphere
- [x] Build passes (`pnpm build`)
</success_criteria>

<output>
After completion, create `.planning/phases/20-visualization-foundation/20-01-SUMMARY.md`
</output>
