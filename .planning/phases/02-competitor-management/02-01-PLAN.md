---
phase: 02-competitor-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/actions/competitors/add.ts
  - src/app/actions/competitors/remove.ts
autonomous: true

must_haves:
  truths:
    - "User can paste a TikTok @handle and the system validates it exists, fetches initial profile + video data, and adds it to their tracked list"
    - "User already tracking a handle gets a clear 'already tracking' error instead of a duplicate"
    - "User can remove a tracked competitor and it disappears from their list"
    - "Removing a competitor only deletes the user's link, not the shared profile"
  artifacts:
    - path: "src/app/actions/competitors/add.ts"
      provides: "addCompetitor server action"
      exports: ["addCompetitor"]
    - path: "src/app/actions/competitors/remove.ts"
      provides: "removeCompetitor server action"
      exports: ["removeCompetitor"]
  key_links:
    - from: "src/app/actions/competitors/add.ts"
      to: "src/lib/scraping/index.ts"
      via: "createScrapingProvider().scrapeProfile()"
      pattern: "createScrapingProvider.*scrapeProfile"
    - from: "src/app/actions/competitors/add.ts"
      to: "src/lib/supabase/service.ts"
      via: "createServiceClient() for RLS-bypass profile lookup and data writes"
      pattern: "createServiceClient"
    - from: "src/app/actions/competitors/add.ts"
      to: "src/lib/schemas/competitor.ts"
      via: "normalizeHandle() for input normalization"
      pattern: "normalizeHandle"
    - from: "src/app/actions/competitors/add.ts"
      to: "src/lib/supabase/server.ts"
      via: "createClient() for auth check and junction row insert"
      pattern: "createClient"
    - from: "src/app/actions/competitors/remove.ts"
      to: "src/lib/supabase/server.ts"
      via: "createClient() for auth check and junction row delete"
      pattern: "createClient"
---

<objective>
Create server actions for adding and removing tracked competitors. The add action validates the TikTok handle via Apify scraping, creates or finds the shared profile using the junction table deduplication model, inserts initial snapshot + video data, and links the user. The remove action deletes only the user's junction row, preserving the shared profile.

Purpose: Enables users to build and manage their competitor tracking list -- the core user-facing mutation layer that Phase 3's UI will call.
Output: Two server actions callable from any React component via `useActionState` or direct invocation.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-data-foundation/01-01-SUMMARY.md
@.planning/phases/01-data-foundation/01-02-SUMMARY.md

# Phase 1 source files (exact APIs to consume)
@src/lib/supabase/server.ts
@src/lib/supabase/service.ts
@src/lib/scraping/types.ts
@src/lib/scraping/apify-provider.ts
@src/lib/scraping/index.ts
@src/lib/schemas/competitor.ts
@supabase/migrations/20260216100000_competitor_tables.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create addCompetitor server action with junction table deduplication</name>
  <files>src/app/actions/competitors/add.ts</files>
  <action>
Create `src/app/actions/competitors/add.ts` with `"use server"` directive.

**Imports:**
- `revalidatePath` from `next/cache`
- `createClient` from `@/lib/supabase/server`
- `createServiceClient` from `@/lib/supabase/service`
- `createScrapingProvider` from `@/lib/scraping`
- `normalizeHandle` from `@/lib/schemas/competitor`
- `ProfileData` type from `@/lib/scraping`

**Export `addCompetitor(handle: string): Promise<ActionResult>`:**

Return type `ActionResult = { error?: string; data?: { competitorId: string; handle: string } }`.

Flow (follow this exactly):
1. **Auth check:** `const supabase = await createClient()`, `supabase.auth.getUser()`. Return `{ error: "Not authenticated" }` if no user.
2. **Normalize handle:** Call `normalizeHandle(handle)`. If result is empty or length < 2, return `{ error: "Invalid TikTok handle" }`.
3. **Service client profile lookup (bypasses RLS):** Use `createServiceClient()` to query `competitor_profiles` by `tiktok_handle = normalized`. Use `.maybeSingle()` (not `.single()`) to avoid throwing on no match.

4a. **If profile exists:** Skip scraping entirely. Go to step 5.

4b. **If profile does NOT exist:**
   - Create scraper via `createScrapingProvider()`
   - Call `scraper.scrapeProfile(normalized)`. Wrap in try/catch -- on error, return `{ error: "TikTok handle not found or could not be scraped" }`.
   - **Upsert profile** with service client into `competitor_profiles` using `.upsert({ ... }, { onConflict: "tiktok_handle" }).select("id").single()`. Map `ProfileData` fields to DB columns: `tiktok_handle: normalized`, `display_name: profileData.displayName`, `bio: profileData.bio`, `avatar_url: profileData.avatarUrl`, `verified: profileData.verified`, `follower_count: profileData.followerCount`, `following_count: profileData.followingCount`, `heart_count: profileData.heartCount`, `video_count: profileData.videoCount`, `last_scraped_at: new Date().toISOString()`, `scrape_status: "success"`. If upsert fails, return `{ error: "Failed to create competitor profile" }`.
   - **Insert initial snapshot** with service client into `competitor_snapshots` using `.upsert({ ... }, { onConflict: "competitor_id,snapshot_date" })`. Fields: `competitor_id: profile.id`, `follower_count`, `following_count`, `heart_count`, `video_count`, `snapshot_date: new Date().toISOString().split("T")[0]`.
   - **Scrape and insert videos** (non-fatal): Wrap in try/catch. Call `scraper.scrapeVideos(normalized)`. If videos returned, upsert into `competitor_videos` with service client using `.upsert(videos.map(...), { onConflict: "competitor_id,platform_video_id" })`. Map `VideoData` fields: `competitor_id: profile.id`, `platform_video_id: v.platformVideoId`, `video_url: v.videoUrl`, `caption: v.caption`, `views: v.views`, `likes: v.likes`, `comments: v.comments`, `shares: v.shares`, `saves: v.saves`, `hashtags: v.hashtags`, `duration_seconds: v.durationSeconds`, `posted_at: v.postedAt.toISOString()`. On video scraping failure, `console.warn` and continue -- video scraping failure is non-fatal.

5. **Insert junction row** using the **authenticated** `supabase` client (not service): `.insert({ user_id: user.id, competitor_id: profile.id })` into `user_competitors`. Catch Postgres error code `23505` (unique violation) and return `{ error: "You are already tracking this competitor" }`. Other errors: return `{ error: "Failed to track competitor" }`.

6. **Revalidate and return:** `revalidatePath("/competitors")` then `return { data: { competitorId: profile.id, handle: normalized } }`.

**Critical details:**
- Use service client for steps 3-4 (profile lookup, profile write, snapshot write, video write) because RLS on competitor_profiles SELECT requires an existing junction row which doesn't exist yet.
- Use auth client only for step 5 (junction row insert) because user_competitors INSERT policy requires `user_id = auth.uid()`.
- Use `.maybeSingle()` not `.single()` for the profile existence check to avoid throwing when profile doesn't exist.
  </action>
  <verify>
Run `npx tsc --noEmit` and confirm no TypeScript errors in `src/app/actions/competitors/add.ts`. Verify the file exports `addCompetitor` function with `"use server"` directive at top.
  </verify>
  <done>
`addCompetitor` server action exists at `src/app/actions/competitors/add.ts`. It normalizes handles, uses service client for profile lookup (bypasses RLS), scrapes via `createScrapingProvider()` for new handles, upserts profile + snapshot + videos with service client, inserts junction row with auth client, handles duplicate tracking via 23505 error code, and calls `revalidatePath("/competitors")`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create removeCompetitor server action</name>
  <files>src/app/actions/competitors/remove.ts</files>
  <action>
Create `src/app/actions/competitors/remove.ts` with `"use server"` directive.

**Imports:**
- `revalidatePath` from `next/cache`
- `createClient` from `@/lib/supabase/server`

**Export `removeCompetitor(competitorId: string): Promise<ActionResult>`:**

Return type `ActionResult = { error?: string; success?: boolean }`.

Flow:
1. **Auth check:** `const supabase = await createClient()`, `supabase.auth.getUser()`. Return `{ error: "Not authenticated" }` if no user.
2. **Validate competitorId:** Basic UUID format check -- if empty string, return `{ error: "Missing competitor ID" }`.
3. **Delete junction row** using auth client: `.delete().eq("user_id", user.id).eq("competitor_id", competitorId)` on `user_competitors`. RLS policy ensures user can only delete their own links.
4. If delete error, return `{ error: "Failed to remove competitor" }`.
5. `revalidatePath("/competitors")` then `return { success: true }`.

**Critical detail:** Do NOT delete from `competitor_profiles`, `competitor_snapshots`, or `competitor_videos`. Only delete the `user_competitors` junction row. The shared profile may be tracked by other users.
  </action>
  <verify>
Run `npx tsc --noEmit` and confirm no TypeScript errors in `src/app/actions/competitors/remove.ts`. Verify the file exports `removeCompetitor` function with `"use server"` directive at top.
  </verify>
  <done>
`removeCompetitor` server action exists at `src/app/actions/competitors/remove.ts`. It validates auth, deletes only the `user_competitors` junction row via the auth client (RLS-enforced), preserves the shared profile and all associated data, and calls `revalidatePath("/competitors")`.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors in `src/app/actions/competitors/`
2. Both files start with `"use server"` directive
3. `addCompetitor` imports `createServiceClient` for profile lookup (NOT auth client)
4. `addCompetitor` uses `createScrapingProvider()` (NOT direct `ApifyClient` import)
5. `addCompetitor` uses `normalizeHandle()` from Phase 1 schemas
6. `addCompetitor` handles 23505 duplicate error code
7. `removeCompetitor` only deletes from `user_competitors`, never touches `competitor_profiles`
8. Both actions call `revalidatePath("/competitors")`
</verification>

<success_criteria>
- Two server action files exist and compile without TypeScript errors
- addCompetitor correctly implements the junction table deduplication flow (find-or-create profile, then link)
- addCompetitor uses service client for profile operations and auth client for junction row
- removeCompetitor only removes the junction link, never the shared profile
- Both actions handle authentication and return structured error/success objects
</success_criteria>

<output>
After completion, create `.planning/phases/02-competitor-management/02-01-SUMMARY.md`
</output>
