---
phase: 09-hybrid-rules-dynamic-weights
plan: 03
type: execute
wave: 2
depends_on: ["09-01", "09-02"]
files_modified:
  - src/lib/engine/aggregator.ts
autonomous: true

must_haves:
  truths:
    - "When all four signal sources are available, weights are behavioral=0.45, gemini=0.25, rules=0.20, trends=0.10"
    - "When a signal source is missing or degraded, its weight is redistributed proportionally to remaining sources"
    - "Confidence calculation reflects signal availability — fewer signals = lower confidence"
    - "Weight selection logic is deterministic and testable given a known signal availability state"
  artifacts:
    - path: "src/lib/engine/aggregator.ts"
      provides: "Dynamic weight selection based on signal availability"
      exports: ["aggregateScores", "ENGINE_VERSION", "selectWeights"]
  key_links:
    - from: "src/lib/engine/aggregator.ts"
      to: "src/lib/engine/pipeline.ts"
      via: "PipelineResult stage outputs determine signal availability"
      pattern: "pipelineResult\\..*Result"
---

<objective>
Implement dynamic weight selection in the aggregator that adapts to available signals. When a pipeline stage fails or returns degraded data, its weight is redistributed proportionally to the remaining sources instead of using a zero-score at full weight.

Purpose: RULE-04 (signal-adaptive weights). Currently, if rules or trends fail, the aggregator still applies their 20%/10% weight to a default score of 50/0, which distorts the final prediction. Dynamic weights ensure the score reflects actual signal quality.

Output: Updated `src/lib/engine/aggregator.ts` with dynamic weight selection.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/engine/aggregator.ts
@src/lib/engine/pipeline.ts
@src/lib/engine/types.ts
@.planning/phases/09-hybrid-rules-dynamic-weights/09-01-SUMMARY.md
@.planning/phases/09-hybrid-rules-dynamic-weights/09-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement dynamic weight selection based on signal availability</name>
  <files>src/lib/engine/aggregator.ts</files>
  <action>
Add a `selectWeights` function to `src/lib/engine/aggregator.ts` that determines weights based on signal availability, and integrate it into `aggregateScores`.

**1. Define signal availability detection:**

```typescript
interface SignalAvailability {
  behavioral: boolean; // DeepSeek produced component scores
  gemini: boolean;     // Gemini produced factor scores (always true — critical stage)
  rules: boolean;      // Rule scoring produced real matches (not default fallback)
  trends: boolean;     // Trend enrichment found matches (not default fallback)
}
```

Determine availability from PipelineResult:
- `behavioral`: `pipelineResult.deepseekResult !== null` (always true since DeepSeek is critical, but defensive)
- `gemini`: `true` (Gemini is critical — pipeline throws if it fails)
- `rules`: `pipelineResult.ruleResult.matched_rules.length > 0` — if zero matches, the rules stage produced no useful signal (either failed with default or genuinely no matches). Use the pipeline warnings to distinguish: if warnings include "Rule scoring unavailable", treat as missing.
- `trends`: `pipelineResult.trendEnrichment.matched_trends.length > 0` — same logic. If warnings include "Trend enrichment unavailable", treat as missing.

**2. Create `selectWeights` function:**

```typescript
export function selectWeights(
  availability: SignalAvailability
): { behavioral: number; gemini: number; rules: number; trends: number } {
  // Base weights (when all signals available)
  const BASE = { behavioral: 0.45, gemini: 0.25, rules: 0.20, trends: 0.10 };

  // If all available, use base weights
  const available = Object.entries(availability).filter(([, v]) => v);
  const missing = Object.entries(availability).filter(([, v]) => !v);

  if (missing.length === 0) return { ...BASE };

  // Redistribute missing weight proportionally to available sources
  const missingWeight = missing.reduce(
    (sum, [key]) => sum + BASE[key as keyof typeof BASE], 0
  );

  const availableWeight = available.reduce(
    (sum, [key]) => sum + BASE[key as keyof typeof BASE], 0
  );

  // Each available source gets its base weight + proportional share of missing weight
  const result = { behavioral: 0, gemini: 0, rules: 0, trends: 0 };
  for (const [key, isAvailable] of Object.entries(availability)) {
    const k = key as keyof typeof BASE;
    if (isAvailable) {
      result[k] = BASE[k] + (BASE[k] / availableWeight) * missingWeight;
    }
    // Missing sources get weight 0
  }

  // Round to avoid floating point noise, ensure they sum to ~1
  const total = Object.values(result).reduce((a, b) => a + b, 0);
  for (const key of Object.keys(result) as (keyof typeof result)[]) {
    result[key] = Math.round((result[key] / total) * 1000) / 1000;
  }

  return result;
}
```

**3. Integrate into `aggregateScores`:**

Replace the static `SCORE_WEIGHTS` usage with dynamic selection:

```typescript
// Determine signal availability from pipeline result
const availability: SignalAvailability = {
  behavioral: pipelineResult.deepseekResult !== null,
  gemini: true, // Always true — critical stage
  rules: pipelineResult.ruleResult.matched_rules.length > 0
    && !pipelineResult.warnings.some(w => w.includes('Rule scoring unavailable')),
  trends: pipelineResult.trendEnrichment.matched_trends.length > 0
    && !pipelineResult.warnings.some(w => w.includes('Trend enrichment unavailable')),
};

const weights = selectWeights(availability);
```

Then use `weights` instead of `SCORE_WEIGHTS` in the overall_score calculation.

**4. Keep `SCORE_WEIGHTS` const** as the base/default (for export transparency in PredictionResult.score_weights). But update `score_weights` in the result to use the ACTUAL weights applied:

```typescript
score_weights: weights, // Actual weights used (may differ from BASE if signals missing)
```

**5. Update confidence calculation** to reflect signal availability:
- In `calculateConfidence`, the signal availability component already accounts for some of this. Add a small penalty when rules or trends are missing:
  - If `!availability.rules`: subtract 0.05 from signal component
  - If `!availability.trends`: subtract 0.05 from signal component
  This makes confidence honestly lower when we have fewer signals.

**6. Add a warning when weights are redistributed:**
```typescript
if (Object.entries(availability).some(([, v]) => !v)) {
  const missingSources = Object.entries(availability)
    .filter(([, v]) => !v)
    .map(([k]) => k);
  warnings.push(`Weights redistributed — missing signals: ${missingSources.join(', ')}`);
}
```

**Important constraints:**
- Do NOT change the aggregateScores function signature or return type
- PredictionResult.score_weights field stays the same shape `{ behavioral, gemini, rules, trends }`
- When all signals are available, output must be IDENTICAL to current behavior
- Export `selectWeights` for potential testing in Phase 12
  </action>
  <verify>
- `pnpm tsc --noEmit` passes
- When all signals available, weights === BASE (0.45/0.25/0.20/0.10)
- When rules missing, its 0.20 weight redistributes proportionally to behavioral/gemini/trends
- When both rules and trends missing, their combined 0.30 weight redistributes to behavioral/gemini
- `score_weights` in result reflects actual weights used
- Missing signals generate a warning in the warnings array
  </verify>
  <done>
- Dynamic weight selection adapts to signal availability
- Missing signal weight redistributed proportionally to remaining sources
- Confidence penalty for missing signals
- PredictionResult.score_weights shows actual applied weights
- Full backward compatibility when all signals present
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify aggregator integration with pipeline and compilation</name>
  <files>src/lib/engine/aggregator.ts</files>
  <action>
**1. Verify the integration points:**
- Confirm `aggregateScores(pipelineResult)` call in `src/app/api/analyze/route.ts` needs no changes (it passes full PipelineResult which contains warnings array)
- Confirm `PipelineResult` interface in pipeline.ts has `warnings` field (it does — verified)
- Confirm `PredictionResult.score_weights` type allows any numbers (it does — `{ behavioral: number; gemini: number; rules: number; trends: number }`)

**2. Run full type-check:**
```bash
pnpm tsc --noEmit
```

**3. Verify no regression scenarios:**
- With all signals: behavioral=0.45, gemini=0.25, rules=0.20, trends=0.10 (unchanged)
- With rules missing: behavioral=~0.5625, gemini=~0.3125, trends=~0.125 (redistributed)
- With rules+trends missing: behavioral=~0.643, gemini=~0.357 (only two sources)

**4. Update ENGINE_VERSION** to "2.1.0" to reflect the dynamic weights capability. This helps with debugging which version of the aggregator was used.
  </action>
  <verify>
- `pnpm tsc --noEmit` passes with zero errors
- ENGINE_VERSION updated to "2.1.0"
- No changes needed in pipeline.ts or route.ts
  </verify>
  <done>
- Full type-check passes
- Integration verified — no downstream changes needed
- ENGINE_VERSION bumped to reflect dynamic weights
  </done>
</task>

</tasks>

<verification>
1. `pnpm tsc --noEmit` passes — no type errors
2. `selectWeights` with all signals returns base weights exactly
3. `selectWeights` with missing rules redistributes 0.20 proportionally
4. `aggregateScores` uses dynamic weights from signal availability
5. `PredictionResult.score_weights` reflects actual applied weights
6. Missing signals produce a warning in the warnings array
7. Confidence adjusted for missing signals
</verification>

<success_criteria>
- Dynamic weight selection adapts to pipeline signal availability
- Weight redistribution is proportional (not arbitrary)
- Full backward compatibility: all signals present = identical output to current
- Missing signals produce both a weight redistribution and a confidence penalty
- TypeScript compiles with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-hybrid-rules-dynamic-weights/09-03-SUMMARY.md`
</output>
