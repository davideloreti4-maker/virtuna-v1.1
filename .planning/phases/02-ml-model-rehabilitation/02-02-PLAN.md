---
phase: 02-ml-model-rehabilitation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/engine/aggregator.ts
  - src/lib/engine/types.ts
  - src/app/api/analyze/route.ts
autonomous: true

must_haves:
  truths:
    - "aggregateScores() is async and calls predictWithML() to get the ML score"
    - "SCORE_WEIGHTS has 5 signals: behavioral 0.35, gemini 0.25, ml 0.15, rules 0.15, trends 0.10"
    - "selectWeights() handles ML signal availability — when ML model is not loaded, 15% redistributes proportionally"
    - "PredictionResult.score_weights includes an ml field"
    - "analysis_results DB insert includes ml_score field"
    - "The overall_score formula includes the ML signal contribution"
  artifacts:
    - path: "src/lib/engine/aggregator.ts"
      provides: "5-signal async aggregator with ML integration"
      contains: "predictWithML"
    - path: "src/lib/engine/types.ts"
      provides: "Updated PredictionResult.score_weights with ml field"
      contains: "ml: number"
    - path: "src/app/api/analyze/route.ts"
      provides: "Async aggregateScores call and ml_score DB insert"
      contains: "ml_score"
  key_links:
    - from: "src/lib/engine/aggregator.ts:aggregateScores"
      to: "src/lib/engine/ml.ts:predictWithML"
      via: "async call with featureVectorToMLInput"
      pattern: "await predictWithML"
    - from: "src/app/api/analyze/route.ts"
      to: "src/lib/engine/aggregator.ts:aggregateScores"
      via: "await (was sync call)"
      pattern: "await aggregateScores"
    - from: "src/app/api/analyze/route.ts"
      to: "analysis_results insert"
      via: "ml_score field"
      pattern: "ml_score.*result"
---

<objective>
Wire the ML signal into the aggregator as a 5th scoring source, update types for the ml weight field, make aggregateScores async, and persist ml_score in the analysis_results DB insert.

Purpose: The ML classifier exists but is never called. This plan connects it to every prediction, giving it 15% weight influence and storing its score for tracking.

Output: An async 5-signal aggregator, updated PredictionResult type, and ml_score persisted to the database on every analysis.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ml-model-rehabilitation/02-RESEARCH.md
@src/lib/engine/aggregator.ts
@src/lib/engine/types.ts
@src/lib/engine/ml.ts
@src/app/api/analyze/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update SCORE_WEIGHTS, SignalAvailability, selectWeights, and aggregateScores to 5-signal async</name>
  <files>src/lib/engine/aggregator.ts</files>
  <action>
Make the following changes to aggregator.ts:

1. **Add imports** at the top (after existing imports):
   ```typescript
   import { predictWithML, featureVectorToMLInput } from "./ml";
   ```

2. **Update SCORE_WEIGHTS** (line 20-25):
   ```typescript
   const SCORE_WEIGHTS = {
     behavioral: 0.35,
     gemini: 0.25,
     ml: 0.15,
     rules: 0.15,
     trends: 0.10,
   } as const;
   ```

3. **Update SignalAvailability** interface (line 31-36) — add ml field:
   ```typescript
   interface SignalAvailability {
     behavioral: boolean;
     gemini: boolean;
     ml: boolean;       // ML model loaded and prediction succeeded
     rules: boolean;
     trends: boolean;
   }
   ```

4. **Update selectWeights** return type and result object (line 45-79):
   - Change return type to include `ml: number`
   - Change result initialization to include `ml: 0`
   - The existing proportional redistribution logic already works generically via `Object.entries(availability)` and `SCORE_WEIGHTS[key]` — it just needs the types updated

   Specifically:
   - Return type: `{ behavioral: number; gemini: number; ml: number; rules: number; trends: number }`
   - Initial result: `const result = { behavioral: 0, gemini: 0, ml: 0, rules: 0, trends: 0 };`
   - The `Object.entries` loop and weight redistribution math work unchanged because they read from `SCORE_WEIGHTS` which now includes `ml`

5. **Make aggregateScores async** (line 210):
   Change: `export function aggregateScores(pipelineResult: PipelineResult): PredictionResult`
   To: `export async function aggregateScores(pipelineResult: PipelineResult): Promise<PredictionResult>`

6. **Add ML prediction call** inside aggregateScores, after the `assembleFeatureVector` call (before the overall score computation):
   ```typescript
   // ML prediction (async — loads model from Supabase Storage on cold start)
   const feature_vector = assembleFeatureVector(pipelineResult);
   const mlFeatures = featureVectorToMLInput(feature_vector);
   const mlScore = await predictWithML(mlFeatures);
   const mlAvailable = mlScore !== null;
   ```

   Move the `assembleFeatureVector` call from its current position (line 336) to BEFORE the overall score computation (it's needed for ML input). Adjust the `feature_vector` reference in the return object accordingly.

7. **Update availability object** — add ml:
   ```typescript
   const availability: SignalAvailability = {
     behavioral: deepseekResult !== null,
     gemini: true,
     ml: mlAvailable,
     rules: ruleResult.matched_rules.length > 0 && !pipelineResult.warnings.some(w => w.includes('Rule scoring unavailable')),
     trends: trendEnrichment.matched_trends.length > 0 && !pipelineResult.warnings.some(w => w.includes('Trend enrichment unavailable')),
   };
   ```

8. **Update overall_score formula** to include ML signal:
   ```typescript
   const overall_score = Math.min(100, Math.max(0, Math.round(
     behavioral_score * weights.behavioral +
     gemini_score * weights.gemini +
     (mlScore ?? 0) * weights.ml +
     ruleResult.rule_score * weights.rules +
     trendEnrichment.trend_score * weights.trends
   )));
   ```

9. **Add ml_score to the return object** — add a new field `ml_score` to the returned PredictionResult:
   Add `ml_score: mlScore ?? 0,` in the return statement.
  </action>
  <verify>
    Run `npx tsc --noEmit` — check for type errors.
    Grep aggregator.ts for `predictWithML` — should appear in import and in function body.
    Grep for `ml: 0.15` in SCORE_WEIGHTS.
    Grep for `async function aggregateScores` — confirm it's async.
  </verify>
  <done>
    aggregateScores() is async, calls predictWithML(), uses 5-signal weights (behavioral 0.35, gemini 0.25, ml 0.15, rules 0.15, trends 0.10), handles ML unavailability via weight redistribution, and includes ml_score in the result.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update PredictionResult type and analyze route for async aggregator + ml_score</name>
  <files>src/lib/engine/types.ts, src/app/api/analyze/route.ts</files>
  <action>
**In types.ts:**

1. Add `ml: number` to the `score_weights` field in PredictionResult (line 150-155):
   ```typescript
   score_weights: {
     behavioral: number;
     gemini: number;
     ml: number;
     rules: number;
     trends: number;
   };
   ```

2. Add `ml_score: number` field to PredictionResult interface, near the other scoring fields (after `behavioral_score: number;` at line 149):
   ```typescript
   ml_score: number;        // ML classifier score (0-100), 0 if model unavailable
   ```

**In analyze/route.ts:**

3. Change the aggregateScores call (line 172) from sync to async:
   ```typescript
   // Old:
   const result = aggregateScores(pipelineResult);
   // New:
   const result = await aggregateScores(pipelineResult);
   ```

4. Add `ml_score` to the DB insert (after `gemini_score` at line ~216):
   ```typescript
   gemini_score: finalResult.gemini_score,
   ml_score: finalResult.ml_score,
   ```

The `analysis_results.ml_score` column already exists in the database (confirmed in research — database.types.ts line 660, `number | null`). No migration needed.
  </action>
  <verify>
    Run `npx tsc --noEmit` — no type errors across the project.
    Grep types.ts for `ml: number` inside score_weights — should be present.
    Grep types.ts for `ml_score: number` — should be present in PredictionResult.
    Grep analyze/route.ts for `await aggregateScores` — should be present.
    Grep analyze/route.ts for `ml_score:` — should appear in the DB insert.
  </verify>
  <done>
    PredictionResult.score_weights includes ml field. PredictionResult has ml_score field. analyze/route.ts awaits aggregateScores and persists ml_score in every DB insert.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors across the entire project
2. SCORE_WEIGHTS in aggregator.ts sums to 1.0 (0.35 + 0.25 + 0.15 + 0.15 + 0.10)
3. selectWeights() handles all permutations of signal availability (especially ml=false redistributing 15%)
4. PredictionResult type includes both `ml_score` and `score_weights.ml`
5. analyze/route.ts uses `await aggregateScores(...)` and includes `ml_score` in DB insert
6. When ML model is unavailable (not trained yet), predictions still work — ML weight redistributes to other signals
</verification>

<success_criteria>
- aggregateScores is async and calls predictWithML
- Weight schema is 5-signal with ml at 15%
- ML unavailability gracefully redistributes weight
- ml_score stored in every analysis_results row
- No regressions — existing predictions work even without ML model
</success_criteria>

<output>
After completion, create `.planning/phases/02-ml-model-rehabilitation/02-02-SUMMARY.md`
</output>
