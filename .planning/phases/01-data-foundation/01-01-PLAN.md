---
phase: 01-data-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260216100000_competitor_tables.sql
  - src/lib/supabase/service.ts
  - src/types/database.types.ts
autonomous: true

must_haves:
  truths:
    - "competitor_profiles table exists with tiktok_handle UNIQUE constraint and BIGINT metric counters"
    - "user_competitors junction table links users to competitor profiles for deduplication"
    - "competitor_snapshots table records one snapshot per competitor per day via UNIQUE(competitor_id, snapshot_date)"
    - "competitor_videos table stores per-video metrics with UNIQUE(competitor_id, platform_video_id)"
    - "RLS policies use (SELECT auth.uid()) pattern and gate access through user_competitors junction table"
    - "Service role client exists for webhook/cron operations that bypass RLS"
  artifacts:
    - path: "supabase/migrations/20260216100000_competitor_tables.sql"
      provides: "Competitor tables, indexes, RLS policies, triggers"
      contains: "CREATE TABLE competitor_profiles"
    - path: "src/lib/supabase/service.ts"
      provides: "Service role Supabase client factory"
      exports: ["createServiceClient"]
    - path: "src/types/database.types.ts"
      provides: "Regenerated database types including competitor tables"
      contains: "competitor_profiles"
  key_links:
    - from: "supabase/migrations/20260216100000_competitor_tables.sql"
      to: "src/types/database.types.ts"
      via: "supabase gen types typescript"
      pattern: "competitor_profiles.*competitor_snapshots.*competitor_videos"
    - from: "src/lib/supabase/service.ts"
      to: "SUPABASE_SERVICE_ROLE_KEY"
      via: "createClient with service role key"
      pattern: "createClient.*SUPABASE_SERVICE_ROLE_KEY"
---

<objective>
Create the database schema for competitor intelligence: four tables (competitor_profiles, user_competitors, competitor_snapshots, competitor_videos), RLS policies gated through the junction table, performance indexes, and the service role client needed for scraping ingestion.

Purpose: Establish the data foundation that all subsequent phases build on. The deduplication model (shared profiles linked via junction table) is the core architectural decision.
Output: Migration file, service client, regenerated database types.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-data-foundation/01-RESEARCH.md
@supabase/migrations/20260202000000_v16_schema.sql
@src/lib/supabase/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create competitor tables migration with RLS and indexes</name>
  <files>supabase/migrations/20260216100000_competitor_tables.sql</files>
  <action>
Create a single Supabase migration file with the following, in order:

**1. Helper function (CREATE OR REPLACE):**
- `update_updated_at_column()` — sets `NEW.updated_at = NOW()` and returns NEW. Use `CREATE OR REPLACE FUNCTION` so it's idempotent.

**2. Tables (follow exact conventions from existing `20260202000000_v16_schema.sql`):**

`competitor_profiles`:
- `id UUID PRIMARY KEY DEFAULT gen_random_uuid()`
- `tiktok_handle TEXT NOT NULL UNIQUE` — normalized (lowercase, no @)
- `display_name TEXT`, `bio TEXT`, `avatar_url TEXT`
- `verified BOOLEAN DEFAULT FALSE`
- `follower_count BIGINT DEFAULT 0`, `following_count BIGINT DEFAULT 0`, `heart_count BIGINT DEFAULT 0` — BIGINT, not INTEGER (viral creators exceed MAX_INT)
- `video_count INTEGER DEFAULT 0`
- `last_scraped_at TIMESTAMPTZ`
- `scrape_status TEXT DEFAULT 'pending' CHECK (scrape_status IN ('pending', 'scraping', 'success', 'failed'))` — TEXT+CHECK, not ENUM
- `created_at TIMESTAMPTZ DEFAULT NOW()`, `updated_at TIMESTAMPTZ DEFAULT NOW()`

`user_competitors` (junction table for deduplication):
- `id UUID PRIMARY KEY DEFAULT gen_random_uuid()`
- `user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE`
- `competitor_id UUID NOT NULL REFERENCES competitor_profiles(id) ON DELETE CASCADE`
- `added_at TIMESTAMPTZ DEFAULT NOW()`
- `UNIQUE(user_id, competitor_id)`

`competitor_snapshots` (daily time-series, append-only):
- `id UUID PRIMARY KEY DEFAULT gen_random_uuid()`
- `competitor_id UUID NOT NULL REFERENCES competitor_profiles(id) ON DELETE CASCADE`
- `follower_count BIGINT NOT NULL`, `following_count BIGINT NOT NULL`, `heart_count BIGINT NOT NULL`
- `video_count INTEGER NOT NULL`
- `snapshot_date DATE NOT NULL DEFAULT CURRENT_DATE`
- `created_at TIMESTAMPTZ DEFAULT NOW()`
- `UNIQUE(competitor_id, snapshot_date)` — one snapshot per competitor per day

`competitor_videos`:
- `id UUID PRIMARY KEY DEFAULT gen_random_uuid()`
- `competitor_id UUID NOT NULL REFERENCES competitor_profiles(id) ON DELETE CASCADE`
- `platform_video_id TEXT NOT NULL`
- `video_url TEXT`, `caption TEXT`
- `views BIGINT DEFAULT 0`, `likes BIGINT DEFAULT 0`, `comments BIGINT DEFAULT 0`, `shares BIGINT DEFAULT 0`, `saves BIGINT DEFAULT 0` — all BIGINT
- `hashtags TEXT[] DEFAULT '{}'`
- `duration_seconds INTEGER`
- `posted_at TIMESTAMPTZ`
- `created_at TIMESTAMPTZ DEFAULT NOW()`, `updated_at TIMESTAMPTZ DEFAULT NOW()`
- `UNIQUE(competitor_id, platform_video_id)`

**3. Indexes:**
- `idx_user_competitors_user_id ON user_competitors(user_id)` — RLS subquery performance
- `idx_user_competitors_competitor_id ON user_competitors(competitor_id)` — RLS subquery performance
- `idx_competitor_snapshots_competitor_id ON competitor_snapshots(competitor_id)`
- `idx_competitor_snapshots_date ON competitor_snapshots(snapshot_date)` — range query performance for growth charts
- `idx_competitor_videos_competitor_id ON competitor_videos(competitor_id)`
- `idx_competitor_videos_posted_at ON competitor_videos(posted_at DESC)` — recent videos sorting
- `idx_competitor_profiles_scrape_status ON competitor_profiles(scrape_status)` — cron batch query

**4. RLS Enable + Policies:**

Enable RLS on ALL four tables.

`user_competitors`:
- SELECT: `user_id = (SELECT auth.uid())` TO authenticated
- INSERT: `user_id = (SELECT auth.uid())` WITH CHECK, TO authenticated
- DELETE: `user_id = (SELECT auth.uid())` TO authenticated

`competitor_profiles`:
- SELECT: `id IN (SELECT competitor_id FROM user_competitors WHERE user_id = (SELECT auth.uid()))` TO authenticated
- INSERT: TO authenticated WITH CHECK (true) — any authenticated user can create a profile (needed for add-competitor flow). The profile itself is shared.

`competitor_snapshots`:
- SELECT: `competitor_id IN (SELECT competitor_id FROM user_competitors WHERE user_id = (SELECT auth.uid()))` TO authenticated

`competitor_videos`:
- SELECT: `competitor_id IN (SELECT competitor_id FROM user_competitors WHERE user_id = (SELECT auth.uid()))` TO authenticated

**5. Triggers:**
- `update_updated_at_column()` trigger on `competitor_profiles` BEFORE UPDATE
- `update_updated_at_column()` trigger on `competitor_videos` BEFORE UPDATE

Use section comment headers (matching existing style: `-- =====================================================`) to separate tables, indexes, RLS, and triggers.
  </action>
  <verify>
Run `npx supabase db lint` (if available) or manually verify the SQL syntax is valid by checking the migration file structure matches existing migration patterns. Verify all four tables are created, all indexes exist, all RLS policies use `(SELECT auth.uid())`, and triggers are set up.
  </verify>
  <done>Migration file exists at `supabase/migrations/20260216100000_competitor_tables.sql` with 4 tables, 7 indexes, 7 RLS policies, 1 helper function, and 2 update triggers. All metric counters use BIGINT. Status field uses TEXT+CHECK. Junction table enables deduplication.</done>
</task>

<task type="auto">
  <name>Task 2: Create service role client and regenerate database types</name>
  <files>src/lib/supabase/service.ts, src/types/database.types.ts</files>
  <action>
**Part A: Service role client (`src/lib/supabase/service.ts`)**

Create the service role client factory following the existing `server.ts` pattern but simpler (no cookies needed):

```typescript
import { createClient } from "@supabase/supabase-js";
import type { Database } from "@/types/database.types";

/**
 * Creates a Supabase client with the service role key.
 * Bypasses RLS — use ONLY in server-side contexts:
 * webhook handlers, cron routes, background jobs.
 *
 * NEVER import this in client components or expose the key.
 */
export function createServiceClient() {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;

  return createClient<Database>(supabaseUrl, serviceRoleKey, {
    auth: {
      autoRefreshToken: false,
      persistSession: false,
    },
  });
}
```

**Part B: Regenerate database types**

Run: `npx supabase gen types typescript --local > src/types/database.types.ts`

If the local Supabase instance is not running or the command fails, note in the summary that types need regeneration after `supabase db push` or `supabase start`. Do NOT manually create the types file — it must be auto-generated.

If `database.types.ts` already exists, verify the regenerated version includes `competitor_profiles`, `user_competitors`, `competitor_snapshots`, and `competitor_videos` table types. If local Supabase is not available, verify the migration SQL is valid and document that type regeneration is pending.
  </action>
  <verify>
1. `src/lib/supabase/service.ts` exports `createServiceClient` function
2. The function uses `SUPABASE_SERVICE_ROLE_KEY` (not anon key)
3. The function passes `Database` generic type
4. `auth.persistSession` is false (service client should not persist sessions)
5. If types were regenerated: `grep "competitor_profiles" src/types/database.types.ts` returns matches
  </verify>
  <done>Service client at `src/lib/supabase/service.ts` exports `createServiceClient()` with service role key, typed with `Database` generic. Database types regenerated (or flagged for regeneration if local Supabase unavailable).</done>
</task>

</tasks>

<verification>
1. Migration file contains all 4 tables with correct column types (BIGINT for metrics, TEXT+CHECK for status)
2. All RLS policies use `(SELECT auth.uid())` pattern — NOT bare `auth.uid()`
3. Junction table `user_competitors` has UNIQUE(user_id, competitor_id)
4. Snapshot table has UNIQUE(competitor_id, snapshot_date) for daily dedup
5. Video table has UNIQUE(competitor_id, platform_video_id) for video dedup
6. Service client uses service role key, not anon key
7. Indexes exist for all RLS-referenced columns (user_id, competitor_id)
</verification>

<success_criteria>
- Migration file creates competitor_profiles, user_competitors, competitor_snapshots, competitor_videos with proper constraints
- RLS policies gate competitor data access through the user_competitors junction table
- Service role client ready for scraping ingestion (bypasses RLS)
- Database types include competitor table definitions (regenerated or pending)
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation/01-01-SUMMARY.md`
</output>
