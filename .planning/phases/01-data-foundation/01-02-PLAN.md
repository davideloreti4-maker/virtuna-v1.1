---
phase: 01-data-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/schemas/competitor.ts
  - src/lib/scraping/types.ts
  - src/lib/scraping/apify-provider.ts
  - src/lib/scraping/index.ts
  - package.json
  - package-lock.json
autonomous: true

must_haves:
  truths:
    - "Apify profile scraper returns validated ProfileData (handle, followerCount, heartCount, videoCount, bio, avatarUrl)"
    - "Apify video scraper returns validated VideoData[] with per-video metrics (views, likes, comments, shares, saves, hashtags, duration)"
    - "All scraped data passes through Zod schemas before any database operation"
    - "Invalid video records are skipped (safeParse) without crashing the batch"
    - "TikTok handles are normalized (lowercase, no @, URL extraction) via Zod transform"
    - "Scraping is abstracted behind ScrapingProvider interface — Apify can be swapped"
  artifacts:
    - path: "src/lib/schemas/competitor.ts"
      provides: "Zod validation schemas for Apify profile and video output"
      exports: ["apifyProfileSchema", "apifyVideoSchema", "ApifyProfile", "ApifyVideo", "normalizeHandle"]
    - path: "src/lib/scraping/types.ts"
      provides: "ScrapingProvider interface and domain data types"
      exports: ["ScrapingProvider", "ProfileData", "VideoData"]
    - path: "src/lib/scraping/apify-provider.ts"
      provides: "Apify implementation of ScrapingProvider"
      exports: ["ApifyScrapingProvider"]
    - path: "src/lib/scraping/index.ts"
      provides: "Default provider factory and barrel exports"
      exports: ["createScrapingProvider", "ScrapingProvider", "ProfileData", "VideoData"]
  key_links:
    - from: "src/lib/scraping/apify-provider.ts"
      to: "src/lib/schemas/competitor.ts"
      via: "import apifyProfileSchema, apifyVideoSchema"
      pattern: "import.*from.*@/lib/schemas/competitor"
    - from: "src/lib/scraping/apify-provider.ts"
      to: "src/lib/scraping/types.ts"
      via: "implements ScrapingProvider"
      pattern: "implements ScrapingProvider"
    - from: "src/lib/scraping/index.ts"
      to: "src/lib/scraping/apify-provider.ts"
      via: "factory creates ApifyScrapingProvider"
      pattern: "new ApifyScrapingProvider"
---

<objective>
Build the Apify scraping service layer with Zod validation at the ingestion boundary. This creates the ScrapingProvider abstraction, the Apify implementation, and the Zod schemas that validate all scraped data before it touches the database.

Purpose: Scraped TikTok data must be validated and normalized before database insertion. The provider abstraction ensures the scraping backend can be swapped without touching data or UI layers.
Output: Zod schemas, ScrapingProvider interface, Apify provider implementation, barrel exports, apify-client dependency installed.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-data-foundation/01-RESEARCH.md
@.planning/phases/01-data-foundation/01-01-SUMMARY.md
@src/lib/supabase/service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install apify-client and create Zod validation schemas</name>
  <files>package.json, package-lock.json, src/lib/schemas/competitor.ts</files>
  <action>
**Part A: Install dependency**

Run: `npm install apify-client@^2.22.0`

This is needed because backend-foundation has not been merged into this worktree. Verify installation with `grep apify-client package.json`.

**Part B: Create Zod schemas (`src/lib/schemas/competitor.ts`)**

Create the schemas directory if it doesn't exist (`src/lib/schemas/`).

The file must contain:

1. **`normalizeHandle(input: string): string`** — Exported utility function:
   - `trim()` the input
   - Extract handle from TikTok URLs: match `/tiktok\.com\/@?([a-zA-Z0-9_.]+)/`
   - Strip leading `@`
   - Lowercase
   - Return the normalized handle

2. **`apifyProfileSchema`** — Zod object schema for Apify profile scraper output:
   - `uniqueId: z.string().transform(normalizeHandle)` — the TikTok handle
   - `nickname: z.string().optional().default("")` — display name
   - `signature: z.string().optional().default("")` — bio
   - `avatarLarger: z.string().url().optional()` — avatar URL (may be absent)
   - `verified: z.boolean().optional().default(false)`
   - `followerCount: z.coerce.number().int().nonnegative().default(0)` — coerce handles string→number from Apify
   - `followingCount: z.coerce.number().int().nonnegative().default(0)`
   - `heartCount: z.coerce.number().int().nonnegative().default(0)`
   - `videoCount: z.coerce.number().int().nonnegative().default(0)`

   Use `z.coerce.number()` for all numeric fields because Apify actors sometimes return strings for large numbers.

3. **`apifyVideoSchema`** — Zod object schema for Apify video scraper output:
   - `id: z.string()` — platform video ID
   - `webVideoUrl: z.string().url().optional()` — direct video URL
   - `text: z.string().optional().default("")` — caption
   - `createTime: z.coerce.number().optional()` — Unix timestamp (seconds)
   - `playCount: z.coerce.number().int().nonnegative().default(0)` — views
   - `diggCount: z.coerce.number().int().nonnegative().default(0)` — likes
   - `shareCount: z.coerce.number().int().nonnegative().default(0)`
   - `commentCount: z.coerce.number().int().nonnegative().default(0)`
   - `collectCount: z.coerce.number().int().nonnegative().default(0)` — saves/bookmarks
   - `hashtags: z.array(z.object({ name: z.string() })).optional().default([])` — Apify returns `[{name: "tag"}]`
   - `videoMeta: z.object({ duration: z.coerce.number().optional() }).optional()` — nested duration

4. **Type exports:**
   - `export type ApifyProfile = z.infer<typeof apifyProfileSchema>;`
   - `export type ApifyVideo = z.infer<typeof apifyVideoSchema>;`

Import `z` from `"zod"` (already installed at v4.3.6).
  </action>
  <verify>
1. `grep "apify-client" package.json` shows the dependency
2. `src/lib/schemas/competitor.ts` exists and exports `apifyProfileSchema`, `apifyVideoSchema`, `normalizeHandle`
3. Verify Zod import resolves: `npx tsc --noEmit src/lib/schemas/competitor.ts` (or check no red squiggles)
4. Test `normalizeHandle` mentally: `normalizeHandle("@CharlI")` → `"charli"`, `normalizeHandle("https://tiktok.com/@user123")` → `"user123"`
  </verify>
  <done>`apify-client` installed. Zod schemas validate profile and video data from Apify with coercion, defaults, and handle normalization. All numeric fields use `z.coerce.number()` to handle string-to-number conversion.</done>
</task>

<task type="auto">
  <name>Task 2: Create ScrapingProvider interface and Apify implementation</name>
  <files>src/lib/scraping/types.ts, src/lib/scraping/apify-provider.ts, src/lib/scraping/index.ts</files>
  <action>
Create the `src/lib/scraping/` directory if it doesn't exist.

**File 1: `src/lib/scraping/types.ts`** — Provider interface and domain types:

```typescript
export interface ProfileData {
  handle: string;
  displayName: string;
  bio: string;
  avatarUrl: string;
  verified: boolean;
  followerCount: number;
  followingCount: number;
  heartCount: number;
  videoCount: number;
}

export interface VideoData {
  platformVideoId: string;
  videoUrl: string;
  caption: string;
  views: number;
  likes: number;
  comments: number;
  shares: number;
  saves: number;
  hashtags: string[];
  durationSeconds: number;
  postedAt: Date;
}

export interface ScrapingProvider {
  /** Scrape a single TikTok profile by handle. Throws if profile not found. */
  scrapeProfile(handle: string): Promise<ProfileData>;

  /** Scrape recent videos for a TikTok handle. Returns validated videos (invalid items skipped). */
  scrapeVideos(handle: string, limit?: number): Promise<VideoData[]>;
}
```

**File 2: `src/lib/scraping/apify-provider.ts`** — Apify implementation:

- Import `ApifyClient` from `"apify-client"`
- Import `apifyProfileSchema`, `apifyVideoSchema` from `"@/lib/schemas/competitor"`
- Import `ProfileData`, `VideoData`, `ScrapingProvider` from `"./types"`

Class `ApifyScrapingProvider implements ScrapingProvider`:

Constructor:
- Accept optional `token?: string`
- Create `this.client = new ApifyClient({ token: token ?? process.env.APIFY_TOKEN! })`

Constants (at module level, NOT in class):
- `PROFILE_ACTOR = "clockworks/tiktok-profile-scraper"`
- `VIDEO_ACTOR = "clockworks/tiktok-scraper"` — Note: use `tiktok-scraper` for videos (NOT `tiktok-video-scraper`), as the main scraper returns video data with metrics

`scrapeProfile(handle: string)`:
- Use `this.client.actor(PROFILE_ACTOR).call({ profiles: [handle], resultsPerPage: 1 }, { waitForFinish: 60 })` — synchronous for single profile validation
- Get items from `this.client.dataset(run.defaultDatasetId).listItems()`
- If no items, throw `new Error(\`No profile data returned for handle: ${handle}\`)`
- Parse `items[0]` through `apifyProfileSchema.parse()` (throw on invalid — single profile must be valid)
- Map parsed result to `ProfileData`:
  - `handle: parsed.uniqueId`
  - `displayName: parsed.nickname`
  - `bio: parsed.signature`
  - `avatarUrl: parsed.avatarLarger ?? ""`
  - `verified: parsed.verified`
  - Numeric fields map directly

`scrapeVideos(handle: string, limit = 30)`:
- Use `this.client.actor(VIDEO_ACTOR).call({ profiles: [handle], resultsPerPage: limit }, { waitForFinish: 120 })` — synchronous is OK for small batches; async webhook pattern is for Phase 2 cron
- Get items from dataset
- Map each item through `apifyVideoSchema.safeParse(item)`:
  - On failure: `console.warn(\`[scraping] Video validation failed:\`, result.error.issues)` and return `null`
  - On success: map to `VideoData`:
    - `platformVideoId: v.id`
    - `videoUrl: v.webVideoUrl ?? ""`
    - `caption: v.text`
    - `views: v.playCount`
    - `likes: v.diggCount`
    - `comments: v.commentCount`
    - `shares: v.shareCount`
    - `saves: v.collectCount`
    - `hashtags: v.hashtags.map(h => h.name)`
    - `durationSeconds: v.videoMeta?.duration ?? 0`
    - `postedAt: v.createTime ? new Date(v.createTime * 1000) : new Date()`
- Filter nulls with type guard: `.filter((v): v is VideoData => v !== null)`

**File 3: `src/lib/scraping/index.ts`** — Barrel export and factory:

```typescript
export type { ScrapingProvider, ProfileData, VideoData } from "./types";
export { ApifyScrapingProvider } from "./apify-provider";

/**
 * Create the default scraping provider.
 * Currently returns Apify. Swap this factory to change provider
 * without touching any consumer code.
 */
export function createScrapingProvider(): ScrapingProvider {
  const { ApifyScrapingProvider } = require("./apify-provider");
  return new ApifyScrapingProvider();
}
```

Actually, use a dynamic import pattern to avoid importing ApifyClient at module level (tree-shaking):

```typescript
import type { ScrapingProvider, ProfileData, VideoData } from "./types";
export type { ScrapingProvider, ProfileData, VideoData };
export { ApifyScrapingProvider } from "./apify-provider";

export function createScrapingProvider(): ScrapingProvider {
  // Lazy import to avoid pulling apify-client into client bundles
  // eslint-disable-next-line @typescript-eslint/no-require-imports
  const { ApifyScrapingProvider } = require("./apify-provider");
  return new ApifyScrapingProvider();
}
```
  </action>
  <verify>
1. `src/lib/scraping/types.ts` exports `ScrapingProvider`, `ProfileData`, `VideoData`
2. `src/lib/scraping/apify-provider.ts` exports `ApifyScrapingProvider` implementing `ScrapingProvider`
3. `src/lib/scraping/index.ts` exports `createScrapingProvider` factory plus re-exports
4. TypeScript compiles without errors: `npx tsc --noEmit` (check scraping files specifically)
5. Apify provider imports Zod schemas from `@/lib/schemas/competitor` (key link verified)
6. Video scraping uses `safeParse` (graceful failure), profile scraping uses `parse` (strict)
  </verify>
  <done>ScrapingProvider interface abstracts data acquisition. ApifyScrapingProvider implements it with Zod validation at the ingestion boundary. Profile scraping throws on invalid data (strict), video scraping skips invalid items (graceful). Factory function enables provider swapping. All types re-exported from barrel.</done>
</task>

</tasks>

<verification>
1. `npm install` succeeds — `apify-client` resolves
2. `npx tsc --noEmit` — no type errors in new files
3. Zod schemas handle edge cases: string numbers coerced, missing optional fields defaulted, handles normalized
4. ScrapingProvider interface is the ONLY contract consumers depend on — ApifyScrapingProvider is an implementation detail
5. Profile scraping: strict validation (`.parse()`) — bad profile data should fail loudly
6. Video scraping: graceful validation (`.safeParse()`) — individual bad videos are skipped, batch continues
7. Handle normalization: "@Handle" → "handle", "https://tiktok.com/@User" → "user"
</verification>

<success_criteria>
- `apify-client` is in package.json dependencies
- Zod schemas validate and normalize all Apify output before any database operation
- ScrapingProvider interface enables provider swapping without consumer changes
- Profile scraper returns validated ProfileData for a given handle
- Video scraper returns validated VideoData[] with invalid items filtered out
- All files compile with TypeScript strict mode
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation/01-02-SUMMARY.md`
</output>
