---
phase: 04-payments
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - src/app/(marketing)/pricing/pricing-section.tsx
  - src/components/app/settings/billing-section.tsx
autonomous: true

must_haves:
  truths:
    - "After completing checkout on /pricing, user sees their tier update without page reload"
    - "Pricing page CTAs reflect current tier (no upgrade button for current/higher tier)"
    - "Billing section uses useSubscription hook for consistent state management"
    - "Billing section polls for tier change after checkout completion"
  artifacts:
    - path: "src/app/(marketing)/pricing/pricing-section.tsx"
      provides: "Post-checkout polling with feedback UI"
      contains: "pollForTierChange"
    - path: "src/components/app/settings/billing-section.tsx"
      provides: "Billing section using useSubscription hook"
      contains: "useSubscription"
  key_links:
    - from: "src/app/(marketing)/pricing/pricing-section.tsx"
      to: "src/hooks/use-subscription.ts"
      via: "useSubscription for polling and tier display"
      pattern: "useSubscription.*pollForTierChange"
    - from: "src/components/app/settings/billing-section.tsx"
      to: "src/hooks/use-subscription.ts"
      via: "useSubscription replaces local fetch"
      pattern: "useSubscription"
---

<objective>
Wire post-checkout tier refresh into pricing page and billing section so users see their updated tier immediately after payment without reloading.

Purpose: Without post-checkout refresh, users complete payment but still see "Get started" / "Start free trial" buttons, creating confusion. This plan closes the loop: pay -> confirm -> see new tier.

Output: Pricing page with post-checkout polling and tier-aware CTAs, billing section refactored to use useSubscription hook with post-checkout polling.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-payments/04-01-SUMMARY.md
@.planning/phases/04-payments/04-02-SUMMARY.md
@src/app/(marketing)/pricing/pricing-section.tsx
@src/components/app/settings/billing-section.tsx
@src/hooks/use-subscription.ts
@src/components/app/checkout-modal.tsx
@src/lib/whop/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add post-checkout polling and tier-aware CTAs to pricing page</name>
  <files>
    src/app/(marketing)/pricing/pricing-section.tsx
  </files>
  <action>
Enhance the pricing section (already auth-aware from 04-01) with post-checkout tier refresh and tier-aware CTA rendering.

1. Import `useSubscription` from `@/hooks/use-subscription` and `hasAccessToTier` from `@/lib/whop/config`.

2. Call `const { tier, isLoading: tierLoading, pollForTierChange, isPolling } = useSubscription();` inside the component.

3. Add state for post-checkout success: `const [checkoutSuccess, setCheckoutSuccess] = useState<'starter' | 'pro' | null>(null);`

4. Update the CheckoutModal `onComplete` callback:
```tsx
<CheckoutModal
  open={!!checkoutPlan}
  onClose={() => setCheckoutPlan(null)}
  planId={checkoutPlan}
  onComplete={async () => {
    const plan = checkoutPlan;
    setCheckoutPlan(null);
    if (plan) {
      const newTier = await pollForTierChange(tier);
      if (newTier !== tier) {
        setCheckoutSuccess(plan);
        // Auto-dismiss success after 5s
        setTimeout(() => setCheckoutSuccess(null), 5000);
      }
    }
  }}
/>
```

5. Add a success banner above the pricing cards (after the header, before the grid):
```tsx
{isPolling && (
  <div className="mb-8 flex items-center justify-center gap-2 rounded-xl border border-white/[0.06] bg-white/[0.02] px-4 py-3">
    <div className="h-4 w-4 animate-spin rounded-full border-2 border-accent border-t-transparent" />
    <span className="text-sm text-foreground-secondary">Confirming your subscription...</span>
  </div>
)}
{checkoutSuccess && !isPolling && (
  <div className="mb-8 flex items-center justify-center gap-2 rounded-xl border border-success/20 bg-success/5 px-4 py-3">
    <Check size={18} className="text-success" />
    <span className="text-sm text-white">
      Welcome to {checkoutSuccess === 'pro' ? 'Pro' : 'Starter'}! Your plan is now active.
    </span>
  </div>
)}
```

Import `Check` from `@phosphor-icons/react` (already imported).

6. Make CTAs tier-aware. For each plan card, conditionally render the CTA:

For Starter card:
- If `hasAccessToTier(tier, 'starter')` → render `<Button variant="secondary" size="lg" className="w-full" disabled>Current plan</Button>` (or "Included" for pro users)
- If NOT authenticated → keep Link to signup
- If authenticated and tier is 'free' → Button opens checkout

For Pro card:
- If `hasAccessToTier(tier, 'pro')` → render `<Button variant="primary" size="lg" className="w-full" disabled>Current plan</Button>`
- If NOT authenticated → keep Link to signup
- If authenticated and tier < 'pro' → Button opens checkout

Create a helper function inside the component:
```tsx
function renderCTA(planTier: 'starter' | 'pro') {
  if (!isAuthenticated) {
    return (
      <Button variant={planTier === 'pro' ? 'primary' : 'secondary'} size="lg" className="w-full" asChild>
        <Link href={`/auth/signup?plan=${planTier}`}>
          {planTier === 'pro' ? 'Start free trial' : 'Get started'}
        </Link>
      </Button>
    );
  }
  if (hasAccessToTier(tier, planTier)) {
    return (
      <Button variant={planTier === 'pro' ? 'primary' : 'secondary'} size="lg" className="w-full" disabled>
        {tier === planTier ? 'Current plan' : 'Included'}
      </Button>
    );
  }
  return (
    <Button
      variant={planTier === 'pro' ? 'primary' : 'secondary'}
      size="lg"
      className="w-full"
      onClick={() => setCheckoutPlan(planTier)}
    >
      {planTier === 'pro' ? 'Start free trial' : 'Get started'}
    </Button>
  );
}
```

Replace the hardcoded Button/Link in each card with `{renderCTA('starter')}` and `{renderCTA('pro')}`.
  </action>
  <verify>
1. Run `npx tsc --noEmit` — no errors.
2. Grep pricing-section.tsx for "pollForTierChange" — confirms polling wired.
3. Grep pricing-section.tsx for "checkoutSuccess" — confirms success feedback.
4. Grep pricing-section.tsx for "hasAccessToTier" — confirms tier-aware CTAs.
5. Grep pricing-section.tsx for "Current plan" — confirms disabled state for current tier.
  </verify>
  <done>
Pricing page polls for tier change after checkout, shows confirming/success banners, and CTAs reflect current tier. Users on Pro see "Current plan" instead of checkout buttons.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor billing section to use useSubscription hook with post-checkout polling</name>
  <files>
    src/components/app/settings/billing-section.tsx
  </files>
  <action>
Replace the local subscription fetching in BillingSection with the `useSubscription` hook for consistent state management and post-checkout polling.

1. Import `useSubscription` from `@/hooks/use-subscription`.

2. Replace the local state and fetching logic:

Remove:
- `const [subscription, setSubscription] = useState<SubscriptionData | null>(null);`
- `const [loading, setLoading] = useState(true);`
- The `fetchSubscription` callback and its useEffect
- The `handleCheckoutComplete` function
- The `SubscriptionData` interface (no longer needed locally)

Replace with:
```tsx
const {
  tier,
  status,
  isTrial,
  trialDaysRemaining,
  isLoading: loading,
  refetch,
  pollForTierChange,
  isPolling,
} = useSubscription();
```

Note: We still need `whopConnected`, `cancelAtPeriodEnd`, and `currentPeriodEnd`. The useSubscription hook returns the full data object. If needed, extend the destructure or access raw data.

Actually, since useSubscription exposes `tier`, `status`, `isTrial`, `trialEndsAt` but not all billing-specific fields, do this:
- Keep a local state `billingDetails` for the extra fields (whopConnected, cancelAtPeriodEnd, currentPeriodEnd)
- Fetch those on mount from `/api/subscription` in a one-time useEffect
- Use useSubscription for tier/status/trial info and polling

OR simpler approach: extend useSubscription's returned data to also expose the raw response fields. But since we don't want to modify use-subscription.ts in this plan (it belongs to 04-02), take the hybrid approach:

```tsx
const { tier, status, isTrial, trialDaysRemaining, pollForTierChange, isPolling } = useSubscription();
const [billingDetails, setBillingDetails] = useState<{
  whopConnected: boolean;
  cancelAtPeriodEnd: boolean;
  currentPeriodEnd: string | null;
} | null>(null);
const [loading, setLoading] = useState(true);

useEffect(() => {
  fetch("/api/subscription")
    .then((res) => res.ok ? res.json() : null)
    .then((data) => {
      if (data) {
        setBillingDetails({
          whopConnected: data.whopConnected ?? false,
          cancelAtPeriodEnd: data.cancelAtPeriodEnd ?? false,
          currentPeriodEnd: data.currentPeriodEnd ?? null,
        });
      }
    })
    .finally(() => setLoading(false));
}, []);
```

3. Update handleCheckoutComplete to use polling:
```tsx
const handleCheckoutComplete = async () => {
  const plan = checkoutPlan;
  setCheckoutPlan(null);
  if (plan) {
    await pollForTierChange(tier);
    // Refresh billing details too
    const res = await fetch("/api/subscription");
    if (res.ok) {
      const data = await res.json();
      setBillingDetails({
        whopConnected: data.whopConnected ?? false,
        cancelAtPeriodEnd: data.cancelAtPeriodEnd ?? false,
        currentPeriodEnd: data.currentPeriodEnd ?? null,
      });
    }
  }
};
```

4. Update references throughout the JSX:
- Replace `subscription?.tier ?? "free"` with `tier`
- Replace `subscription?.status ?? "active"` with `status`
- Replace `subscription?.cancelAtPeriodEnd` with `billingDetails?.cancelAtPeriodEnd`
- Replace `subscription?.whopConnected` with `billingDetails?.whopConnected`
- Replace `subscription?.currentPeriodEnd` with `billingDetails?.currentPeriodEnd`

5. Add trial info to the current plan card. After the status badge, if `isTrial`, add:
```tsx
{isTrial && trialDaysRemaining !== null && (
  <span className={`rounded-full px-2.5 py-1 text-xs font-medium ${
    trialDaysRemaining <= 3 ? 'text-warning bg-warning/10' : 'text-info bg-info/10'
  }`}>
    {trialDaysRemaining} {trialDaysRemaining === 1 ? 'day' : 'days'} left in trial
  </span>
)}
```

6. Add polling indicator. If `isPolling`, show a small "Updating..." text near the plan name:
```tsx
{isPolling && (
  <span className="text-xs text-foreground-muted animate-pulse">Updating...</span>
)}
```
  </action>
  <verify>
1. Run `npx tsc --noEmit` — no errors.
2. Run `pnpm build` — successful build.
3. Grep billing-section.tsx for "useSubscription" — confirms hook usage.
4. Grep billing-section.tsx for "pollForTierChange" — confirms post-checkout polling.
5. Grep billing-section.tsx for "isTrial" — confirms trial info display.
  </verify>
  <done>
Billing section uses useSubscription hook for tier/trial state, polls for tier change after checkout with "Updating..." indicator, shows trial days remaining badge when applicable. Build passes.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `pnpm build` succeeds
3. Pricing page shows "Confirming..." during polling and success banner after checkout
4. Pricing CTAs reflect current tier (disabled "Current plan" for active tier)
5. Billing section uses useSubscription hook and polls after checkout
6. Trial state shown in billing section
</verification>

<success_criteria>
- Post-checkout on /pricing: polling spinner -> success banner -> CTAs update to reflect new tier
- Pricing CTAs disabled for current/included tiers
- Billing section refactored to use useSubscription hook
- Billing section shows trial days remaining when applicable
- Both pages poll for tier change after Whop checkout completion
- No page reload needed to see updated subscription state
</success_criteria>

<output>
After completion, create `.planning/phases/04-payments/04-03-SUMMARY.md`
</output>
