---
phase: 06-ai-intelligence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260217000000_competitor_intelligence.sql
  - src/types/database.types.ts
  - src/lib/ai/types.ts
  - src/lib/ai/prompts.ts
  - src/lib/ai/deepseek.ts
  - src/lib/ai/gemini.ts
  - src/lib/ai/intelligence-service.ts
  - src/app/api/intelligence/[competitorId]/route.ts
autonomous: true
user_setup:
  - service: deepseek
    why: "AI-powered content strategy analysis"
    env_vars:
      - name: DEEPSEEK_API_KEY
        source: "https://platform.deepseek.com/api_keys"
  - service: gemini
    why: "AI-powered viral detection and hashtag recommendations"
    env_vars:
      - name: GEMINI_API_KEY
        source: "https://aistudio.google.com/apikey"

must_haves:
  truths:
    - "POST /api/intelligence/[competitorId] with analysis_type=strategy returns a Zod-validated strategy analysis object with hooks, content_series, psychological_triggers, overall_strategy, strengths, weaknesses"
    - "POST /api/intelligence/[competitorId] with analysis_type=viral returns viral video explanations for videos exceeding 3x average views"
    - "POST /api/intelligence/[competitorId] with analysis_type=hashtag_gap returns hashtag gap analysis comparing user vs competitor"
    - "POST /api/intelligence/[competitorId] with analysis_type=recommendations returns personalized content recommendations"
    - "GET /api/intelligence/[competitorId] returns cached insights from competitor_intelligence table without calling AI"
    - "Second call to the same analysis type returns cached data, not a fresh AI call"
  artifacts:
    - path: "supabase/migrations/20260217000000_competitor_intelligence.sql"
      provides: "competitor_intelligence table with RLS"
      contains: "CREATE TABLE competitor_intelligence"
    - path: "src/lib/ai/types.ts"
      provides: "Zod schemas for all 4 AI response types"
      exports: ["StrategyAnalysisSchema", "ViralExplanationSchema", "HashtagGapSchema", "RecommendationsSchema"]
    - path: "src/lib/ai/prompts.ts"
      provides: "Prompt builders for all 4 analysis types"
      exports: ["buildStrategyPrompt", "buildViralPrompt", "buildHashtagGapPrompt", "buildRecommendationsPrompt"]
    - path: "src/lib/ai/deepseek.ts"
      provides: "DeepSeek client for strategy + recommendations"
      exports: ["analyzeStrategy", "generateRecommendations"]
    - path: "src/lib/ai/gemini.ts"
      provides: "Gemini client for viral + hashtag gap"
      exports: ["explainViralVideos", "analyzeHashtagGap"]
    - path: "src/lib/ai/intelligence-service.ts"
      provides: "Orchestrator with caching layer"
      exports: ["getStrategyAnalysis", "getViralDetection", "getHashtagGap", "getRecommendations", "getAllIntelligence"]
    - path: "src/app/api/intelligence/[competitorId]/route.ts"
      provides: "API route for triggering and retrieving AI analysis"
      exports: ["GET", "POST"]
  key_links:
    - from: "src/app/api/intelligence/[competitorId]/route.ts"
      to: "src/lib/ai/intelligence-service.ts"
      via: "import orchestrator functions"
      pattern: "import.*intelligence-service"
    - from: "src/lib/ai/intelligence-service.ts"
      to: "src/lib/ai/deepseek.ts"
      via: "calls analyzeStrategy, generateRecommendations"
      pattern: "import.*deepseek"
    - from: "src/lib/ai/intelligence-service.ts"
      to: "src/lib/ai/gemini.ts"
      via: "calls explainViralVideos, analyzeHashtagGap"
      pattern: "import.*gemini"
    - from: "src/lib/ai/intelligence-service.ts"
      to: "competitor_intelligence table"
      via: "Supabase service client for cache read/write"
      pattern: 'from\\("competitor_intelligence"\\)'
---

<objective>
Build the AI analysis service layer: database table for caching AI responses, DeepSeek + Gemini client modules with Zod-validated structured output, prompt templates for 4 analysis types (strategy, viral, hashtag gap, recommendations), an orchestration service with database caching, and an API route to trigger/retrieve analysis.

Purpose: This is the data/logic backbone for Phase 6 intelligence. The UI plan (06-02) consumes cached insights via server component queries -- it needs this service layer in place.

Output: `src/lib/ai/` directory with 5 modules, migration file, database types update, API route.
</objective>

<execution_context>
@/Users/davideloreti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davideloreti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-ai-intelligence/06-RESEARCH.md
@.planning/phases/04-detail-page-analytics/04-01-SUMMARY.md

# Key existing files to reference
@src/lib/competitors-utils.ts                    # computeAverageViews, computeHashtagFrequency, computeEngagementRate, VideoMetrics
@src/lib/supabase/service.ts                     # createServiceClient pattern
@src/types/database.types.ts                     # Existing DB types (add competitor_intelligence)
@src/app/(app)/competitors/[handle]/page.tsx      # Detail page server component (consumers pattern)
@src/app/(app)/competitors/compare/page.tsx       # resolveHandle("me") pattern for user's own data
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database migration, types, Zod schemas, and prompt templates</name>
  <files>
    supabase/migrations/20260217000000_competitor_intelligence.sql
    src/types/database.types.ts
    src/lib/ai/types.ts
    src/lib/ai/prompts.ts
  </files>
  <action>
**1. Migration file** (`supabase/migrations/20260217000000_competitor_intelligence.sql`):

Create `competitor_intelligence` table exactly as specified in RESEARCH.md:
- `id` UUID PK with gen_random_uuid()
- `competitor_id` UUID NOT NULL FK to competitor_profiles(id) ON DELETE CASCADE
- `analysis_type` TEXT NOT NULL with CHECK constraint: `('strategy', 'viral', 'hashtag_gap', 'recommendations')`
- `insights` JSONB NOT NULL
- `model_used` TEXT nullable
- `prompt_tokens` INTEGER nullable
- `completion_tokens` INTEGER nullable
- `generated_at` TIMESTAMPTZ NOT NULL DEFAULT NOW()
- `user_id` UUID nullable FK to auth.users(id) ON DELETE CASCADE (only used for hashtag_gap which is user-specific)
- `created_at` TIMESTAMPTZ DEFAULT NOW()
- UNIQUE constraint on `(competitor_id, analysis_type, COALESCE(user_id, '00000000-0000-0000-0000-000000000000'))` for upsert support
- Index on `(competitor_id, analysis_type)`
- Enable RLS with SELECT policy: visible if `competitor_id IN (SELECT competitor_id FROM user_competitors WHERE user_id = (SELECT auth.uid()))` -- matches existing RLS pattern from competitor_snapshots/videos
- INSERT/UPDATE policy for service role (or use service client which bypasses RLS -- follow existing pattern)

**2. Database types** (`src/types/database.types.ts`):

Add `competitor_intelligence` table types inline (same pattern as existing competitor tables -- see phase 02-competitor-management decision: "Added competitor table types to database.types.ts inline"):
```typescript
competitor_intelligence: {
  Row: {
    id: string
    competitor_id: string
    analysis_type: string
    insights: Json
    model_used: string | null
    prompt_tokens: number | null
    completion_tokens: number | null
    generated_at: string
    user_id: string | null
    created_at: string | null
  }
  Insert: {
    id?: string
    competitor_id: string
    analysis_type: string
    insights: Json
    model_used?: string | null
    prompt_tokens?: number | null
    completion_tokens?: number | null
    generated_at?: string
    user_id?: string | null
    created_at?: string | null
  }
  Update: {
    id?: string
    competitor_id?: string
    analysis_type?: string
    insights?: Json
    model_used?: string | null
    prompt_tokens?: number | null
    completion_tokens?: number | null
    generated_at?: string
    user_id?: string | null
    created_at?: string | null
  }
  Relationships: [{
    foreignKeyName: "competitor_intelligence_competitor_id_fkey"
    columns: ["competitor_id"]
    isOneToOne: false
    referencedRelation: "competitor_profiles"
    referencedColumns: ["id"]
  }]
}
```

**3. Zod schemas** (`src/lib/ai/types.ts`):

Define Zod schemas and inferred TypeScript types for all 4 analysis response types. Use `z.object()` for structured validation. Export both schemas and types.

```typescript
// StrategyAnalysisSchema (INTL-01) -- DeepSeek
// hooks: array of { pattern: string, frequency: number, example: string }
// content_series: array of { name: string, description: string, video_count: number }
// psychological_triggers: string[]
// overall_strategy: string (2-3 paragraphs)
// strengths: string[] (3-5 items)
// weaknesses: string[] (3-5 items)

// ViralExplanationSchema (INTL-02) -- Gemini
// videos: array of { caption: string, views: number, viral_multiplier: number, explanation: string, key_factors: string[] }

// HashtagGapSchema (INTL-03) -- Gemini
// competitor_only: array of { tag: string, count: number, recommendation: string }
// user_only: array of { tag: string, count: number, assessment: string }
// shared: array of { tag: string, competitor_count: number, user_count: number }
// overall_recommendation: string

// RecommendationsSchema (INTL-04) -- DeepSeek
// recommendations: array of { category: "format" | "timing" | "hooks" | "content_style", title: string, description: string, priority: "high" | "medium" | "low", action_items: string[] }
// summary: string
```

Also define a `CompetitorContext` type used as input to prompt builders:
```typescript
interface CompetitorContext {
  handle: string
  followerCount: number | null
  heartCount: number | null
  videoCount: number | null
  bio: string | null
  topHashtags: { tag: string; count: number }[]   // top 10
  cadence: { postsPerWeek: number; postsPerMonth: number } | null
  engagementRate: number | null
  averageViews: number | null
  growthVelocity: { percentage: number; direction: string } | null
  topVideoCaptions: { caption: string; views: number }[]  // top 5, captions truncated to 200 chars
  durationBreakdown: { label: string; percentage: number }[]
}
```

And a `ViralVideoInput` type for viral analysis:
```typescript
interface ViralVideoInput {
  caption: string | null
  views: number | null
  likes: number | null
  comments: number | null
  shares: number | null
  duration_seconds: number | null
  posted_at: string | null
  hashtags: string[] | null
  viralMultiplier: number  // e.g., 12.5 means 12.5x average
}
```

**4. Prompt templates** (`src/lib/ai/prompts.ts`):

Export 4 prompt builder functions. Each takes structured data and returns a string prompt. Follow these guidelines from RESEARCH.md:
- Pre-aggregate data, NEVER send raw arrays
- Keep prompts focused: one analysis type per prompt
- Include output format instructions in the prompt (JSON structure description)
- Truncate captions to 200 chars

`buildStrategyPrompt(ctx: CompetitorContext): string` -- Analyze content strategy for a TikTok creator. Ask for hooks, patterns, psychological triggers, content series, strengths, weaknesses. Include the JSON output format in the system instruction.

`buildViralPrompt(competitorHandle: string, averageViews: number, viralVideos: ViralVideoInput[]): string` -- For each viral video (limit to top 5), explain why it went viral. Include baseline average views for context.

`buildHashtagGapPrompt(competitorHandle: string, competitorOnly: { tag: string; count: number }[], userOnly: { tag: string; count: number }[], shared: { tag: string; competitorCount: number; userCount: number }[]): string` -- Analyze hashtag gaps and give actionable recommendations. Limit to top 10 each category.

`buildRecommendationsPrompt(ctx: CompetitorContext, strategyHighlights?: string, viralPatterns?: string): string` -- Generate personalized recommendations across 4 categories (format, timing, hooks, content_style). If strategy/viral data available, reference it for deeper recommendations.

All prompts should instruct the model to respond ONLY with valid JSON matching the expected schema. No markdown, no explanation text.
  </action>
  <verify>
- `npx tsc --noEmit` passes (types compile correctly)
- Migration SQL is valid (no syntax errors)
- All 4 Zod schemas export from `src/lib/ai/types.ts`
- All 4 prompt builders export from `src/lib/ai/prompts.ts`
  </verify>
  <done>
- `competitor_intelligence` migration file exists with table, index, RLS policy, unique constraint
- `database.types.ts` includes `competitor_intelligence` Row/Insert/Update/Relationships
- 4 Zod schemas with inferred types exported from `types.ts`
- 4 prompt builder functions exported from `prompts.ts`, each returning well-structured prompts that include JSON format instructions
  </done>
</task>

<task type="auto">
  <name>Task 2: AI client modules, intelligence service orchestrator, and API route</name>
  <files>
    src/lib/ai/deepseek.ts
    src/lib/ai/gemini.ts
    src/lib/ai/intelligence-service.ts
    src/app/api/intelligence/[competitorId]/route.ts
  </files>
  <action>
**Install dependencies first:**
```bash
npm install openai @google/genai
```

**1. DeepSeek client** (`src/lib/ai/deepseek.ts`):

Lazy-initialized singleton pattern (proven in backend-foundation):
```typescript
import OpenAI from "openai";
let client: OpenAI | null = null;
function getClient(): OpenAI {
  if (!client) {
    const apiKey = process.env.DEEPSEEK_API_KEY;
    if (!apiKey) throw new Error("Missing DEEPSEEK_API_KEY");
    client = new OpenAI({ apiKey, baseURL: "https://api.deepseek.com" });
  }
  return client;
}
```

Export two functions:
- `analyzeStrategy(ctx: CompetitorContext): Promise<StrategyAnalysis>` -- Calls DeepSeek `deepseek-chat` with `response_format: { type: "json_object" }`. Uses `buildStrategyPrompt`. Strips markdown fences before JSON.parse, then validates with `StrategyAnalysisSchema.parse()`. Returns parsed+validated result. Also returns `{ analysis, usage: { prompt_tokens, completion_tokens } }` for tracking.

- `generateRecommendations(ctx: CompetitorContext, strategyHighlights?: string, viralPatterns?: string): Promise<Recommendations>` -- Same pattern, uses `buildRecommendationsPrompt`, validates with `RecommendationsSchema`.

Helper: `stripFences(text: string): string` -- Removes ```json ... ``` and `<think>...</think>` wrappers that DeepSeek sometimes adds. Export for testing.

Both functions should use a shared `callDeepSeek(prompt: string, schema: ZodType)` internal helper to avoid duplication. Include basic retry (1 retry on parse failure with a "Please respond with valid JSON only" append).

**2. Gemini client** (`src/lib/ai/gemini.ts`):

Lazy-initialized singleton:
```typescript
import { GoogleGenAI } from "@google/genai";
let client: GoogleGenAI | null = null;
function getClient(): GoogleGenAI {
  if (!client) {
    const apiKey = process.env.GEMINI_API_KEY;
    if (!apiKey) throw new Error("Missing GEMINI_API_KEY");
    client = new GoogleGenAI({ apiKey });
  }
  return client;
}
```

Export two functions:
- `explainViralVideos(handle: string, avgViews: number, viralVideos: ViralVideoInput[]): Promise<ViralExplanation>` -- Uses Gemini `gemini-2.5-flash-lite` with `responseMimeType: "application/json"`. Uses `buildViralPrompt`. Validates with `ViralExplanationSchema.parse()`.

- `analyzeHashtagGap(handle: string, competitorOnly: ..., userOnly: ..., shared: ...): Promise<HashtagGap>` -- Same pattern, uses `buildHashtagGapPrompt`, validates with `HashtagGapSchema`.

Both should use a shared `callGemini(prompt: string, schema: ZodType)` internal helper.

**3. Intelligence service orchestrator** (`src/lib/ai/intelligence-service.ts`):

This is the caching + coordination layer. Uses the service client (from `@/lib/supabase/service`) for writes (bypasses RLS) and the user's client for reads (respects RLS).

Export 5 functions:
- `getStrategyAnalysis(supabase, competitorId, ctx)` -- Check cache (competitor_intelligence where analysis_type='strategy'), compare `generated_at` vs profile's `last_scraped_at` for staleness (stale if generated_at < last_scraped_at OR > 7 days old). If fresh cache, return `insights` cast to `StrategyAnalysis`. If stale/missing, call `analyzeStrategy()`, upsert result into `competitor_intelligence` via service client (ON CONFLICT update), return fresh analysis.

- `getViralDetection(supabase, competitorId, videos, averageViews)` -- First, detect viral videos (views > avgViews * 3) using pure computation. If no viral videos, return `{ videos: [] }`. If viral videos exist, check cache. If stale/missing, call `explainViralVideos()`, cache, return.

- `getHashtagGap(supabase, competitorId, userId, competitorVideos, userVideos)` -- Pure computation for gap data using `computeHashtagFrequency`. Then check cache (this one includes user_id in the unique key since it's user-specific). If stale/missing, call `analyzeHashtagGap()`, cache with user_id, return.

- `getRecommendations(supabase, competitorId, ctx, strategyHighlights?, viralPatterns?)` -- Check cache. If stale/missing, call `generateRecommendations()`, cache, return.

- `getAllIntelligence(supabase, competitorId)` -- Simple read: fetch all cached rows for this competitor, return a map of `{ strategy?, viral?, hashtag_gap?, recommendations? }`. This is what the detail page server component will call for initial render.

Internal helper: `checkCache(supabase, competitorId, analysisType, userId?)` -- Query competitor_intelligence, return cached row or null. `isStale(generatedAt, lastScrapedAt)` -- Returns true if generated_at < lastScrapedAt or generated_at is > 7 days ago.

For upserts, use the service client: `createServiceClient().from("competitor_intelligence").upsert({ ... }, { onConflict: "competitor_id,analysis_type,COALESCE(user_id, '00000000-0000-0000-0000-000000000000')" })`. This handles the race condition documented in RESEARCH.md pitfall 5.

**Important:** The upsert onConflict with COALESCE may not work directly via Supabase JS. Alternative: use `.insert()` with a raw ON CONFLICT clause, or simply delete+insert. Use insert + catch unique violation as fallback.

**4. API route** (`src/app/api/intelligence/[competitorId]/route.ts`):

**GET handler:** Retrieve cached intelligence for a competitor. Auth check (createClient -> getUser -> verify junction). Call `getAllIntelligence()`. Return JSON.

**POST handler:** Trigger a specific analysis. Auth check. Parse body: `{ analysis_type: "strategy" | "viral" | "hashtag_gap" | "recommendations" }`. Fetch competitor profile + videos + snapshots as needed. Build CompetitorContext from the data (using existing utils: computeHashtagFrequency, computeAverageViews, computeEngagementRate, computeGrowthVelocity, computePostingCadence, computeDurationBreakdown). Call the appropriate service function. Return the fresh analysis as JSON.

For hashtag_gap, need to also fetch user's own videos:
1. Get user's tiktok_handle from creator_profiles
2. Look up their competitor_profile + videos
3. If no self-tracking data, return `{ error: "Set your TikTok handle to enable hashtag gap analysis" }`

Use `export const maxDuration = 60;` for timeout (AI calls can take 10-30s).
  </action>
  <verify>
- `npx tsc --noEmit` passes
- `npm install openai @google/genai` completes successfully
- All exports from deepseek.ts, gemini.ts, intelligence-service.ts compile
- API route file exists with GET and POST exports
- No AI library imports leak to any file outside `src/lib/ai/` and `src/app/api/intelligence/`
  </verify>
  <done>
- `openai` and `@google/genai` installed in package.json
- DeepSeek client calls `deepseek-chat` with JSON mode, strips fences, validates with Zod
- Gemini client calls `gemini-2.5-flash-lite` with JSON response mime type, validates with Zod
- Intelligence service checks database cache before calling AI, upserts results with token tracking
- API route authenticates user, verifies junction ownership, delegates to service layer
- All AI-related code confined to `src/lib/ai/` and `src/app/api/intelligence/`
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- zero type errors
2. Migration SQL is syntactically valid
3. No `openai` or `@google/genai` imports in any file under `src/components/` or `src/app/(app)/` (server-only enforcement)
4. All 4 analysis types have: Zod schema, prompt builder, AI client function, service orchestrator function
5. Service layer uses database caching with staleness check (7-day TTL or newer scrape data)
</verification>

<success_criteria>
- Complete AI service layer compiles with zero type errors
- All 4 analysis types end-to-end: prompt -> AI call -> Zod validation -> DB cache -> retrieval
- API route handles both GET (cached retrieval) and POST (trigger analysis) with proper auth
- Intelligence service prevents redundant AI calls via database caching
</success_criteria>

<output>
After completion, create `.planning/phases/06-ai-intelligence/06-01-SUMMARY.md`
</output>
